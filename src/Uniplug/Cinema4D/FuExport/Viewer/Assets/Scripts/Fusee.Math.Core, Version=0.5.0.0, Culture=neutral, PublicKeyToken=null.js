/* Generated by JSIL v0.8.1 build 26046. See http://jsil.org/ for more information. */ 
'use strict';
var $asm04 = JSIL.DeclareAssembly("Fusee.Math.Core, Version=0.5.0.0, Culture=neutral, PublicKeyToken=null");

JSIL.DeclareNamespace("Fusee");
JSIL.DeclareNamespace("Fusee.Math");
/* struct Fusee.Math.AABBf */ 

(function AABBf$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Math.float3)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Math.float4x4)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize(System.Array.Of($asm04.Fusee.Math.float3))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.System.Int32)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$asm04.TypeRef("Fusee.Math.float3"), $asm07.TypeRef("System.Single")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float3"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$asm04.TypeRef("Fusee.Math.float4x4"), $asm04.TypeRef("Fusee.Math.float3")]))) ();
  };

  function AABBf__ctor (min_, max_) {
    this.min = min_.MemberwiseClone();
    this.max = max_.MemberwiseClone();
  };

  function AABBf_get_Center () {
    return $S00().CallStatic($T00(), "op_Multiply", null, $T00().op_Addition(this.max.MemberwiseClone(), this.min).MemberwiseClone(), 0.5);
  };

  function AABBf_get_Size () {
    return $T00().op_Subtraction(this.max.MemberwiseClone(), this.min);
  };

  function AABBf_op_Multiply (m, box) {
    var result = new $thisType();
    var array = JSIL.Array.New($T00(), [$S01().Construct(box.min.x, box.min.y, box.min.z), $S01().Construct(box.min.x, box.min.y, box.max.z), $S01().Construct(box.min.x, box.max.y, box.min.z), $S01().Construct(box.min.x, box.max.y, box.max.z), $S01().Construct(box.max.x, box.min.y, box.min.z), $S01().Construct(box.max.x, box.min.y, box.max.z), $S01().Construct(box.max.x, box.max.y, box.min.z), $S01().Construct(box.max.x, box.max.y, box.max.z)]);

    for (var i = 0; i < 8; i = ((i + 1) | 0)) {
      array[i] = $S02().CallStatic($T01(), "op_Multiply", null, m, array[i]);
    }
    result.min = array[0].MemberwiseClone();
    result.max = array[0].MemberwiseClone();

    for (i = 1; i < 8; i = ((i + 1) | 0)) {
      if (+array[i].x < +result.min.x) {
        result.min.x = +array[i].x;
      }
      if (+array[i].y < +result.min.y) {
        result.min.y = +array[i].y;
      }
      if (+array[i].z < +result.min.z) {
        result.min.z = +array[i].z;
      }
      if (+array[i].x > +result.max.x) {
        result.max.x = +array[i].x;
      }
      if (+array[i].y > +result.max.y) {
        result.max.y = +array[i].y;
      }
      if (+array[i].z > +result.max.z) {
        result.max.z = +array[i].z;
      }
    }
    return result;
  };

  function AABBf_Union (a, b) {
    var result = new $thisType();
    result.min.x = +(
      (+a.min.x < +b.min.x)
         ? a.min.x
         : b.min.x)
    ;
    result.min.y = +(
      (+a.min.y < +b.min.y)
         ? a.min.y
         : b.min.y)
    ;
    result.min.z = +(
      (+a.min.z < +b.min.z)
         ? a.min.z
         : b.min.z)
    ;
    result.max.x = +(
      (+a.max.x > +b.max.x)
         ? a.max.x
         : b.max.x)
    ;
    result.max.y = +(
      (+a.max.y > +b.max.y)
         ? a.max.y
         : b.max.y)
    ;
    result.max.z = +(
      (+a.max.z > +b.max.z)
         ? a.max.z
         : b.max.z)
    ;
    return result;
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.AABBf", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.float3"), $asm04.TypeRef("Fusee.Math.float3")]), 
      AABBf__ctor
    );

    $.Method({Static:false, Public:true }, "get_Center", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.float3")), 
      AABBf_get_Center
    );

    $.Method({Static:false, Public:true }, "get_Size", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.float3")), 
      AABBf_get_Size
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.float4x4"), $.Type]), 
      AABBf_op_Multiply
    );

    $.Method({Static:true , Public:true }, "Union", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      AABBf_Union
    );

    $.Field({Static:false, Public:true }, "min", $asm04.TypeRef("Fusee.Math.float3"))
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [1]; }); 
    $.Field({Static:false, Public:true }, "max", $asm04.TypeRef("Fusee.Math.float3"))
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [2]; }); 
    $.Property({Static:false, Public:true }, "Center", $asm04.TypeRef("Fusee.Math.float3"));

    $.Property({Static:false, Public:true }, "Size", $asm04.TypeRef("Fusee.Math.float3"));

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm08.TypeRef("ProtoBuf.ProtoContractAttribute"));

})();

/* struct Fusee.Math.double2 */ 

(function double2$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm07.System.Double)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Math.double3)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Math.double4)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.System.Math)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm04.Fusee.Math.MathHelper)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm07.System.Converter$b2.Of($asm07.System.String, $asm04.Fusee.Math.double2))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm07.System.String)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm04.Fusee.Math.QuaternionD)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double2"), [$asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double2"), [$asm07.TypeRef("System.Double"), $asm04.TypeRef("Fusee.Math.double2")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double2")]), $asm07.TypeRef("System.Double"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double2")])
      ]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double2")]), $asm07.TypeRef("System.Double"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double2")])
      ]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double2")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double2")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double2")])
      ]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("System.Double"), [$asm07.TypeRef("System.Double")]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double2")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double2")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double2")])
      ]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.QuaternionD"), [
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double")
      ]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")])
      ]))) ();
  };

  function double2__ctor$00 (x, y) {
    this.x = +x;
    this.y = +y;
  };

  function double2__ctor$01 (v) {
    this.x = +v.x;
    this.y = +v.y;
  };

  function double2__ctor$02 (v) {
    this.x = +v.x;
    this.y = +v.y;
  };

  function double2__ctor$03 (v) {
    this.x = +v.x;
    this.y = +v.y;
  };

  function double2_Add$04 (right) {
    this.x += +right.x;
    this.y += +right.y;
  };

  function double2_Add$05 (/* ref */ right) {
    this.x += +right.get().x;
    this.y += +right.get().y;
  };

  function double2_Add$06 ($a, $b) {
    var b = new JSIL.BoxedVariable($b.MemberwiseClone());
    var a = new JSIL.BoxedVariable($a.MemberwiseClone());
    $thisType.Add(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  };

  function double2_Add$07 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((+a.get().x + +b.get().x), (+a.get().y + +b.get().y)));
  };

  function double2_BaryCentric$08 (a, b, c, u, v) {
    return $thisType.op_Addition(
      $thisType.op_Addition(a.MemberwiseClone(), $S01().CallStatic($thisType, "op_Multiply", null, u, $thisType.op_Subtraction(b.MemberwiseClone(), a).MemberwiseClone())).MemberwiseClone(), 
      $S01().CallStatic($thisType, "op_Multiply", null, v, $thisType.op_Subtraction(c.MemberwiseClone(), a).MemberwiseClone())
    );
  };

  function double2_BaryCentric$09 (/* ref */ a, /* ref */ b, /* ref */ c, u, v, /* ref */ result) {
    result.set(a.get().MemberwiseClone());
    var double = new JSIL.BoxedVariable(b.get().MemberwiseClone());
    $thisType.Subtract(/* ref */ double, /* ref */ a, /* ref */ double);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ double, u, /* ref */ double);
    $thisType.Add(/* ref */ result, /* ref */ double, /* ref */ result);
    double.set(c.get().MemberwiseClone());
    $thisType.Subtract(/* ref */ double, /* ref */ a, /* ref */ double);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ double, v, /* ref */ double);
    $thisType.Add(/* ref */ result, /* ref */ double, /* ref */ result);
  };

  function double2_Clamp$0A (vec, min, max) {
    vec.x = +(
      (+vec.x < +min.x)
         ? min.x
         : (
          (+vec.x > +max.x)
             ? max.x
             : vec.x)
    )
    ;
    vec.y = +(
      (+vec.y < +min.y)
         ? min.y
         : (
          (+vec.y > +max.y)
             ? max.y
             : vec.y)
    )
    ;
    return vec;
  };

  function double2_Clamp$0B (/* ref */ vec, /* ref */ min, /* ref */ max, /* ref */ result) {
    result.get().x = +(
      (+vec.get().x < +min.get().x)
         ? min.get().x
         : (
          (+vec.get().x > +max.get().x)
             ? max.get().x
             : vec.get().x)
    )
    ;
    result.get().y = +(
      (+vec.get().y < +min.get().y)
         ? min.get().y
         : (
          (+vec.get().y > +max.get().y)
             ? max.get().y
             : vec.get().y)
    )
    ;
  };

  function double2_ComponentMax$0C (a, b) {
    a.x = +(
      (+a.x > +b.x)
         ? a.x
         : b.x)
    ;
    a.y = +(
      (+a.y > +b.y)
         ? a.y
         : b.y)
    ;
    return a;
  };

  function double2_ComponentMax$0D (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(
      (+a.get().x > +b.get().x)
         ? a.get().x
         : b.get().x)
    ;
    result.get().y = +(
      (+a.get().y > +b.get().y)
         ? a.get().y
         : b.get().y)
    ;
  };

  function double2_ComponentMin$0E (a, b) {
    a.x = +(
      (+a.x < +b.x)
         ? a.x
         : b.x)
    ;
    a.y = +(
      (+a.y < +b.y)
         ? a.y
         : b.y)
    ;
    return a;
  };

  function double2_ComponentMin$0F (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(
      (+a.get().x < +b.get().x)
         ? a.get().x
         : b.get().x)
    ;
    result.get().y = +(
      (+a.get().y < +b.get().y)
         ? a.get().y
         : b.get().y)
    ;
  };

  function double2_Div$10 (f) {
    var num = +((1 / +f));
    this.x *= num;
    this.y *= num;
  };

  function double2_Div$11 (a, f) {
    var num = +((1 / +f));
    a.x *= num;
    a.y *= num;
    return a;
  };

  function double2_Div$12 (/* ref */ a, f, /* ref */ result) {
    var num = +((1 / +f));
    result.get().x = +a.get().x * num;
    result.get().y = +a.get().y * num;
  };

  function double2_Divide$13 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S03().CallStatic($thisType, "Divide", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  };

  function double2_Divide$14 (/* ref */ vector, scale, /* ref */ result) {
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vector, +((1 / +scale)), /* ref */ result);
  };

  function double2_Divide$15 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale.MemberwiseClone());
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S04().CallStatic($thisType, "Divide", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  };

  function double2_Divide$16 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct(+((+vector.get().x / +scale.get().x)), +((+vector.get().y / +scale.get().y))));
  };

  function double2_Dot$17 (left, right) {
    return ((+left.x * +right.x) + (+left.y * +right.y));
  };

  function double2_Dot$18 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set((+left.get().x * +right.get().x) + (+left.get().y * +right.get().y));
  };

  function double2_Object_Equals (obj) {
    return ($thisType.$Is(obj) && this.Equals($thisType.$Cast(obj)));
  };

  function double2_Equals$19 (other) {
    return ((+this.x === +other.x) && (+this.y === +other.y));
  };

  function double2_get_Length () {
    return Math.sqrt(((+this.x * +this.x) + (+this.y * +this.y)));
  };

  function double2_get_LengthFast () {
    return +((1 / +$S05().CallStatic($T05(), "InverseSqrtFast", null, (+this.x * +this.x) + (+this.y * +this.y))));
  };

  function double2_get_LengthSquared () {
    return ((+this.x * +this.x) + (+this.y * +this.y));
  };

  function double2_get_Parse () {
    return $thisType.double2$Parse$value;
  };

  function double2_get_PerpendicularLeft () {
    return $S00().Construct(-this.y, this.x);
  };

  function double2_get_PerpendicularRight () {
    return $S00().Construct(this.y, -this.x);
  };

  function double2_GetHashCode () {
    return (((this.x).GetHashCode() | 0) ^ ((this.y).GetHashCode() | 0));
  };

  function double2_Lerp$1A (a, b, blend) {
    a.x = (+blend * (+b.x - +a.x)) + +a.x;
    a.y = (+blend * (+b.y - +a.y)) + +a.y;
    return a;
  };

  function double2_Lerp$1B (/* ref */ a, /* ref */ b, blend, /* ref */ result) {
    result.get().x = (+blend * (+b.get().x - +a.get().x)) + +a.get().x;
    result.get().y = (+blend * (+b.get().y - +a.get().y)) + +a.get().y;
  };

  function double2_Max (left, right) {
    return (
      (+left.get_LengthSquared() >= +right.get_LengthSquared())
         ? left
         : right)
    ;
  };

  function double2_Min (left, right) {
    return (
      (+left.get_LengthSquared() < +right.get_LengthSquared())
         ? left
         : right)
    ;
  };

  function double2_Mult$1C (f) {
    this.x *= +f;
    this.y *= +f;
  };

  function double2_Mult$1D (a, f) {
    a.x *= +f;
    a.y *= +f;
    return a;
  };

  function double2_Mult$1E (/* ref */ a, f, /* ref */ result) {
    result.get().x = +a.get().x * +f;
    result.get().y = +a.get().y * +f;
  };

  function double2_Multiply$1F ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  };

  function double2_Multiply$20 (/* ref */ vector, scale, /* ref */ result) {
    result.set($S00().Construct((+vector.get().x * +scale), (+vector.get().y * +scale)));
  };

  function double2_Multiply$21 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale.MemberwiseClone());
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S06().CallStatic($thisType, "Multiply", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  };

  function double2_Multiply$22 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct((+vector.get().x * +scale.get().x), (+vector.get().y * +scale.get().y)));
  };

  function double2_Normalize$23 () {
    var num = +((1 / +this.get_Length()));
    this.x *= num;
    this.y *= num;
  };

  function double2_Normalize$24 (vec) {
    var num = +((1 / +vec.get_Length()));
    vec.x *= num;
    vec.y *= num;
    return vec;
  };

  function double2_Normalize$25 (/* ref */ vec, /* ref */ result) {
    var num = +((1 / +(vec.get()).get_Length()));
    result.get().x = +vec.get().x * num;
    result.get().y = +vec.get().y * num;
  };

  function double2_NormalizeFast$26 () {
    var num = +$S05().CallStatic($T05(), "InverseSqrtFast", null, (+this.x * +this.x) + (+this.y * +this.y));
    this.x *= num;
    this.y *= num;
  };

  function double2_NormalizeFast$27 (vec) {
    var num = +$S05().CallStatic($T05(), "InverseSqrtFast", null, (+vec.x * +vec.x) + (+vec.y * +vec.y));
    vec.x *= num;
    vec.y *= num;
    return vec;
  };

  function double2_NormalizeFast$28 (/* ref */ vec, /* ref */ result) {
    var num = +$S05().CallStatic($T05(), "InverseSqrtFast", null, (+vec.get().x * +vec.get().x) + (+vec.get().y * +vec.get().y));
    result.get().x = +vec.get().x * num;
    result.get().y = +vec.get().y * num;
  };

  function double2_op_Addition (left, right) {
    left.x += +right.x;
    left.y += +right.y;
    return left;
  };

  function double2_op_Division (vec, scale) {
    var num = +((1 / +scale));
    vec.x *= num;
    vec.y *= num;
    return vec;
  };

  function double2_op_Equality (left, right) {
    return left.Equals(right);
  };

  function double2_op_Inequality (left, right) {
    return !left.Equals(right);
  };

  function double2_op_Multiply$29 (vec, scale) {
    vec.x *= +scale;
    vec.y *= +scale;
    return vec;
  };

  function double2_op_Multiply$2A (scale, vec) {
    vec.x *= +scale;
    vec.y *= +scale;
    return vec;
  };

  function double2_op_Subtraction (left, right) {
    left.x -= +right.x;
    left.y -= +right.y;
    return left;
  };

  function double2_op_UnaryNegation (vec) {
    vec.x = -vec.x;
    vec.y = -vec.y;
    return vec;
  };

  function double2_Scale$2B (sx, sy) {
    this.x *= +sx;
    this.y *= +sy;
  };

  function double2_Scale$2C (scale) {
    this.x *= +scale.x;
    this.y *= +scale.y;
  };

  function double2_Scale$2D (/* ref */ scale) {
    this.x *= +scale.get().x;
    this.y *= +scale.get().y;
  };

  function double2_set_Parse (value) {
    $thisType.double2$Parse$value = value;
  };

  function double2_Sub$2E (right) {
    this.x -= +right.x;
    this.y -= +right.y;
  };

  function double2_Sub$2F (/* ref */ right) {
    this.x -= +right.get().x;
    this.y -= +right.get().y;
  };

  function double2_Sub$30 (a, b) {
    a.x -= +b.x;
    a.y -= +b.y;
    return a;
  };

  function double2_Sub$31 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +a.get().x - +b.get().x;
    result.get().y = +a.get().y - +b.get().y;
  };

  function double2_Subtract$32 ($a, $b) {
    var b = new JSIL.BoxedVariable($b.MemberwiseClone());
    var a = new JSIL.BoxedVariable($a.MemberwiseClone());
    $thisType.Subtract(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  };

  function double2_Subtract$33 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((+a.get().x - +b.get().x), (+a.get().y - +b.get().y)));
  };

  function double2_ToArray () {
    return JSIL.Array.New($T00(), [this.x, this.y]);
  };

  function double2_toString () {
    return $T07().Format("({0}, {1})", this.x, this.y);
  };

  function double2_Transform$34 ($vec, $quat) {
    var quat = new JSIL.BoxedVariable($quat.MemberwiseClone());
    var vec = new JSIL.BoxedVariable($vec.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.Transform(/* ref */ vec, /* ref */ quat, /* ref */ result);
    return result.get();
  };

  function double2_Transform$35 (/* ref */ vec, /* ref */ quat, /* ref */ result) {
    var quaternionD2 = new JSIL.BoxedVariable(new ($T08())());
    var quaternionD3 = new JSIL.BoxedVariable(new ($T08())());
    var quaternionD = new JSIL.BoxedVariable($S07().Construct(vec.get().x, vec.get().y, 0, 0));
    $T08().Invert(/* ref */ quat, /* ref */ quaternionD2);
    $S08().CallStatic($T08(), "Multiply", null, /* ref */ quat, /* ref */ quaternionD, /* ref */ quaternionD3);
    $S08().CallStatic($T08(), "Multiply", null, /* ref */ quaternionD3, /* ref */ quaternionD2, /* ref */ quaternionD);
    result.set($S00().Construct((quaternionD.get()).get_x(), (quaternionD.get()).get_y()));
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.double2", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.Double, $.Double]), 
      double2__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Type), 
      double2__ctor$01
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"));

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.double3")), 
      double2__ctor$02
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"));

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.double4")), 
      double2__ctor$03
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"));

    $.Method({Static:false, Public:true }, "Add", 
      JSIL.MethodSignature.Action($.Type), 
      double2_Add$04
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:false, Public:true }, "Add", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      double2_Add$05
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double2_Add$06
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_Add$07
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type, $.Double, 
          $.Double
        ]), 
      double2_BaryCentric$08
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_BaryCentric$09
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type
        ]), 
      double2_Clamp$0A
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_Clamp$0B
    );

    $.Method({Static:true , Public:true }, "ComponentMax", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double2_ComponentMax$0C
    );

    $.Method({Static:true , Public:true }, "ComponentMax", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_ComponentMax$0D
    );

    $.Method({Static:true , Public:true }, "ComponentMin", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double2_ComponentMin$0E
    );

    $.Method({Static:true , Public:true }, "ComponentMin", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_ComponentMin$0F
    );

    $.Method({Static:false, Public:true }, "Div", 
      JSIL.MethodSignature.Action($.Double), 
      double2_Div$10
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double2_Div$11
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_Div$12
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double2_Divide$13
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_Divide$14
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double2_Divide$15
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_Divide$16
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature($.Double, [$.Type, $.Type]), 
      double2_Dot$17
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Double])
        ]), 
      double2_Dot$18
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      double2_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type]), 
      double2_Equals$19
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      JSIL.MethodSignature.Return($.Double), 
      double2_get_Length
    );

    $.Method({Static:false, Public:true }, "get_LengthFast", 
      JSIL.MethodSignature.Return($.Double), 
      double2_get_LengthFast
    );

    $.Method({Static:false, Public:true }, "get_LengthSquared", 
      JSIL.MethodSignature.Return($.Double), 
      double2_get_LengthSquared
    );

    $.Method({Static:true , Public:true }, "get_Parse", 
      JSIL.MethodSignature.Return($asm07.TypeRef("System.Converter`2", [$.String, $.Type])), 
      double2_get_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_PerpendicularLeft", 
      JSIL.MethodSignature.Return($.Type), 
      double2_get_PerpendicularLeft
    );

    $.Method({Static:false, Public:true }, "get_PerpendicularRight", 
      JSIL.MethodSignature.Return($.Type), 
      double2_get_PerpendicularRight
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32), 
      double2_GetHashCode
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Double
        ]), 
      double2_Lerp$1A
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_Lerp$1B
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double2_Max
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double2_Min
    );

    $.Method({Static:false, Public:true }, "Mult", 
      JSIL.MethodSignature.Action($.Double), 
      double2_Mult$1C
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double2_Mult$1D
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_Mult$1E
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double2_Multiply$1F
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_Multiply$20
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double2_Multiply$21
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_Multiply$22
    );

    $.Method({Static:false, Public:true }, "Normalize", 
      JSIL.MethodSignature.Void, 
      double2_Normalize$23
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      double2_Normalize$24
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double2_Normalize$25
    );

    $.Method({Static:false, Public:true }, "NormalizeFast", 
      JSIL.MethodSignature.Void, 
      double2_NormalizeFast$26
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      double2_NormalizeFast$27
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double2_NormalizeFast$28
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double2_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Division", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double2_op_Division
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      double2_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      double2_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double2_op_Multiply$29
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Double, $.Type]), 
      double2_op_Multiply$2A
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double2_op_Subtraction
    );

    $.Method({Static:true , Public:true }, "op_UnaryNegation", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      double2_op_UnaryNegation
    );

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [$.Double, $.Double]), 
      double2_Scale$2B
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      JSIL.MethodSignature.Action($.Type), 
      double2_Scale$2C
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      double2_Scale$2D
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "set_Parse", 
      JSIL.MethodSignature.Action($asm07.TypeRef("System.Converter`2", [$.String, $.Type])), 
      double2_set_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "Sub", 
      JSIL.MethodSignature.Action($.Type), 
      double2_Sub$2E
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:false, Public:true }, "Sub", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      double2_Sub$2F
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double2_Sub$30
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_Sub$31
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double2_Subtract$32
    );

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_Subtract$33
    );

    $.Method({Static:false, Public:true }, "ToArray", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Double])), 
      double2_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      double2_toString
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.QuaternionD")]), 
      double2_Transform$34
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double2_Transform$35
    );

    $.Field({Static:false, Public:true }, "x", $.Double); 
    $.Field({Static:false, Public:true }, "y", $.Double); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitX", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitY", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "Zero", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "One", $.Type); 
    $.Field({Static:true , Public:false}, "double2$Parse$value", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]))
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    function double2__cctor () {
      $thisType.UnitX = new $thisType();
      $thisType.UnitY = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.One = new $thisType();
      $thisType.UnitX = $S00().Construct(1, 0);
      $thisType.UnitY = $S00().Construct(0, 1);
      $thisType.Zero = $S00().Construct(0, 0);
      $thisType.One = $S00().Construct(1, 1);
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      double2__cctor
    );

    $.Property({Static:false, Public:true }, "Length", $.Double);

    $.Property({Static:false, Public:true }, "LengthFast", $.Double);

    $.Property({Static:false, Public:true }, "LengthSquared", $.Double);

    $.Property({Static:false, Public:true }, "PerpendicularRight", $.Type);

    $.Property({Static:false, Public:true }, "PerpendicularLeft", $.Type);

    $.Property({Static:true , Public:true }, "Parse", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]));

    $.ImplementInterfaces(
      /* 0 */ $asm07.TypeRef("System.IEquatable`1", [$.Type])
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Math.double3 */ 

(function double3$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm07.System.Double)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Math.double2)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Math.double4)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.System.Math)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.System.Object)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm04.Fusee.Math.MathHelper)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm07.System.Converter$b2.Of($asm07.System.String, $asm04.Fusee.Math.double3))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm07.System.String)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm04.Fusee.Math.double4x4)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm04.Fusee.Math.QuaternionD)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double3"), [
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double3"), [$asm07.TypeRef("System.Double"), $asm04.TypeRef("Fusee.Math.double3")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")]), $asm07.TypeRef("System.Double"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")])
      ]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")]), $asm07.TypeRef("System.Double"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")])
      ]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")])
      ]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("System.Double"), [$asm07.TypeRef("System.Double")]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double2"), [$asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double")]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")])
      ]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4x4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")])
      ]))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double4"), [
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double")
      ]))) ();
  };
  var $S0A = function () {
    return ($S0A = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4x4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")])
      ]))) ();
  };
  var $S0B = function () {
    return ($S0B = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")])
      ]))) ();
  };
  var $S0C = function () {
    return ($S0C = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double3"), [$asm04.TypeRef("Fusee.Math.double4")]))) ();
  };
  var $S0D = function () {
    return ($S0D = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double4"), [$asm04.TypeRef("Fusee.Math.double3")]))) ();
  };

  function double3__ctor$00 (x, y, z) {
    this.x = +x;
    this.y = +y;
    this.z = +z;
  };

  function double3__ctor$01 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = 0;
  };

  function double3__ctor$02 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
  };

  function double3__ctor$03 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
  };

  function double3_Add$04 (right) {
    this.x += +right.x;
    this.y += +right.y;
    this.z += +right.z;
  };

  function double3_Add$05 (/* ref */ right) {
    this.x += +right.get().x;
    this.y += +right.get().y;
    this.z += +right.get().z;
  };

  function double3_Add$06 ($a, $b) {
    var b = new JSIL.BoxedVariable($b.MemberwiseClone());
    var a = new JSIL.BoxedVariable($a.MemberwiseClone());
    $thisType.Add(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  };

  function double3_Add$07 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((+a.get().x + +b.get().x), (+a.get().y + +b.get().y), (+a.get().z + +b.get().z)));
  };

  function double3_BaryCentric$08 (a, b, c, u, v) {
    return $thisType.op_Addition(
      $thisType.op_Addition(a.MemberwiseClone(), $S01().CallStatic($thisType, "op_Multiply", null, u, $thisType.op_Subtraction(b.MemberwiseClone(), a).MemberwiseClone())).MemberwiseClone(), 
      $S01().CallStatic($thisType, "op_Multiply", null, v, $thisType.op_Subtraction(c.MemberwiseClone(), a).MemberwiseClone())
    );
  };

  function double3_BaryCentric$09 (/* ref */ a, /* ref */ b, /* ref */ c, u, v, /* ref */ result) {
    result.set(a.get().MemberwiseClone());
    var double = new JSIL.BoxedVariable(b.get().MemberwiseClone());
    $thisType.Subtract(/* ref */ double, /* ref */ a, /* ref */ double);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ double, u, /* ref */ double);
    $thisType.Add(/* ref */ result, /* ref */ double, /* ref */ result);
    double.set(c.get().MemberwiseClone());
    $thisType.Subtract(/* ref */ double, /* ref */ a, /* ref */ double);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ double, v, /* ref */ double);
    $thisType.Add(/* ref */ result, /* ref */ double, /* ref */ result);
  };

  function double3_CalculateAngle$0A (first, second) {
    return Math.acos(+((+$thisType.Dot(first, second) / (+first.get_Length() * +second.get_Length()))));
  };

  function double3_CalculateAngle$0B (/* ref */ first, /* ref */ second, /* ref */ result) {
    var num = new JSIL.BoxedVariable(0);
    $thisType.Dot(/* ref */ first, /* ref */ second, /* ref */ num);
    result.set((Math.acos(+((+num.get() / (+(first.get()).get_Length() * +(second.get()).get_Length()))))));
  };

  function double3_Clamp$0C (vec, min, max) {
    vec.x = +(
      (+vec.x < +min.x)
         ? min.x
         : (
          (+vec.x > +max.x)
             ? max.x
             : vec.x)
    )
    ;
    vec.y = +(
      (+vec.y < +min.y)
         ? min.y
         : (
          (+vec.y > +max.y)
             ? max.y
             : vec.y)
    )
    ;
    vec.z = +(
      (+vec.z < +min.z)
         ? min.z
         : (
          (+vec.z > +max.z)
             ? max.z
             : vec.z)
    )
    ;
    return vec;
  };

  function double3_Clamp$0D (/* ref */ vec, /* ref */ min, /* ref */ max, /* ref */ result) {
    result.get().x = +(
      (+vec.get().x < +min.get().x)
         ? min.get().x
         : (
          (+vec.get().x > +max.get().x)
             ? max.get().x
             : vec.get().x)
    )
    ;
    result.get().y = +(
      (+vec.get().y < +min.get().y)
         ? min.get().y
         : (
          (+vec.get().y > +max.get().y)
             ? max.get().y
             : vec.get().y)
    )
    ;
    result.get().z = +(
      (+vec.get().z < +min.get().z)
         ? min.get().z
         : (
          (+vec.get().z > +max.get().z)
             ? max.get().z
             : vec.get().z)
    )
    ;
  };

  function double3_ComponentMax$0E (a, b) {
    a.x = +(
      (+a.x > +b.x)
         ? a.x
         : b.x)
    ;
    a.y = +(
      (+a.y > +b.y)
         ? a.y
         : b.y)
    ;
    a.z = +(
      (+a.z > +b.z)
         ? a.z
         : b.z)
    ;
    return a;
  };

  function double3_ComponentMax$0F (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(
      (+a.get().x > +b.get().x)
         ? a.get().x
         : b.get().x)
    ;
    result.get().y = +(
      (+a.get().y > +b.get().y)
         ? a.get().y
         : b.get().y)
    ;
    result.get().z = +(
      (+a.get().z > +b.get().z)
         ? a.get().z
         : b.get().z)
    ;
  };

  function double3_ComponentMin$10 (a, b) {
    a.x = +(
      (+a.x < +b.x)
         ? a.x
         : b.x)
    ;
    a.y = +(
      (+a.y < +b.y)
         ? a.y
         : b.y)
    ;
    a.z = +(
      (+a.z < +b.z)
         ? a.z
         : b.z)
    ;
    return a;
  };

  function double3_ComponentMin$11 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(
      (+a.get().x < +b.get().x)
         ? a.get().x
         : b.get().x)
    ;
    result.get().y = +(
      (+a.get().y < +b.get().y)
         ? a.get().y
         : b.get().y)
    ;
    result.get().z = +(
      (+a.get().z < +b.get().z)
         ? a.get().z
         : b.get().z)
    ;
  };

  function double3_Cross$12 ($left, $right) {
    var right = new JSIL.BoxedVariable($right.MemberwiseClone());
    var left = new JSIL.BoxedVariable($left.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.Cross(/* ref */ left, /* ref */ right, /* ref */ result);
    return result.get();
  };

  function double3_Cross$13 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S00().Construct(((+left.get().y * +right.get().z) - (+left.get().z * +right.get().y)), ((+left.get().z * +right.get().x) - (+left.get().x * +right.get().z)), ((+left.get().x * +right.get().y) - (+left.get().y * +right.get().x))));
  };

  function double3_Div$14 (f) {
    var num = +((1 / +f));
    this.x *= num;
    this.y *= num;
    this.z *= num;
  };

  function double3_Div$15 (a, f) {
    var num = +((1 / +f));
    a.x *= num;
    a.y *= num;
    a.z *= num;
    return a;
  };

  function double3_Div$16 (/* ref */ a, f, /* ref */ result) {
    var num = +((1 / +f));
    result.get().x = +a.get().x * num;
    result.get().y = +a.get().y * num;
    result.get().z = +a.get().z * num;
  };

  function double3_Divide$17 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S03().CallStatic($thisType, "Divide", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  };

  function double3_Divide$18 (/* ref */ vector, scale, /* ref */ result) {
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vector, +((1 / +scale)), /* ref */ result);
  };

  function double3_Divide$19 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale.MemberwiseClone());
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S04().CallStatic($thisType, "Divide", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  };

  function double3_Divide$1A (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct(+((+vector.get().x / +scale.get().x)), +((+vector.get().y / +scale.get().y)), +((+vector.get().z / +scale.get().z))));
  };

  function double3_Dot$1B (left, right) {
    return (((+left.x * +right.x) + (+left.y * +right.y)) + (+left.z * +right.z));
  };

  function double3_Dot$1C (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set(((+left.get().x * +right.get().x) + (+left.get().y * +right.get().y)) + (+left.get().z * +right.get().z));
  };

  function double3_Object_Equals (obj) {
    return ($thisType.$Is(obj) && this.Equals($thisType.$Cast(obj)));
  };

  function double3_Equals$1D (other) {
    return (!((+this.x !== +other.x) || 
        (+this.y !== +other.y)) && (+this.z === +other.z));
  };

  function double3_get_b () {
    return this.z;
  };

  function double3_get_g () {
    return this.y;
  };

  function double3_get_Length () {
    return Math.sqrt((((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z)));
  };

  function double3_get_LengthFast () {
    return +((1 / +$S05().CallStatic($T05(), "InverseSqrtFast", null, ((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z))));
  };

  function double3_get_LengthSquared () {
    return (((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z));
  };

  function double3_get_Parse () {
    return $thisType.double3$Parse$value;
  };

  function double3_get_r () {
    return this.x;
  };

  function double3_get_xy () {
    return $S06().Construct(this.x, this.y);
  };

  function double3_GetHashCode () {
    return ((((this.x).GetHashCode() | 0) ^ ((this.y).GetHashCode() | 0)) ^ ((this.z).GetHashCode() | 0));
  };

  function double3_Lerp$1E (a, b, blend) {
    a.x = (+blend * (+b.x - +a.x)) + +a.x;
    a.y = (+blend * (+b.y - +a.y)) + +a.y;
    a.z = (+blend * (+b.z - +a.z)) + +a.z;
    return a;
  };

  function double3_Lerp$1F (/* ref */ a, /* ref */ b, blend, /* ref */ result) {
    result.get().x = (+blend * (+b.get().x - +a.get().x)) + +a.get().x;
    result.get().y = (+blend * (+b.get().y - +a.get().y)) + +a.get().y;
    result.get().z = (+blend * (+b.get().z - +a.get().z)) + +a.get().z;
  };

  function double3_Max (left, right) {
    return (
      (+left.get_LengthSquared() >= +right.get_LengthSquared())
         ? left
         : right)
    ;
  };

  function double3_Min (left, right) {
    return (
      (+left.get_LengthSquared() < +right.get_LengthSquared())
         ? left
         : right)
    ;
  };

  function double3_Mult$20 (f) {
    this.x *= +f;
    this.y *= +f;
    this.z *= +f;
  };

  function double3_Mult$21 (a, f) {
    a.x *= +f;
    a.y *= +f;
    a.z *= +f;
    return a;
  };

  function double3_Mult$22 (/* ref */ a, f, /* ref */ result) {
    result.get().x = +a.get().x * +f;
    result.get().y = +a.get().y * +f;
    result.get().z = +a.get().z * +f;
  };

  function double3_Multiply$23 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  };

  function double3_Multiply$24 (/* ref */ vector, scale, /* ref */ result) {
    result.set($S00().Construct((+vector.get().x * +scale), (+vector.get().y * +scale), (+vector.get().z * +scale)));
  };

  function double3_Multiply$25 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale.MemberwiseClone());
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S07().CallStatic($thisType, "Multiply", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  };

  function double3_Multiply$26 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct((+vector.get().x * +scale.get().x), (+vector.get().y * +scale.get().y), (+vector.get().z * +scale.get().z)));
  };

  function double3_Normalize$27 () {
    var num = +((1 / +this.get_Length()));
    this.x *= num;
    this.y *= num;
    this.z *= num;
  };

  function double3_Normalize$28 (vec) {
    var num = +((1 / +vec.get_Length()));
    vec.x *= num;
    vec.y *= num;
    vec.z *= num;
    return vec;
  };

  function double3_Normalize$29 (/* ref */ vec, /* ref */ result) {
    var num = +((1 / +(vec.get()).get_Length()));
    result.get().x = +vec.get().x * num;
    result.get().y = +vec.get().y * num;
    result.get().z = +vec.get().z * num;
  };

  function double3_NormalizeFast$2A () {
    var num = +$S05().CallStatic($T05(), "InverseSqrtFast", null, ((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z));
    this.x *= num;
    this.y *= num;
    this.z *= num;
  };

  function double3_NormalizeFast$2B (vec) {
    var num = +$S05().CallStatic($T05(), "InverseSqrtFast", null, ((+vec.x * +vec.x) + (+vec.y * +vec.y)) + (+vec.z * +vec.z));
    vec.x *= num;
    vec.y *= num;
    vec.z *= num;
    return vec;
  };

  function double3_NormalizeFast$2C (/* ref */ vec, /* ref */ result) {
    var num = +$S05().CallStatic($T05(), "InverseSqrtFast", null, ((+vec.get().x * +vec.get().x) + (+vec.get().y * +vec.get().y)) + (+vec.get().z * +vec.get().z));
    result.get().x = +vec.get().x * num;
    result.get().y = +vec.get().y * num;
    result.get().z = +vec.get().z * num;
  };

  function double3_op_Addition (left, right) {
    left.x += +right.x;
    left.y += +right.y;
    left.z += +right.z;
    return left;
  };

  function double3_op_Division (vec, scale) {
    var num = +((1 / +scale));
    vec.x *= num;
    vec.y *= num;
    vec.z *= num;
    return vec;
  };

  function double3_op_Equality (left, right) {
    return left.Equals(right);
  };

  function double3_op_Inequality (left, right) {
    return !left.Equals(right);
  };

  function double3_op_Multiply$2D (vec, scale) {
    vec.x *= +scale;
    vec.y *= +scale;
    vec.z *= +scale;
    return vec;
  };

  function double3_op_Multiply$2E (scale, vec) {
    vec.x *= +scale;
    vec.y *= +scale;
    vec.z *= +scale;
    return vec;
  };

  function double3_op_Subtraction (left, right) {
    left.x -= +right.x;
    left.y -= +right.y;
    left.z -= +right.z;
    return left;
  };

  function double3_op_UnaryNegation (vec) {
    vec.x = -vec.x;
    vec.y = -vec.y;
    vec.z = -vec.z;
    return vec;
  };

  function double3_Scale$2F (sx, sy, sz) {
    this.x *= +sx;
    this.y *= +sy;
    this.z *= +sz;
  };

  function double3_Scale$30 (scale) {
    this.x *= +scale.x;
    this.y *= +scale.y;
    this.z *= +scale.z;
  };

  function double3_Scale$31 (/* ref */ scale) {
    this.x *= +scale.get().x;
    this.y *= +scale.get().y;
    this.z *= +scale.get().z;
  };

  function double3_set_b (value) {
    this.z = +value;
  };

  function double3_set_g (value) {
    this.y = +value;
  };

  function double3_set_Parse (value) {
    $thisType.double3$Parse$value = value;
  };

  function double3_set_r (value) {
    this.x = +value;
  };

  function double3_set_xy (value) {
    this.x = +value.x;
    this.y = +value.y;
  };

  function double3_Sub$32 (right) {
    this.x -= +right.x;
    this.y -= +right.y;
    this.z -= +right.z;
  };

  function double3_Sub$33 (/* ref */ right) {
    this.x -= +right.get().x;
    this.y -= +right.get().y;
    this.z -= +right.get().z;
  };

  function double3_Sub$34 (a, b) {
    a.x -= +b.x;
    a.y -= +b.y;
    a.z -= +b.z;
    return a;
  };

  function double3_Sub$35 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +a.get().x - +b.get().x;
    result.get().y = +a.get().y - +b.get().y;
    result.get().z = +a.get().z - +b.get().z;
  };

  function double3_Subtract$36 ($a, $b) {
    var b = new JSIL.BoxedVariable($b.MemberwiseClone());
    var a = new JSIL.BoxedVariable($a.MemberwiseClone());
    $thisType.Subtract(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  };

  function double3_Subtract$37 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((+a.get().x - +b.get().x), (+a.get().y - +b.get().y), (+a.get().z - +b.get().z)));
  };

  function double3_ToArray () {
    return JSIL.Array.New($T00(), [this.x, this.y, this.z]);
  };

  function double3_toString () {
    return $T07().Format("({0}, {1}, {2})", this.x, this.y, this.z);
  };

  function double3_Transform$38 ($vec, $mat) {
    var mat = new JSIL.BoxedVariable($mat.MemberwiseClone());
    var vec = new JSIL.BoxedVariable($vec.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $S08().CallStatic($thisType, "Transform", null, /* ref */ vec, /* ref */ mat, /* ref */ result);
    return result.get();
  };

  function double3_Transform$39 (/* ref */ vec, /* ref */ mat, /* ref */ result) {
    var double = new JSIL.BoxedVariable($S09().Construct(vec.get().x, vec.get().y, vec.get().z, 1));
    $S0A().CallStatic($T02(), "Transform", null, /* ref */ double, /* ref */ mat, /* ref */ double);
    result.set((double.get()).get_xyz().MemberwiseClone());
  };

  function double3_Transform$3A ($vec, $quat) {
    var quat = new JSIL.BoxedVariable($quat.MemberwiseClone());
    var vec = new JSIL.BoxedVariable($vec.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $S0B().CallStatic($thisType, "Transform", null, /* ref */ vec, /* ref */ quat, /* ref */ result);
    return result.get();
  };

  function double3_Transform$3B (/* ref */ vec, /* ref */ quat, /* ref */ result) {
    var double = new JSIL.BoxedVariable(new $thisType());
    var double2 = new JSIL.BoxedVariable(new $thisType());
    var xyz = new JSIL.BoxedVariable((quat.get()).get_xyz().MemberwiseClone());
    $thisType.Cross(/* ref */ xyz, /* ref */ vec, /* ref */ double);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vec, (quat.get()).get_w(), /* ref */ double2);
    $thisType.Add(/* ref */ double, /* ref */ double2, /* ref */ double);
    $thisType.Cross(/* ref */ xyz, /* ref */ double, /* ref */ double);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ double, 2, /* ref */ double);
    $thisType.Add(/* ref */ vec, /* ref */ double, /* ref */ result);
  };

  function double3_TransformNormal$3C (norm, mat) {
    mat.Invert();
    return $thisType.TransformNormalInverse(norm.MemberwiseClone(), mat);
  };

  function double3_TransformNormal$3D (/* ref */ norm, /* ref */ mat, /* ref */ result) {
    var double4x = new JSIL.BoxedVariable($T08().Invert(mat.get().MemberwiseClone()).MemberwiseClone());
    $thisType.TransformNormalInverse(/* ref */ norm, /* ref */ double4x, /* ref */ result);
  };

  function double3_TransformNormalInverse$3E (norm, invMat) {
    var result = new $thisType();
    result.x = +$thisType.Dot(norm, $S0C().Construct(invMat.Row0));
    result.y = +$thisType.Dot(norm, $S0C().Construct(invMat.Row1));
    result.z = +$thisType.Dot(norm, $S0C().Construct(invMat.Row2));
    return result;
  };

  function double3_TransformNormalInverse$3F (/* ref */ norm, /* ref */ invMat, /* ref */ result) {
    result.get().x = ((+norm.get().x * +invMat.get().Row0.x) + (+norm.get().y * +invMat.get().Row0.y)) + (+norm.get().z * +invMat.get().Row0.z);
    result.get().y = ((+norm.get().x * +invMat.get().Row1.x) + (+norm.get().y * +invMat.get().Row1.y)) + (+norm.get().z * +invMat.get().Row1.z);
    result.get().z = ((+norm.get().x * +invMat.get().Row2.x) + (+norm.get().y * +invMat.get().Row2.y)) + (+norm.get().z * +invMat.get().Row2.z);
  };

  function double3_TransformPerspective$40 ($vec, $mat) {
    var mat = new JSIL.BoxedVariable($mat.MemberwiseClone());
    var vec = new JSIL.BoxedVariable($vec.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.TransformPerspective(/* ref */ vec, /* ref */ mat, /* ref */ result);
    return result.get();
  };

  function double3_TransformPerspective$41 (/* ref */ vec, /* ref */ mat, /* ref */ result) {
    var double = new JSIL.BoxedVariable($S0D().Construct(vec.get()));
    $S0A().CallStatic($T02(), "Transform", null, /* ref */ double, /* ref */ mat, /* ref */ double);
    result.get().x = +((+double.get().x / +double.get().w));
    result.get().y = +((+double.get().y / +double.get().w));
    result.get().z = +((+double.get().z / +double.get().w));
  };

  function double3_TransformPosition$42 (pos, mat) {
    var result = new $thisType();
    result.x = +$thisType.Dot(pos, $S0C().Construct(mat.get_Column0())) + +mat.Row3.x;
    result.y = +$thisType.Dot(pos, $S0C().Construct(mat.get_Column1())) + +mat.Row3.y;
    result.z = +$thisType.Dot(pos, $S0C().Construct(mat.get_Column2())) + +mat.Row3.z;
    return result;
  };

  function double3_TransformPosition$43 (/* ref */ pos, /* ref */ mat, /* ref */ result) {
    result.get().x = (((+pos.get().x * +mat.get().Row0.x) + (+pos.get().y * +mat.get().Row1.x)) + (+pos.get().z * +mat.get().Row2.x)) + +mat.get().Row3.x;
    result.get().y = (((+pos.get().x * +mat.get().Row0.y) + (+pos.get().y * +mat.get().Row1.y)) + (+pos.get().z * +mat.get().Row2.y)) + +mat.get().Row3.y;
    result.get().z = (((+pos.get().x * +mat.get().Row0.z) + (+pos.get().y * +mat.get().Row1.z)) + (+pos.get().z * +mat.get().Row2.z)) + +mat.get().Row3.z;
  };

  function double3_TransformVector$44 (vec, mat) {
    var result = new $thisType();
    result.x = +$thisType.Dot(vec, $S0C().Construct(mat.get_Column0()));
    result.y = +$thisType.Dot(vec, $S0C().Construct(mat.get_Column1()));
    result.z = +$thisType.Dot(vec, $S0C().Construct(mat.get_Column2()));
    return result;
  };

  function double3_TransformVector$45 (/* ref */ vec, /* ref */ mat, /* ref */ result) {
    result.get().x = ((+vec.get().x * +mat.get().Row0.x) + (+vec.get().y * +mat.get().Row1.x)) + (+vec.get().z * +mat.get().Row2.x);
    result.get().y = ((+vec.get().x * +mat.get().Row0.y) + (+vec.get().y * +mat.get().Row1.y)) + (+vec.get().z * +mat.get().Row2.y);
    result.get().z = ((+vec.get().x * +mat.get().Row0.z) + (+vec.get().y * +mat.get().Row1.z)) + (+vec.get().z * +mat.get().Row2.z);
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.double3", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 3, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double
        ]), 
      double3__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.double2")), 
      double3__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Type), 
      double3__ctor$02
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.double4")), 
      double3__ctor$03
    );

    $.Method({Static:false, Public:true }, "Add", 
      JSIL.MethodSignature.Action($.Type), 
      double3_Add$04
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:false, Public:true }, "Add", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      double3_Add$05
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double3_Add$06
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Add$07
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type, $.Double, 
          $.Double
        ]), 
      double3_BaryCentric$08
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_BaryCentric$09
    );

    $.Method({Static:true , Public:true }, "CalculateAngle", 
      new JSIL.MethodSignature($.Double, [$.Type, $.Type]), 
      double3_CalculateAngle$0A
    );

    $.Method({Static:true , Public:true }, "CalculateAngle", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Double])
        ]), 
      double3_CalculateAngle$0B
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type
        ]), 
      double3_Clamp$0C
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Clamp$0D
    );

    $.Method({Static:true , Public:true }, "ComponentMax", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double3_ComponentMax$0E
    );

    $.Method({Static:true , Public:true }, "ComponentMax", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_ComponentMax$0F
    );

    $.Method({Static:true , Public:true }, "ComponentMin", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double3_ComponentMin$10
    );

    $.Method({Static:true , Public:true }, "ComponentMin", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_ComponentMin$11
    );

    $.Method({Static:true , Public:true }, "Cross", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double3_Cross$12
    );

    $.Method({Static:true , Public:true }, "Cross", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Cross$13
    );

    $.Method({Static:false, Public:true }, "Div", 
      JSIL.MethodSignature.Action($.Double), 
      double3_Div$14
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double3_Div$15
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Div$16
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double3_Divide$17
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Divide$18
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double3_Divide$19
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Divide$1A
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature($.Double, [$.Type, $.Type]), 
      double3_Dot$1B
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Double])
        ]), 
      double3_Dot$1C
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      double3_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type]), 
      double3_Equals$1D
    );

    $.Method({Static:false, Public:true }, "get_b", 
      JSIL.MethodSignature.Return($.Double), 
      double3_get_b
    );

    $.Method({Static:false, Public:true }, "get_g", 
      JSIL.MethodSignature.Return($.Double), 
      double3_get_g
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      JSIL.MethodSignature.Return($.Double), 
      double3_get_Length
    );

    $.Method({Static:false, Public:true }, "get_LengthFast", 
      JSIL.MethodSignature.Return($.Double), 
      double3_get_LengthFast
    );

    $.Method({Static:false, Public:true }, "get_LengthSquared", 
      JSIL.MethodSignature.Return($.Double), 
      double3_get_LengthSquared
    );

    $.Method({Static:true , Public:true }, "get_Parse", 
      JSIL.MethodSignature.Return($asm07.TypeRef("System.Converter`2", [$.String, $.Type])), 
      double3_get_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_r", 
      JSIL.MethodSignature.Return($.Double), 
      double3_get_r
    );

    $.Method({Static:false, Public:true }, "get_xy", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.double2")), 
      double3_get_xy
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32), 
      double3_GetHashCode
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Double
        ]), 
      double3_Lerp$1E
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Lerp$1F
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double3_Max
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double3_Min
    );

    $.Method({Static:false, Public:true }, "Mult", 
      JSIL.MethodSignature.Action($.Double), 
      double3_Mult$20
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double3_Mult$21
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Mult$22
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double3_Multiply$23
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Multiply$24
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double3_Multiply$25
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Multiply$26
    );

    $.Method({Static:false, Public:true }, "Normalize", 
      JSIL.MethodSignature.Void, 
      double3_Normalize$27
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      double3_Normalize$28
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double3_Normalize$29
    );

    $.Method({Static:false, Public:true }, "NormalizeFast", 
      JSIL.MethodSignature.Void, 
      double3_NormalizeFast$2A
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      double3_NormalizeFast$2B
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double3_NormalizeFast$2C
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double3_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Division", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double3_op_Division
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      double3_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      double3_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double3_op_Multiply$2D
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Double, $.Type]), 
      double3_op_Multiply$2E
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double3_op_Subtraction
    );

    $.Method({Static:true , Public:true }, "op_UnaryNegation", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      double3_op_UnaryNegation
    );

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double
        ]), 
      double3_Scale$2F
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      JSIL.MethodSignature.Action($.Type), 
      double3_Scale$30
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      double3_Scale$31
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "set_b", 
      JSIL.MethodSignature.Action($.Double), 
      double3_set_b
    );

    $.Method({Static:false, Public:true }, "set_g", 
      JSIL.MethodSignature.Action($.Double), 
      double3_set_g
    );

    $.Method({Static:true , Public:true }, "set_Parse", 
      JSIL.MethodSignature.Action($asm07.TypeRef("System.Converter`2", [$.String, $.Type])), 
      double3_set_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "set_r", 
      JSIL.MethodSignature.Action($.Double), 
      double3_set_r
    );

    $.Method({Static:false, Public:true }, "set_xy", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.double2")), 
      double3_set_xy
    );

    $.Method({Static:false, Public:true }, "Sub", 
      JSIL.MethodSignature.Action($.Type), 
      double3_Sub$32
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:false, Public:true }, "Sub", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      double3_Sub$33
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double3_Sub$34
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Sub$35
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double3_Subtract$36
    );

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Subtract$37
    );

    $.Method({Static:false, Public:true }, "ToArray", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Double])), 
      double3_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      double3_toString
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.double4x4")]), 
      double3_Transform$38
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Transform$39
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.QuaternionD")]), 
      double3_Transform$3A
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_Transform$3B
    );

    $.Method({Static:true , Public:true }, "TransformNormal", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.double4x4")]), 
      double3_TransformNormal$3C
    );

    $.Method({Static:true , Public:true }, "TransformNormal", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_TransformNormal$3D
    );

    $.Method({Static:true , Public:true }, "TransformNormalInverse", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.double4x4")]), 
      double3_TransformNormalInverse$3E
    );

    $.Method({Static:true , Public:true }, "TransformNormalInverse", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_TransformNormalInverse$3F
    );

    $.Method({Static:true , Public:true }, "TransformPerspective", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.double4x4")]), 
      double3_TransformPerspective$40
    );

    $.Method({Static:true , Public:true }, "TransformPerspective", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_TransformPerspective$41
    );

    $.Method({Static:true , Public:true }, "TransformPosition", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.double4x4")]), 
      double3_TransformPosition$42
    );

    $.Method({Static:true , Public:true }, "TransformPosition", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_TransformPosition$43
    );

    $.Method({Static:true , Public:true }, "TransformVector", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.double4x4")]), 
      double3_TransformVector$44
    );

    $.Method({Static:true , Public:true }, "TransformVector", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double3_TransformVector$45
    );

    $.Field({Static:false, Public:true }, "x", $.Double); 
    $.Field({Static:false, Public:true }, "y", $.Double); 
    $.Field({Static:false, Public:true }, "z", $.Double); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitX", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitY", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitZ", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "Zero", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "One", $.Type); 
    $.Field({Static:true , Public:false}, "double3$Parse$value", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]))
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    function double3__cctor () {
      $thisType.UnitX = new $thisType();
      $thisType.UnitY = new $thisType();
      $thisType.UnitZ = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.One = new $thisType();
      $thisType.UnitX = $S00().Construct(1, 0, 0);
      $thisType.UnitY = $S00().Construct(0, 1, 0);
      $thisType.UnitZ = $S00().Construct(0, 0, 1);
      $thisType.Zero = $S00().Construct(0, 0, 0);
      $thisType.One = $S00().Construct(1, 1, 1);
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      double3__cctor
    );

    $.Property({Static:false, Public:true }, "Length", $.Double);

    $.Property({Static:false, Public:true }, "LengthFast", $.Double);

    $.Property({Static:false, Public:true }, "LengthSquared", $.Double);

    $.Property({Static:false, Public:true }, "xy", $asm04.TypeRef("Fusee.Math.double2"));

    $.Property({Static:false, Public:true }, "r", $.Double);

    $.Property({Static:false, Public:true }, "g", $.Double);

    $.Property({Static:false, Public:true }, "b", $.Double);

    $.Property({Static:true , Public:true }, "Parse", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]));

    $.ImplementInterfaces(
      /* 0 */ $asm07.TypeRef("System.IEquatable`1", [$.Type])
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Math.double4 */ 

(function double4$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm07.System.Double)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Math.double2)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Math.double3)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.System.Math)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm04.Fusee.Math.MathHelper)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm07.System.Converter$b2.Of($asm07.System.String, $asm04.Fusee.Math.double4))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm07.System.String)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm04.Fusee.Math.double4x4)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm04.Fusee.Math.QuaternionD)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double4"), [
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double4"), [$asm07.TypeRef("System.Double"), $asm04.TypeRef("Fusee.Math.double4")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")]), $asm07.TypeRef("System.Double"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")])
      ]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")]), $asm07.TypeRef("System.Double"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")])
      ]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")])
      ]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("System.Double"), [$asm07.TypeRef("System.Double")]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double2"), [$asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double")]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double3"), [
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double")
      ]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")])
      ]))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4x4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")])
      ]))) ();
  };
  var $S0A = function () {
    return ($S0A = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")])
      ]))) ();
  };
  var $S0B = function () {
    return ($S0B = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.QuaternionD"), [
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double")
      ]))) ();
  };
  var $S0C = function () {
    return ($S0C = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")])
      ]))) ();
  };

  function double4__ctor$00 (x, y, z, w) {
    this.x = +x;
    this.y = +y;
    this.z = +z;
    this.w = +w;
  };

  function double4__ctor$01 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = 0;
    this.w = 0;
  };

  function double4__ctor$02 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
    this.w = 0;
  };

  function double4__ctor$03 (v, ww) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
    this.w = +ww;
  };

  function double4__ctor$04 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
    this.w = +v.w;
  };

  function double4_Add$05 (right) {
    this.x += +right.x;
    this.y += +right.y;
    this.z += +right.z;
    this.w += +right.w;
  };

  function double4_Add$06 (/* ref */ right) {
    this.x += +right.get().x;
    this.y += +right.get().y;
    this.z += +right.get().z;
    this.w += +right.get().w;
  };

  function double4_Add$07 ($a, $b) {
    var b = new JSIL.BoxedVariable($b.MemberwiseClone());
    var a = new JSIL.BoxedVariable($a.MemberwiseClone());
    $thisType.Add(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  };

  function double4_Add$08 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((+a.get().x + +b.get().x), (+a.get().y + +b.get().y), (+a.get().z + +b.get().z), (+a.get().w + +b.get().w)));
  };

  function double4_BaryCentric$09 (a, b, c, u, v) {
    return $thisType.op_Addition(
      $thisType.op_Addition(a.MemberwiseClone(), $S01().CallStatic($thisType, "op_Multiply", null, u, $thisType.op_Subtraction(b.MemberwiseClone(), a).MemberwiseClone())).MemberwiseClone(), 
      $S01().CallStatic($thisType, "op_Multiply", null, v, $thisType.op_Subtraction(c.MemberwiseClone(), a).MemberwiseClone())
    );
  };

  function double4_BaryCentric$0A (/* ref */ a, /* ref */ b, /* ref */ c, u, v, /* ref */ result) {
    result.set(a.get().MemberwiseClone());
    var double = new JSIL.BoxedVariable(b.get().MemberwiseClone());
    $thisType.Subtract(/* ref */ double, /* ref */ a, /* ref */ double);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ double, u, /* ref */ double);
    $thisType.Add(/* ref */ result, /* ref */ double, /* ref */ result);
    double.set(c.get().MemberwiseClone());
    $thisType.Subtract(/* ref */ double, /* ref */ a, /* ref */ double);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ double, v, /* ref */ double);
    $thisType.Add(/* ref */ result, /* ref */ double, /* ref */ result);
  };

  function double4_Clamp$0B (vec, min, max) {
    vec.x = +(
      (+vec.x < +min.x)
         ? min.x
         : (
          (+vec.x > +max.x)
             ? max.x
             : vec.x)
    )
    ;
    vec.y = +(
      (+vec.y < +min.y)
         ? min.y
         : (
          (+vec.y > +max.y)
             ? max.y
             : vec.y)
    )
    ;
    vec.z = +(
      (+vec.x < +min.z)
         ? min.z
         : (
          (+vec.z > +max.z)
             ? max.z
             : vec.z)
    )
    ;
    vec.w = +(
      (+vec.y < +min.w)
         ? min.w
         : (
          (+vec.w > +max.w)
             ? max.w
             : vec.w)
    )
    ;
    return vec;
  };

  function double4_Clamp$0C (/* ref */ vec, /* ref */ min, /* ref */ max, /* ref */ result) {
    result.get().x = +(
      (+vec.get().x < +min.get().x)
         ? min.get().x
         : (
          (+vec.get().x > +max.get().x)
             ? max.get().x
             : vec.get().x)
    )
    ;
    result.get().y = +(
      (+vec.get().y < +min.get().y)
         ? min.get().y
         : (
          (+vec.get().y > +max.get().y)
             ? max.get().y
             : vec.get().y)
    )
    ;
    result.get().z = +(
      (+vec.get().x < +min.get().z)
         ? min.get().z
         : (
          (+vec.get().z > +max.get().z)
             ? max.get().z
             : vec.get().z)
    )
    ;
    result.get().w = +(
      (+vec.get().y < +min.get().w)
         ? min.get().w
         : (
          (+vec.get().w > +max.get().w)
             ? max.get().w
             : vec.get().w)
    )
    ;
  };

  function double4_Div$0D (f) {
    var num = +((1 / +f));
    this.x *= num;
    this.y *= num;
    this.z *= num;
    this.w *= num;
  };

  function double4_Div$0E (a, f) {
    var num = +((1 / +f));
    a.x *= num;
    a.y *= num;
    a.z *= num;
    a.w *= num;
    return a;
  };

  function double4_Div$0F (/* ref */ a, f, /* ref */ result) {
    var num = +((1 / +f));
    result.get().x = +a.get().x * num;
    result.get().y = +a.get().y * num;
    result.get().z = +a.get().z * num;
    result.get().w = +a.get().w * num;
  };

  function double4_Divide$10 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S03().CallStatic($thisType, "Divide", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  };

  function double4_Divide$11 (/* ref */ vector, scale, /* ref */ result) {
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vector, +((1 / +scale)), /* ref */ result);
  };

  function double4_Divide$12 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale.MemberwiseClone());
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S04().CallStatic($thisType, "Divide", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  };

  function double4_Divide$13 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct(+((+vector.get().x / +scale.get().x)), +((+vector.get().y / +scale.get().y)), +((+vector.get().z / +scale.get().z)), +((+vector.get().w / +scale.get().w))));
  };

  function double4_Dot$14 (left, right) {
    return ((((+left.x * +right.x) + (+left.y * +right.y)) + (+left.z * +right.z)) + (+left.w * +right.w));
  };

  function double4_Dot$15 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set((((+left.get().x * +right.get().x) + (+left.get().y * +right.get().y)) + (+left.get().z * +right.get().z)) + (+left.get().w * +right.get().w));
  };

  function double4_Object_Equals (obj) {
    return ($thisType.$Is(obj) && this.Equals($thisType.$Cast(obj)));
  };

  function double4_Equals$16 (other) {
    return (!((+this.x !== +other.x) || 
        (+this.y !== +other.y) || 
        (+this.z !== +other.z)) && (+this.w === +other.w));
  };

  function double4_get_a () {
    return this.w;
  };

  function double4_get_b () {
    return this.z;
  };

  function double4_get_g () {
    return this.y;
  };

  function double4_get_Length () {
    return Math.sqrt(((((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z)) + (+this.w * +this.w)));
  };

  function double4_get_LengthFast () {
    return +((1 / +$S05().CallStatic($T05(), "InverseSqrtFast", null, (((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z)) + (+this.w * +this.w))));
  };

  function double4_get_LengthSquared () {
    return ((((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z)) + (+this.w * +this.w));
  };

  function double4_get_Parse () {
    return $thisType.double4$Parse$value;
  };

  function double4_get_r () {
    return this.x;
  };

  function double4_get_rgb () {
    return this.get_xyz();
  };

  function double4_get_xy () {
    return $S06().Construct(this.x, this.y);
  };

  function double4_get_xyz () {
    return $S07().Construct(this.x, this.y, this.z);
  };

  function double4_GetHashCode () {
    return (((((this.x).GetHashCode() | 0) ^ ((this.y).GetHashCode() | 0)) ^ ((this.z).GetHashCode() | 0)) ^ ((this.w).GetHashCode() | 0));
  };

  function double4_Lerp$17 (a, b, blend) {
    a.x = (+blend * (+b.x - +a.x)) + +a.x;
    a.y = (+blend * (+b.y - +a.y)) + +a.y;
    a.z = (+blend * (+b.z - +a.z)) + +a.z;
    a.w = (+blend * (+b.w - +a.w)) + +a.w;
    return a;
  };

  function double4_Lerp$18 (/* ref */ a, /* ref */ b, blend, /* ref */ result) {
    result.get().x = (+blend * (+b.get().x - +a.get().x)) + +a.get().x;
    result.get().y = (+blend * (+b.get().y - +a.get().y)) + +a.get().y;
    result.get().z = (+blend * (+b.get().z - +a.get().z)) + +a.get().z;
    result.get().w = (+blend * (+b.get().w - +a.get().w)) + +a.get().w;
  };

  function double4_Max$19 (a, b) {
    a.x = +(
      (+a.x > +b.x)
         ? a.x
         : b.x)
    ;
    a.y = +(
      (+a.y > +b.y)
         ? a.y
         : b.y)
    ;
    a.z = +(
      (+a.z > +b.z)
         ? a.z
         : b.z)
    ;
    a.w = +(
      (+a.w > +b.w)
         ? a.w
         : b.w)
    ;
    return a;
  };

  function double4_Max$1A (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(
      (+a.get().x > +b.get().x)
         ? a.get().x
         : b.get().x)
    ;
    result.get().y = +(
      (+a.get().y > +b.get().y)
         ? a.get().y
         : b.get().y)
    ;
    result.get().z = +(
      (+a.get().z > +b.get().z)
         ? a.get().z
         : b.get().z)
    ;
    result.get().w = +(
      (+a.get().w > +b.get().w)
         ? a.get().w
         : b.get().w)
    ;
  };

  function double4_Min$1B (a, b) {
    a.x = +(
      (+a.x < +b.x)
         ? a.x
         : b.x)
    ;
    a.y = +(
      (+a.y < +b.y)
         ? a.y
         : b.y)
    ;
    a.z = +(
      (+a.z < +b.z)
         ? a.z
         : b.z)
    ;
    a.w = +(
      (+a.w < +b.w)
         ? a.w
         : b.w)
    ;
    return a;
  };

  function double4_Min$1C (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(
      (+a.get().x < +b.get().x)
         ? a.get().x
         : b.get().x)
    ;
    result.get().y = +(
      (+a.get().y < +b.get().y)
         ? a.get().y
         : b.get().y)
    ;
    result.get().z = +(
      (+a.get().z < +b.get().z)
         ? a.get().z
         : b.get().z)
    ;
    result.get().w = +(
      (+a.get().w < +b.get().w)
         ? a.get().w
         : b.get().w)
    ;
  };

  function double4_Mult$1D (f) {
    this.x *= +f;
    this.y *= +f;
    this.z *= +f;
    this.w *= +f;
  };

  function double4_Mult$1E (a, f) {
    a.x *= +f;
    a.y *= +f;
    a.z *= +f;
    a.w *= +f;
    return a;
  };

  function double4_Mult$1F (/* ref */ a, f, /* ref */ result) {
    result.get().x = +a.get().x * +f;
    result.get().y = +a.get().y * +f;
    result.get().z = +a.get().z * +f;
    result.get().w = +a.get().w * +f;
  };

  function double4_Multiply$20 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  };

  function double4_Multiply$21 (/* ref */ vector, scale, /* ref */ result) {
    result.set($S00().Construct((+vector.get().x * +scale), (+vector.get().y * +scale), (+vector.get().z * +scale), (+vector.get().w * +scale)));
  };

  function double4_Multiply$22 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale.MemberwiseClone());
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S08().CallStatic($thisType, "Multiply", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  };

  function double4_Multiply$23 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct((+vector.get().x * +scale.get().x), (+vector.get().y * +scale.get().y), (+vector.get().z * +scale.get().z), (+vector.get().w * +scale.get().w)));
  };

  function double4_Normalize$24 () {
    var num = +((1 / +this.get_Length()));
    this.x *= num;
    this.y *= num;
    this.z *= num;
    this.w *= num;
  };

  function double4_Normalize$25 (vec) {
    var num = +((1 / +vec.get_Length()));
    vec.x *= num;
    vec.y *= num;
    vec.z *= num;
    vec.w *= num;
    return vec;
  };

  function double4_Normalize$26 (/* ref */ vec, /* ref */ result) {
    var num = +((1 / +(vec.get()).get_Length()));
    result.get().x = +vec.get().x * num;
    result.get().y = +vec.get().y * num;
    result.get().z = +vec.get().z * num;
    result.get().w = +vec.get().w * num;
  };

  function double4_NormalizeFast$27 () {
    var num = +$S05().CallStatic($T05(), "InverseSqrtFast", null, (((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z)) + (+this.w * +this.w));
    this.x *= num;
    this.y *= num;
    this.z *= num;
    this.w *= num;
  };

  function double4_NormalizeFast$28 (vec) {
    var num = +$S05().CallStatic($T05(), "InverseSqrtFast", null, (((+vec.x * +vec.x) + (+vec.y * +vec.y)) + (+vec.z * +vec.z)) + (+vec.w * +vec.w));
    vec.x *= num;
    vec.y *= num;
    vec.z *= num;
    vec.w *= num;
    return vec;
  };

  function double4_NormalizeFast$29 (/* ref */ vec, /* ref */ result) {
    var num = +$S05().CallStatic($T05(), "InverseSqrtFast", null, (((+vec.get().x * +vec.get().x) + (+vec.get().y * +vec.get().y)) + (+vec.get().z * +vec.get().z)) + (+vec.get().w * +vec.get().w));
    result.get().x = +vec.get().x * num;
    result.get().y = +vec.get().y * num;
    result.get().z = +vec.get().z * num;
    result.get().w = +vec.get().w * num;
  };

  function double4_op_Addition (left, right) {
    left.x += +right.x;
    left.y += +right.y;
    left.z += +right.z;
    left.w += +right.w;
    return left;
  };

  function double4_op_Division (vec, scale) {
    var num = +((1 / +scale));
    vec.x *= num;
    vec.y *= num;
    vec.z *= num;
    vec.w *= num;
    return vec;
  };

  function double4_op_Equality (left, right) {
    return left.Equals(right);
  };

  function double4_op_Inequality (left, right) {
    return !left.Equals(right);
  };

  function double4_op_Multiply$2A (vec, scale) {
    vec.x *= +scale;
    vec.y *= +scale;
    vec.z *= +scale;
    vec.w *= +scale;
    return vec;
  };

  function double4_op_Multiply$2B (scale, vec) {
    vec.x *= +scale;
    vec.y *= +scale;
    vec.z *= +scale;
    vec.w *= +scale;
    return vec;
  };

  function double4_op_Subtraction (left, right) {
    left.x -= +right.x;
    left.y -= +right.y;
    left.z -= +right.z;
    left.w -= +right.w;
    return left;
  };

  function double4_op_UnaryNegation (vec) {
    vec.x = -vec.x;
    vec.y = -vec.y;
    vec.z = -vec.z;
    vec.w = -vec.w;
    return vec;
  };

  function double4_Scale$2C (sx, sy, sz, sw) {
    this.x *= +sx;
    this.y *= +sy;
    this.z *= +sz;
    this.w *= +sw;
  };

  function double4_Scale$2D (scale) {
    this.x *= +scale.x;
    this.y *= +scale.y;
    this.z *= +scale.z;
    this.w *= +scale.w;
  };

  function double4_Scale$2E (/* ref */ scale) {
    this.x *= +scale.get().x;
    this.y *= +scale.get().y;
    this.z *= +scale.get().z;
    this.w *= +scale.get().w;
  };

  function double4_set_a (value) {
    this.w = +value;
  };

  function double4_set_b (value) {
    this.z = +value;
  };

  function double4_set_g (value) {
    this.y = +value;
  };

  function double4_set_Parse (value) {
    $thisType.double4$Parse$value = value;
  };

  function double4_set_r (value) {
    this.x = +value;
  };

  function double4_set_rgb (value) {
    (this.xyz = value.MemberwiseClone());
  };

  function double4_set_xy (value) {
    this.x = +value.x;
    this.y = +value.y;
  };

  function double4_set_xyz (value) {
    this.x = +value.x;
    this.y = +value.y;
    this.z = +value.z;
  };

  function double4_Sub$2F (right) {
    this.x -= +right.x;
    this.y -= +right.y;
    this.z -= +right.z;
    this.w -= +right.w;
  };

  function double4_Sub$30 (/* ref */ right) {
    this.x -= +right.get().x;
    this.y -= +right.get().y;
    this.z -= +right.get().z;
    this.w -= +right.get().w;
  };

  function double4_Sub$31 (a, b) {
    a.x -= +b.x;
    a.y -= +b.y;
    a.z -= +b.z;
    a.w -= +b.w;
    return a;
  };

  function double4_Sub$32 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +a.get().x - +b.get().x;
    result.get().y = +a.get().y - +b.get().y;
    result.get().z = +a.get().z - +b.get().z;
    result.get().w = +a.get().w - +b.get().w;
  };

  function double4_Subtract$33 ($a, $b) {
    var b = new JSIL.BoxedVariable($b.MemberwiseClone());
    var a = new JSIL.BoxedVariable($a.MemberwiseClone());
    $thisType.Subtract(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  };

  function double4_Subtract$34 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((+a.get().x - +b.get().x), (+a.get().y - +b.get().y), (+a.get().z - +b.get().z), (+a.get().w - +b.get().w)));
  };

  function double4_ToArray () {
    return JSIL.Array.New($T00(), [this.x, this.y, this.z, this.w]);
  };

  function double4_toString () {
    return $T07().Format("({0}, {1}, {2}, {3})", JSIL.Array.New($T03(), [this.x, this.y, this.z, this.w]));
  };

  function double4_Transform$35 ($vec, $mat) {
    var mat = new JSIL.BoxedVariable($mat.MemberwiseClone());
    var vec = new JSIL.BoxedVariable($vec.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $S09().CallStatic($thisType, "Transform", null, /* ref */ vec, /* ref */ mat, /* ref */ result);
    return result.get();
  };

  function double4_Transform$36 (/* ref */ vec, /* ref */ mat, /* ref */ result) {
    result.set($S00().Construct(((((+vec.get().x * +mat.get().Row0.x) + (+vec.get().y * +mat.get().Row1.x)) + (+vec.get().z * +mat.get().Row2.x)) + (+vec.get().w * +mat.get().Row3.x)), ((((+vec.get().x * +mat.get().Row0.y) + (+vec.get().y * +mat.get().Row1.y)) + (+vec.get().z * +mat.get().Row2.y)) + (+vec.get().w * +mat.get().Row3.y)), ((((+vec.get().x * +mat.get().Row0.z) + (+vec.get().y * +mat.get().Row1.z)) + (+vec.get().z * +mat.get().Row2.z)) + (+vec.get().w * +mat.get().Row3.z)), ((((+vec.get().x * +mat.get().Row0.w) + (+vec.get().y * +mat.get().Row1.w)) + (+vec.get().z * +mat.get().Row2.w)) + (+vec.get().w * +mat.get().Row3.w))));
  };

  function double4_Transform$37 ($vec, $quat) {
    var quat = new JSIL.BoxedVariable($quat.MemberwiseClone());
    var vec = new JSIL.BoxedVariable($vec.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $S0A().CallStatic($thisType, "Transform", null, /* ref */ vec, /* ref */ quat, /* ref */ result);
    return result.get();
  };

  function double4_Transform$38 (/* ref */ vec, /* ref */ quat, /* ref */ result) {
    var quaternionD2 = new JSIL.BoxedVariable(new ($T09())());
    var quaternionD3 = new JSIL.BoxedVariable(new ($T09())());
    var quaternionD = new JSIL.BoxedVariable($S0B().Construct(vec.get().x, vec.get().y, vec.get().z, vec.get().w));
    $T09().Invert(/* ref */ quat, /* ref */ quaternionD2);
    $S0C().CallStatic($T09(), "Multiply", null, /* ref */ quat, /* ref */ quaternionD, /* ref */ quaternionD3);
    $S0C().CallStatic($T09(), "Multiply", null, /* ref */ quaternionD3, /* ref */ quaternionD2, /* ref */ quaternionD);
    result.set($S00().Construct((quaternionD.get()).get_x(), (quaternionD.get()).get_y(), (quaternionD.get()).get_z(), (quaternionD.get()).get_w()));
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.double4", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 4, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double
        ]), 
      double4__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.double2")), 
      double4__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.double3")), 
      double4__ctor$02
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.double3"), $.Double]), 
      double4__ctor$03
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Type), 
      double4__ctor$04
    );

    $.Method({Static:false, Public:true }, "Add", 
      JSIL.MethodSignature.Action($.Type), 
      double4_Add$05
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:false, Public:true }, "Add", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      double4_Add$06
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4_Add$07
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Add$08
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type, $.Double, 
          $.Double
        ]), 
      double4_BaryCentric$09
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_BaryCentric$0A
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type
        ]), 
      double4_Clamp$0B
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Clamp$0C
    );

    $.Method({Static:false, Public:true }, "Div", 
      JSIL.MethodSignature.Action($.Double), 
      double4_Div$0D
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double4_Div$0E
    );

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Div$0F
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double4_Divide$10
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Divide$11
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4_Divide$12
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Divide$13
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature($.Double, [$.Type, $.Type]), 
      double4_Dot$14
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Double])
        ]), 
      double4_Dot$15
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      double4_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type]), 
      double4_Equals$16
    );

    $.Method({Static:false, Public:true }, "get_a", 
      JSIL.MethodSignature.Return($.Double), 
      double4_get_a
    );

    $.Method({Static:false, Public:true }, "get_b", 
      JSIL.MethodSignature.Return($.Double), 
      double4_get_b
    );

    $.Method({Static:false, Public:true }, "get_g", 
      JSIL.MethodSignature.Return($.Double), 
      double4_get_g
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      JSIL.MethodSignature.Return($.Double), 
      double4_get_Length
    );

    $.Method({Static:false, Public:true }, "get_LengthFast", 
      JSIL.MethodSignature.Return($.Double), 
      double4_get_LengthFast
    );

    $.Method({Static:false, Public:true }, "get_LengthSquared", 
      JSIL.MethodSignature.Return($.Double), 
      double4_get_LengthSquared
    );

    $.Method({Static:true , Public:true }, "get_Parse", 
      JSIL.MethodSignature.Return($asm07.TypeRef("System.Converter`2", [$.String, $.Type])), 
      double4_get_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_r", 
      JSIL.MethodSignature.Return($.Double), 
      double4_get_r
    );

    $.Method({Static:false, Public:true }, "get_rgb", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.double3")), 
      double4_get_rgb
    );

    $.Method({Static:false, Public:true }, "get_xy", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.double2")), 
      double4_get_xy
    );

    $.Method({Static:false, Public:true }, "get_xyz", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.double3")), 
      double4_get_xyz
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32), 
      double4_GetHashCode
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Double
        ]), 
      double4_Lerp$17
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Lerp$18
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4_Max$19
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Max$1A
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4_Min$1B
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Min$1C
    );

    $.Method({Static:false, Public:true }, "Mult", 
      JSIL.MethodSignature.Action($.Double), 
      double4_Mult$1D
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double4_Mult$1E
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Mult$1F
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double4_Multiply$20
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Multiply$21
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4_Multiply$22
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Multiply$23
    );

    $.Method({Static:false, Public:true }, "Normalize", 
      JSIL.MethodSignature.Void, 
      double4_Normalize$24
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      double4_Normalize$25
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double4_Normalize$26
    );

    $.Method({Static:false, Public:true }, "NormalizeFast", 
      JSIL.MethodSignature.Void, 
      double4_NormalizeFast$27
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      double4_NormalizeFast$28
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double4_NormalizeFast$29
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Division", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double4_op_Division
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      double4_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      double4_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      double4_op_Multiply$2A
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Double, $.Type]), 
      double4_op_Multiply$2B
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4_op_Subtraction
    );

    $.Method({Static:true , Public:true }, "op_UnaryNegation", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      double4_op_UnaryNegation
    );

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double
        ]), 
      double4_Scale$2C
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      JSIL.MethodSignature.Action($.Type), 
      double4_Scale$2D
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      double4_Scale$2E
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "set_a", 
      JSIL.MethodSignature.Action($.Double), 
      double4_set_a
    );

    $.Method({Static:false, Public:true }, "set_b", 
      JSIL.MethodSignature.Action($.Double), 
      double4_set_b
    );

    $.Method({Static:false, Public:true }, "set_g", 
      JSIL.MethodSignature.Action($.Double), 
      double4_set_g
    );

    $.Method({Static:true , Public:true }, "set_Parse", 
      JSIL.MethodSignature.Action($asm07.TypeRef("System.Converter`2", [$.String, $.Type])), 
      double4_set_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "set_r", 
      JSIL.MethodSignature.Action($.Double), 
      double4_set_r
    );

    $.Method({Static:false, Public:true }, "set_rgb", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.double3")), 
      double4_set_rgb
    );

    $.Method({Static:false, Public:true }, "set_xy", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.double2")), 
      double4_set_xy
    );

    $.Method({Static:false, Public:true }, "set_xyz", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.double3")), 
      double4_set_xyz
    );

    $.Method({Static:false, Public:true }, "Sub", 
      JSIL.MethodSignature.Action($.Type), 
      double4_Sub$2F
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:false, Public:true }, "Sub", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      double4_Sub$30
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4_Sub$31
    );

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Sub$32
    );

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4_Subtract$33
    );

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Subtract$34
    );

    $.Method({Static:false, Public:true }, "ToArray", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Double])), 
      double4_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      double4_toString
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.double4x4")]), 
      double4_Transform$35
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Transform$36
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.QuaternionD")]), 
      double4_Transform$37
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4_Transform$38
    );

    $.Field({Static:false, Public:true }, "x", $.Double); 
    $.Field({Static:false, Public:true }, "y", $.Double); 
    $.Field({Static:false, Public:true }, "z", $.Double); 
    $.Field({Static:false, Public:true }, "w", $.Double); 
    $.Field({Static:true , Public:true }, "UnitX", $.Type); 
    $.Field({Static:true , Public:true }, "UnitY", $.Type); 
    $.Field({Static:true , Public:true }, "UnitZ", $.Type); 
    $.Field({Static:true , Public:true }, "UnitW", $.Type); 
    $.Field({Static:true , Public:true }, "Zero", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "One", $.Type); 
    $.Field({Static:true , Public:false}, "double4$Parse$value", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]))
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    function double4__cctor () {
      $thisType.UnitX = new $thisType();
      $thisType.UnitY = new $thisType();
      $thisType.UnitZ = new $thisType();
      $thisType.UnitW = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.One = new $thisType();
      $thisType.UnitX = $S00().Construct(1, 0, 0, 0);
      $thisType.UnitY = $S00().Construct(0, 1, 0, 0);
      $thisType.UnitZ = $S00().Construct(0, 0, 1, 0);
      $thisType.UnitW = $S00().Construct(0, 0, 0, 1);
      $thisType.Zero = $S00().Construct(0, 0, 0, 0);
      $thisType.One = $S00().Construct(1, 1, 1, 1);
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      double4__cctor
    );

    $.Property({Static:false, Public:true }, "Length", $.Double);

    $.Property({Static:false, Public:true }, "LengthFast", $.Double);

    $.Property({Static:false, Public:true }, "LengthSquared", $.Double);

    $.Property({Static:false, Public:true }, "xy", $asm04.TypeRef("Fusee.Math.double2"));

    $.Property({Static:false, Public:true }, "xyz", $asm04.TypeRef("Fusee.Math.double3"));

    $.Property({Static:false, Public:true }, "r", $.Double);

    $.Property({Static:false, Public:true }, "g", $.Double);

    $.Property({Static:false, Public:true }, "b", $.Double);

    $.Property({Static:false, Public:true }, "rgb", $asm04.TypeRef("Fusee.Math.double3"));

    $.Property({Static:false, Public:true }, "a", $.Double);

    $.Property({Static:true , Public:true }, "Parse", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]));

    $.ImplementInterfaces(
      /* 0 */ $asm07.TypeRef("System.IEquatable`1", [$.Type])
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Math.double4x4 */ 

(function double4x4$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Math.double4)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm07.System.Double)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Math.double3)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.System.Math)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.System.ArgumentOutOfRangeException)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm07.System.Object)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm07.System.Converter$b2.Of($asm07.System.String, $asm04.Fusee.Math.double4x4))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm07.System.String)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double4x4"), [
        $asm04.TypeRef("Fusee.Math.double4"), $asm04.TypeRef("Fusee.Math.double4"), 
        $asm04.TypeRef("Fusee.Math.double4"), $asm04.TypeRef("Fusee.Math.double4")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double4"), [
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double")
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double4x4"), [
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double")
      ]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("System.ArgumentOutOfRangeException"), [$asm07.TypeRef("System.String")]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double3"), [
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double")
      ]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double4"), [$asm04.TypeRef("Fusee.Math.double4"), $asm07.TypeRef("System.Double")]))) ();
  };

  function double4x4__ctor$00 (row0, row1, row2, row3) {
    this.Row0 = row0.MemberwiseClone();
    this.Row1 = row1.MemberwiseClone();
    this.Row2 = row2.MemberwiseClone();
    this.Row3 = row3.MemberwiseClone();
  };

  function double4x4__ctor$01 (m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    this.Row0 = $S01().Construct(m00, m01, m02, m03);
    this.Row1 = $S01().Construct(m10, m11, m12, m13);
    this.Row2 = $S01().Construct(m20, m21, m22, m23);
    this.Row3 = $S01().Construct(m30, m31, m32, m33);
  };

  function double4x4_Add (left, right) {
    return $S02().Construct((+left.get_M11() + +right.get_M11()), (+left.get_M12() + +right.get_M12()), (+left.get_M13() + +right.get_M13()), (+left.get_M14() + +right.get_M14()), (+left.get_M21() + +right.get_M21()), (+left.get_M22() + +right.get_M22()), (+left.get_M23() + +right.get_M23()), (+left.get_M24() + +right.get_M24()), (+left.get_M31() + +right.get_M31()), (+left.get_M32() + +right.get_M32()), (+left.get_M33() + +right.get_M33()), (+left.get_M34() + +right.get_M34()), (+left.get_M41() + +right.get_M41()), (+left.get_M42() + +right.get_M42()), (+left.get_M43() + +right.get_M43()), (+left.get_M44() + +right.get_M44()));
  };

  function double4x4_CreateFromAxisAngle$02 (axis, angle, /* ref */ result) {
    var num = (Math.cos(-angle));
    var num2 = (Math.sin(-angle));
    var num3 = 1 - num;
    axis.Normalize();
    result.set($S02().Construct((((num3 * +axis.x) * +axis.x) + num), (((num3 * +axis.x) * +axis.y) + (num2 * +axis.z)), (((num3 * +axis.x) * +axis.z) - (num2 * +axis.y)), 0, (((num3 * +axis.x) * +axis.y) - (num2 * +axis.z)), (((num3 * +axis.y) * +axis.y) + num), (((num3 * +axis.y) * +axis.z) + (num2 * +axis.x)), 0, (((num3 * +axis.x) * +axis.z) + (num2 * +axis.y)), (((num3 * +axis.y) * +axis.z) - (num2 * +axis.x)), (((num3 * +axis.z) * +axis.z) + num), 0, 0, 0, 0, 1));
  };

  function double4x4_CreateFromAxisAngle$03 (axis, angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateFromAxisAngle(axis.MemberwiseClone(), angle, /* ref */ result);
    return result.get();
  };

  function double4x4_CreateOrthographic$04 (width, height, zNear, zFar, /* ref */ result) {
    $thisType.CreateOrthographicOffCenter(
      +((-width / 2)), 
      +((+width / 2)), 
      +((-height / 2)), 
      +((+height / 2)), 
      zNear, 
      zFar, 
      /* ref */ result
    );
  };

  function double4x4_CreateOrthographic$05 (width, height, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateOrthographicOffCenter(
      +((-width / 2)), 
      +((+width / 2)), 
      +((-height / 2)), 
      +((+height / 2)), 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  };

  function double4x4_CreateOrthographicOffCenter$06 (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    result.set(new $thisType());
    var num = +((1 / (+right - +left)));
    var num2 = +((1 / (+top - +bottom)));
    var num3 = +((1 / (+zFar - +zNear)));
    (result.get()).set_M11(2 * num);
    (result.get()).set_M22(2 * num2);
    (result.get()).set_M33(2 * num3);
    (result.get()).set_M14(-(+right + +left) * num);
    (result.get()).set_M24(-(+top + +bottom) * num2);
    (result.get()).set_M34(-(+zFar + +zNear) * num3);
    (result.get()).set_M44(1);
  };

  function double4x4_CreateOrthographicOffCenter$07 (left, right, bottom, top, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateOrthographicOffCenter(
      left, 
      right, 
      bottom, 
      top, 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  };

  function double4x4_CreateOrthographicOffCenterRH (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    result.set(new $thisType());
    var num = +((1 / (+right - +left)));
    var num2 = +((1 / (+top - +bottom)));
    var num3 = +((1 / (+zFar - +zNear)));
    (result.get()).set_M11(2 * num);
    (result.get()).set_M22(2 * num2);
    (result.get()).set_M33(-2 * num3);
    (result.get()).set_M14(-(+right + +left) * num);
    (result.get()).set_M24(-(+top + +bottom) * num2);
    (result.get()).set_M34(-(+zFar + +zNear) * num3);
    (result.get()).set_M44(1);
  };

  function double4x4_CreatePerspectiveFieldOfView$08 (fovy, aspect, zNear, zFar, /* ref */ result) {
    if (!((+fovy > 0) && (+fovy <= 3.1415926535897931))) {
      throw $S03().Construct("fovy");
    }
    if (+aspect <= 0) {
      throw $S03().Construct("aspect");
    }
    if (+zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    if (+zFar <= 0) {
      throw $S03().Construct("zFar");
    }
    if (+zNear >= +zFar) {
      throw $S03().Construct("zNear");
    }
    var num = +zNear * (Math.tan((0.5 * +fovy)));
    var num2 = -num;
    $thisType.CreatePerspectiveOffCenter(
      num2 * +aspect, 
      num * +aspect, 
      num2, 
      num, 
      zNear, 
      zFar, 
      /* ref */ result
    );
  };

  function double4x4_CreatePerspectiveFieldOfView$09 (fovy, aspect, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreatePerspectiveFieldOfView(
      fovy, 
      aspect, 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  };

  function double4x4_CreatePerspectiveFieldOfView_ROW$0A (fovy, aspect, zNear, zFar, /* ref */ result) {
    if (!((+fovy > 0) && (+fovy <= 3.1415926535897931))) {
      throw $S03().Construct("fovy");
    }
    if (+aspect <= 0) {
      throw $S03().Construct("aspect");
    }
    if (+zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    if (+zFar <= 0) {
      throw $S03().Construct("zFar");
    }
    if (+zNear >= +zFar) {
      throw $S03().Construct("zNear");
    }
    var num = +zNear * (Math.tan((0.5 * +fovy)));
    var num2 = -num;
    $thisType.CreatePerspectiveOffCenter_ROW(
      num2 * +aspect, 
      num * +aspect, 
      num2, 
      num, 
      zNear, 
      zFar, 
      /* ref */ result
    );
  };

  function double4x4_CreatePerspectiveFieldOfView_ROW$0B (fovy, aspect, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreatePerspectiveFieldOfView_ROW(
      fovy, 
      aspect, 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  };

  function double4x4_CreatePerspectiveOffCenter$0C (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    if (+zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    if (+zFar <= 0) {
      throw $S03().Construct("zFar");
    }
    if (+zNear >= +zFar) {
      throw $S03().Construct("zNear");
    }
    var m2 = +(((2 * +zNear) / (+top - +bottom)));
    var m4 = +(((+top + +bottom) / (+bottom - +top)));
    result.set($S02().Construct(+(((2 * +zNear) / (+right - +left))), 0, +(((+left + +right) / (+left - +right))), 0, 0, m2, m4, 0, 0, 0, +(((+zFar + +zNear) / (+zFar - +zNear))), +((-((2 * +zFar) * +zNear) / (+zFar - +zNear))), 0, 0, 1, 0));
  };

  function double4x4_CreatePerspectiveOffCenter$0D (left, right, bottom, top, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreatePerspectiveOffCenter(
      left, 
      right, 
      bottom, 
      top, 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  };

  function double4x4_CreatePerspectiveOffCenter_ROW (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    if (+zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    if (+zFar <= 0) {
      throw $S03().Construct("zFar");
    }
    if (+zNear >= +zFar) {
      throw $S03().Construct("zNear");
    }
    var m = +(((2 * +zNear) / (+right - +left)));
    var m2 = +(((2 * +zNear) / (+top - +bottom)));
    var m3 = +(((+left + +right) / (+left - +right)));
    var m4 = +(((+top + +bottom) / (+bottom - +top)));
    result.set($S02().Construct(m, 0, 0, 0, 0, m2, 0, 0, m3, m4, +(((+zFar + +zNear) / (+zFar - +zNear))), 1, 0, 0, +((-((2 * +zFar) * +zNear) / (+zFar - +zNear))), 0));
  };

  function double4x4_CreatePerspectiveOffCenterRH (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    if (+zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    if (+zFar <= 0) {
      throw $S03().Construct("zFar");
    }
    if (+zNear >= +zFar) {
      throw $S03().Construct("zNear");
    }
    var m = +(((2 * +zNear) / (+right - +left)));
    var m2 = +(((2 * +zNear) / (+top - +bottom)));
    var m3 = +(((+right + +left) / (+right - +left)));
    var m4 = +(((+top + +bottom) / (+top - +bottom)));
    result.set($S02().Construct(m, 0, m3, 0, 0, m2, m4, 0, 0, 0, +((-(+zFar + +zNear) / (+zFar - +zNear))), +((-((2 * +zFar) * +zNear) / (+zFar - +zNear))), 0, 0, -1, 0));
  };

  function double4x4_CreateRotationX$0E (angle, /* ref */ result) {
    var num = (Math.cos(angle));
    var num2 = (Math.sin(angle));
    result.get().Row0 = $T00().UnitX.MemberwiseClone();
    result.get().Row1 = $S01().Construct(0, num, -num2, 0);
    result.get().Row2 = $S01().Construct(0, num2, num, 0);
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  };

  function double4x4_CreateRotationX$0F (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationX(angle, /* ref */ result);
    return result.get();
  };

  function double4x4_CreateRotationX_ROW$10 (angle, /* ref */ result) {
    var num = (Math.cos(angle));
    var num2 = (Math.sin(angle));
    result.get().Row0 = $T00().UnitX.MemberwiseClone();
    result.get().Row1 = $S01().Construct(0, num, num2, 0);
    result.get().Row2 = $S01().Construct(0, -num2, num, 0);
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  };

  function double4x4_CreateRotationX_ROW$11 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationX_ROW(angle, /* ref */ result);
    return result.get();
  };

  function double4x4_CreateRotationY$12 (angle, /* ref */ result) {
    var num = (Math.cos(angle));
    var num2 = (Math.sin(angle));
    result.get().Row0 = $S01().Construct(num, 0, num2, 0);
    result.get().Row1 = $T00().UnitY.MemberwiseClone();
    result.get().Row2 = $S01().Construct(-num2, 0, num, 0);
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  };

  function double4x4_CreateRotationY$13 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationY(angle, /* ref */ result);
    return result.get();
  };

  function double4x4_CreateRotationY_ROW$14 (angle, /* ref */ result) {
    var num = (Math.cos(angle));
    var num2 = (Math.sin(angle));
    result.get().Row0 = $S01().Construct(num, 0, -num2, 0);
    result.get().Row1 = $T00().UnitY.MemberwiseClone();
    result.get().Row2 = $S01().Construct(num2, 0, num, 0);
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  };

  function double4x4_CreateRotationY_ROW$15 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationY_ROW(angle, /* ref */ result);
    return result.get();
  };

  function double4x4_CreateRotationZ$16 (angle, /* ref */ result) {
    var num = (Math.cos(angle));
    var num2 = (Math.sin(angle));
    result.get().Row0 = $S01().Construct(num, -num2, 0, 0);
    result.get().Row1 = $S01().Construct(num2, num, 0, 0);
    result.get().Row2 = $T00().UnitZ.MemberwiseClone();
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  };

  function double4x4_CreateRotationZ$17 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationZ(angle, /* ref */ result);
    return result.get();
  };

  function double4x4_CreateTranslation$18 (x, y, z, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    (result.get()).set_M14(x);
    (result.get()).set_M24(y);
    (result.get()).set_M34(z);
  };

  function double4x4_CreateTranslation$19 (/* ref */ vector, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    (result.get()).set_M14(vector.get().x);
    (result.get()).set_M24(vector.get().y);
    (result.get()).set_M34(vector.get().z);
  };

  function double4x4_CreateTranslation$1A (x, y, z) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateTranslation(x, y, z, /* ref */ result);
    return result.get();
  };

  function double4x4_CreateTranslation$1B (vector) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateTranslation(vector.x, vector.y, vector.z, /* ref */ result);
    return result.get();
  };

  function double4x4_CreateTranslation_ROW$1C (x, y, z, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    result.get().Row3 = $S01().Construct(x, y, z, 1);
  };

  function double4x4_CreateTranslation_ROW$1D (x, y, z) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateTranslation_ROW(x, y, z, /* ref */ result);
    return result.get();
  };

  function double4x4_Object_Equals (obj) {
    return ($thisType.$Is(obj) && this.Equals($thisType.$Cast(obj)));
  };

  function double4x4_Equals$1E (other) {
    return (!(!$T00().op_Equality(this.Row0, other.Row0) || 
        !$T00().op_Equality(this.Row1, other.Row1) || 
        !$T00().op_Equality(this.Row2, other.Row2)) && $T00().op_Equality(this.Row3, other.Row3));
  };

  function double4x4_get_Column0 () {
    return $S01().Construct(this.Row0.x, this.Row1.x, this.Row2.x, this.Row3.x);
  };

  function double4x4_get_Column1 () {
    return $S01().Construct(this.Row0.y, this.Row1.y, this.Row2.y, this.Row3.y);
  };

  function double4x4_get_Column2 () {
    return $S01().Construct(this.Row0.z, this.Row1.z, this.Row2.z, this.Row3.z);
  };

  function double4x4_get_Column3 () {
    return $S01().Construct(this.Row0.w, this.Row1.w, this.Row2.w, this.Row3.w);
  };

  function double4x4_get_Determinant () {
    return ((((((((((((((((((((((((((+this.Row0.x * +this.Row1.y) * +this.Row2.z) * +this.Row3.w) - (((+this.Row0.x * +this.Row1.y) * +this.Row2.w) * +this.Row3.z)) + (((+this.Row0.x * +this.Row1.z) * +this.Row2.w) * +this.Row3.y)) - (((+this.Row0.x * +this.Row1.z) * +this.Row2.y) * +this.Row3.w)) + (((+this.Row0.x * +this.Row1.w) * +this.Row2.y) * +this.Row3.z)) - (((+this.Row0.x * +this.Row1.w) * +this.Row2.z) * +this.Row3.y)) - (((+this.Row0.y * +this.Row1.z) * +this.Row2.w) * +this.Row3.x)) + (((+this.Row0.y * +this.Row1.z) * +this.Row2.x) * +this.Row3.w)) - (((+this.Row0.y * +this.Row1.w) * +this.Row2.x) * +this.Row3.z)) + (((+this.Row0.y * +this.Row1.w) * +this.Row2.z) * +this.Row3.x)) - (((+this.Row0.y * +this.Row1.x) * +this.Row2.z) * +this.Row3.w)) + (((+this.Row0.y * +this.Row1.x) * +this.Row2.w) * +this.Row3.z)) + (((+this.Row0.z * +this.Row1.w) * +this.Row2.x) * +this.Row3.y)) - (((+this.Row0.z * +this.Row1.w) * +this.Row2.y) * +this.Row3.x)) + (((+this.Row0.z * +this.Row1.x) * +this.Row2.y) * +this.Row3.w)) - (((+this.Row0.z * +this.Row1.x) * +this.Row2.w) * +this.Row3.y)) + (((+this.Row0.z * +this.Row1.y) * +this.Row2.w) * +this.Row3.x)) - (((+this.Row0.z * +this.Row1.y) * +this.Row2.x) * +this.Row3.w)) - (((+this.Row0.w * +this.Row1.x) * +this.Row2.y) * +this.Row3.z)) + (((+this.Row0.w * +this.Row1.x) * +this.Row2.z) * +this.Row3.y)) - (((+this.Row0.w * +this.Row1.y) * +this.Row2.z) * +this.Row3.x)) + (((+this.Row0.w * +this.Row1.y) * +this.Row2.x) * +this.Row3.z)) - (((+this.Row0.w * +this.Row1.z) * +this.Row2.x) * +this.Row3.y)) + (((+this.Row0.w * +this.Row1.z) * +this.Row2.y) * +this.Row3.x));
  };

  function double4x4_get_IsAffine () {
    return $T00().op_Equality(this.Row3, $T00().UnitW);
  };

  function double4x4_get_M11 () {
    return this.Row0.x;
  };

  function double4x4_get_M12 () {
    return this.Row0.y;
  };

  function double4x4_get_M13 () {
    return this.Row0.z;
  };

  function double4x4_get_M14 () {
    return this.Row0.w;
  };

  function double4x4_get_M21 () {
    return this.Row1.x;
  };

  function double4x4_get_M22 () {
    return this.Row1.y;
  };

  function double4x4_get_M23 () {
    return this.Row1.z;
  };

  function double4x4_get_M24 () {
    return this.Row1.w;
  };

  function double4x4_get_M31 () {
    return this.Row2.x;
  };

  function double4x4_get_M32 () {
    return this.Row2.y;
  };

  function double4x4_get_M33 () {
    return this.Row2.z;
  };

  function double4x4_get_M34 () {
    return this.Row2.w;
  };

  function double4x4_get_M41 () {
    return this.Row3.x;
  };

  function double4x4_get_M42 () {
    return this.Row3.y;
  };

  function double4x4_get_M43 () {
    return this.Row3.z;
  };

  function double4x4_get_M44 () {
    return this.Row3.w;
  };

  function double4x4_get_Offset () {
    return $S04().Construct(this.Row0.w, this.Row1.w, this.Row2.w);
  };

  function double4x4_get_Parse () {
    return $thisType.double4x4$Parse$value;
  };

  function double4x4_GetHashCode () {
    return (((((this.Row0).GetHashCode() | 0) ^ ((this.Row1).GetHashCode() | 0)) ^ ((this.Row2).GetHashCode() | 0)) ^ ((this.Row3).GetHashCode() | 0));
  };

  function double4x4_Invert$1F () {
    JSIL.CopyMembers($thisType.Invert(this).MemberwiseClone(), this);
  };

  function double4x4_Invert$20 (mat) {
    if (!(!$thisType.op_Equality(mat, $thisType.Identity) && !$thisType.op_Equality(mat, $thisType.Zero))) {
      var result = mat.MemberwiseClone();
    } else if (mat.get_IsAffine()) {
      result = $thisType.InvertAffine(mat.MemberwiseClone());
    } else {
      mat.Transpose();
      var num = +mat.get_M33() * +mat.get_M44();
      var num2 = +mat.get_M34() * +mat.get_M43();
      var num3 = +mat.get_M32() * +mat.get_M44();
      var num4 = +mat.get_M34() * +mat.get_M42();
      var num5 = +mat.get_M32() * +mat.get_M43();
      var num6 = +mat.get_M33() * +mat.get_M42();
      var num7 = +mat.get_M31() * +mat.get_M44();
      var num8 = +mat.get_M34() * +mat.get_M41();
      var num9 = +mat.get_M31() * +mat.get_M43();
      var num10 = +mat.get_M33() * +mat.get_M41();
      var num11 = +mat.get_M31() * +mat.get_M42();
      var num12 = +mat.get_M32() * +mat.get_M41();
      var num13 = ((num * +mat.get_M22()) + (num4 * +mat.get_M23())) + (num5 * +mat.get_M24());
      num13 -= ((num2 * +mat.get_M22()) + (num3 * +mat.get_M23())) + (num6 * +mat.get_M24());
      var num14 = ((num2 * +mat.get_M21()) + (num7 * +mat.get_M23())) + (num10 * +mat.get_M24());
      num14 -= ((num * +mat.get_M21()) + (num8 * +mat.get_M23())) + (num9 * +mat.get_M24());
      var num15 = ((num3 * +mat.get_M21()) + (num8 * +mat.get_M22())) + (num11 * +mat.get_M24());
      num15 -= ((num4 * +mat.get_M21()) + (num7 * +mat.get_M22())) + (num12 * +mat.get_M24());
      var num16 = ((num6 * +mat.get_M21()) + (num9 * +mat.get_M22())) + (num12 * +mat.get_M23());
      num16 -= ((num5 * +mat.get_M21()) + (num10 * +mat.get_M22())) + (num11 * +mat.get_M23());
      var num17 = ((num2 * +mat.get_M12()) + (num3 * +mat.get_M13())) + (num6 * +mat.get_M14());
      num17 -= ((num * +mat.get_M12()) + (num4 * +mat.get_M13())) + (num5 * +mat.get_M14());
      var num18 = ((num * +mat.get_M11()) + (num8 * +mat.get_M13())) + (num9 * +mat.get_M14());
      num18 -= ((num2 * +mat.get_M11()) + (num7 * +mat.get_M13())) + (num10 * +mat.get_M14());
      var num19 = ((num4 * +mat.get_M11()) + (num7 * +mat.get_M12())) + (num12 * +mat.get_M14());
      num19 -= ((num3 * +mat.get_M11()) + (num8 * +mat.get_M12())) + (num11 * +mat.get_M14());
      var num20 = ((num5 * +mat.get_M11()) + (num10 * +mat.get_M12())) + (num11 * +mat.get_M13());
      num20 -= ((num6 * +mat.get_M11()) + (num9 * +mat.get_M12())) + (num12 * +mat.get_M13());
      num = +mat.get_M13() * +mat.get_M24();
      num2 = +mat.get_M14() * +mat.get_M23();
      num3 = +mat.get_M12() * +mat.get_M24();
      num4 = +mat.get_M14() * +mat.get_M22();
      num5 = +mat.get_M12() * +mat.get_M23();
      num6 = +mat.get_M13() * +mat.get_M22();
      num7 = +mat.get_M11() * +mat.get_M24();
      num8 = +mat.get_M14() * +mat.get_M21();
      num9 = +mat.get_M11() * +mat.get_M23();
      num10 = +mat.get_M13() * +mat.get_M21();
      num11 = +mat.get_M11() * +mat.get_M22();
      num12 = +mat.get_M12() * +mat.get_M21();
      var num21 = ((num * +mat.get_M42()) + (num4 * +mat.get_M43())) + (num5 * +mat.get_M44());
      num21 -= ((num2 * +mat.get_M42()) + (num3 * +mat.get_M43())) + (num6 * +mat.get_M44());
      var num22 = ((num2 * +mat.get_M41()) + (num7 * +mat.get_M43())) + (num10 * +mat.get_M44());
      num22 -= ((num * +mat.get_M41()) + (num8 * +mat.get_M43())) + (num9 * +mat.get_M44());
      var num23 = ((num3 * +mat.get_M41()) + (num8 * +mat.get_M42())) + (num11 * +mat.get_M44());
      num23 -= ((num4 * +mat.get_M41()) + (num7 * +mat.get_M42())) + (num12 * +mat.get_M44());
      var num24 = ((num6 * +mat.get_M41()) + (num9 * +mat.get_M42())) + (num12 * +mat.get_M43());
      num24 -= ((num5 * +mat.get_M41()) + (num10 * +mat.get_M42())) + (num11 * +mat.get_M43());
      var num25 = ((num3 * +mat.get_M33()) + (num6 * +mat.get_M34())) + (num2 * +mat.get_M32());
      num25 -= ((num5 * +mat.get_M34()) + (num * +mat.get_M32())) + (num4 * +mat.get_M33());
      var num26 = ((num9 * +mat.get_M34()) + (num * +mat.get_M31())) + (num8 * +mat.get_M33());
      num26 -= ((num7 * +mat.get_M33()) + (num10 * +mat.get_M34())) + (num2 * +mat.get_M31());
      var num27 = ((num7 * +mat.get_M32()) + (num12 * +mat.get_M34())) + (num4 * +mat.get_M31());
      num27 -= ((num11 * +mat.get_M34()) + (num3 * +mat.get_M31())) + (num8 * +mat.get_M32());
      var num28 = ((num11 * +mat.get_M33()) + (num5 * +mat.get_M31())) + (num10 * +mat.get_M32());
      num28 -= ((num9 * +mat.get_M32()) + (num12 * +mat.get_M33())) + (num6 * +mat.get_M31());
      var num29 = (((+mat.get_M11() * num13) + (+mat.get_M12() * num14)) + (+mat.get_M13() * num15)) + (+mat.get_M14() * num16);
      if (!((num29 <= 1.1920930376163597E-07) && (num29 >= -1.1920930376163597E-07))) {
        num29 = +((1 / num29));
        $thisType.prototype._ctor.call(mat, 
          num29 * num13, 
          num29 * num14, 
          num29 * num15, 
          num29 * num16, 
          num29 * num17, 
          num29 * num18, 
          num29 * num19, 
          num29 * num20, 
          num29 * num21, 
          num29 * num22, 
          num29 * num23, 
          num29 * num24, 
          num29 * num25, 
          num29 * num26, 
          num29 * num27, 
          num29 * num28
        );
      } else {
        mat.Transpose();
      }
      result = mat.MemberwiseClone();
    }
    return result;
  };

  function double4x4_InvertAffine (mat) {
    var w = -(((+mat.get_M11() * +mat.get_M14()) + (+mat.get_M21() * +mat.get_M24())) + (+mat.get_M31() * +mat.get_M34()));
    var w2 = -(((+mat.get_M12() * +mat.get_M14()) + (+mat.get_M22() * +mat.get_M24())) + (+mat.get_M32() * +mat.get_M34()));
    var w3 = -(((+mat.get_M13() * +mat.get_M14()) + (+mat.get_M23() * +mat.get_M24())) + (+mat.get_M33() * +mat.get_M34()));
    return $S00().Construct($S01().Construct(mat.get_M11(), mat.get_M21(), mat.get_M31(), w), $S01().Construct(mat.get_M12(), mat.get_M22(), mat.get_M32(), w2), $S01().Construct(mat.get_M13(), mat.get_M23(), mat.get_M33(), w3), $S01().Construct(0, 0, 0, 1));
  };

  function double4x4_LookAt$21 (eye, target, up) {
    var double = $T02().Normalize($T02().op_Subtraction(target.MemberwiseClone(), eye).MemberwiseClone());
    var double2 = $T02().Normalize($T02().Cross(up.MemberwiseClone(), double.MemberwiseClone()).MemberwiseClone());
    var left = $T02().Cross(double.MemberwiseClone(), double2.MemberwiseClone()).MemberwiseClone();
    return $S02().Construct(double2.x, double2.y, double2.z, -$T02().Dot(double2, eye), left.x, left.y, left.z, -$T02().Dot(left, eye), double.x, double.y, double.z, -$T02().Dot(double, eye), 0, 0, 0, 1);
  };

  function double4x4_LookAt$22 (eyeX, eyeY, eyeZ, targetX, targetY, targetZ, upX, upY, upZ) {
    return $thisType.LookAt($S04().Construct(eyeX, eyeY, eyeZ), $S04().Construct(targetX, targetY, targetZ), $S04().Construct(upX, upY, upZ));
  };

  function double4x4_LookAt_ROW$23 (eye, target, up) {
    var double = $T02().Normalize($T02().op_Subtraction(target.MemberwiseClone(), eye).MemberwiseClone());
    var double2 = $T02().Normalize($T02().Cross(up.MemberwiseClone(), double.MemberwiseClone()).MemberwiseClone());
    var left = $T02().Cross(double.MemberwiseClone(), double2.MemberwiseClone()).MemberwiseClone();
    return $S00().Construct($S01().Construct(double2.x, left.x, double.x, 0), $S01().Construct(double2.y, left.y, double.y, 0), $S01().Construct(double2.z, left.z, double.z, 0), $S01().Construct(-$T02().Dot(double2, eye), -$T02().Dot(left, eye), -$T02().Dot(double, eye), 1));
  };

  function double4x4_LookAt_ROW$24 (eyeX, eyeY, eyeZ, targetX, targetY, targetZ, upX, upY, upZ) {
    return $thisType.LookAt_ROW($S04().Construct(eyeX, eyeY, eyeZ), $S04().Construct(targetX, targetY, targetZ), $S04().Construct(upX, upY, upZ));
  };

  function double4x4_LookAtRH (eye, target, up) {
    var double = $T02().Normalize($T02().op_Subtraction(eye.MemberwiseClone(), target).MemberwiseClone());
    var double2 = $T02().Normalize($T02().Cross(up.MemberwiseClone(), double.MemberwiseClone()).MemberwiseClone());
    var left = $T02().Cross(double.MemberwiseClone(), double2.MemberwiseClone()).MemberwiseClone();
    return $S02().Construct(double2.x, double2.y, double2.z, -$T02().Dot(double2, eye), left.x, left.y, left.z, -$T02().Dot(left, eye), double.x, double.y, double.z, -$T02().Dot(double, eye), 0, 0, 0, 1);
  };

  function double4x4_Mult$25 ($left, $right) {
    var right = new JSIL.BoxedVariable($right);
    var left = new JSIL.BoxedVariable($left);
    var double4x = new JSIL.BoxedVariable(new $thisType());
    if ($thisType.op_Equality(left.get(), $thisType.Identity)) {
      var result = right.get().MemberwiseClone();
    } else if ($thisType.op_Equality(right.get(), $thisType.Identity)) {
      result = left.get().MemberwiseClone();
    } else if (!(!$thisType.op_Equality(left.get(), $thisType.Zero) && !$thisType.op_Equality(right.get(), $thisType.Zero))) {
      result = $thisType.Zero.MemberwiseClone();
    } else {
      if (!(!(left.get()).get_IsAffine() || !(right.get()).get_IsAffine())) {
        $thisType.MultAffine(/* ref */ left, /* ref */ right, /* ref */ double4x);
      } else {
        $thisType.Mult(/* ref */ left, /* ref */ right, /* ref */ double4x);
      }
      result = double4x.get().MemberwiseClone();
    }
    return result;
  };

  function double4x4_Mult$26 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct(((((+(left.get()).get_M11() * +(right.get()).get_M11()) + (+(left.get()).get_M12() * +(right.get()).get_M21())) + (+(left.get()).get_M13() * +(right.get()).get_M31())) + (+(left.get()).get_M14() * +(right.get()).get_M41())), ((((+(left.get()).get_M11() * +(right.get()).get_M12()) + (+(left.get()).get_M12() * +(right.get()).get_M22())) + (+(left.get()).get_M13() * +(right.get()).get_M32())) + (+(left.get()).get_M14() * +(right.get()).get_M42())), ((((+(left.get()).get_M11() * +(right.get()).get_M13()) + (+(left.get()).get_M12() * +(right.get()).get_M23())) + (+(left.get()).get_M13() * +(right.get()).get_M33())) + (+(left.get()).get_M14() * +(right.get()).get_M43())), ((((+(left.get()).get_M11() * +(right.get()).get_M14()) + (+(left.get()).get_M12() * +(right.get()).get_M24())) + (+(left.get()).get_M13() * +(right.get()).get_M34())) + (+(left.get()).get_M14() * +(right.get()).get_M44())), ((((+(left.get()).get_M21() * +(right.get()).get_M11()) + (+(left.get()).get_M22() * +(right.get()).get_M21())) + (+(left.get()).get_M23() * +(right.get()).get_M31())) + (+(left.get()).get_M24() * +(right.get()).get_M41())), ((((+(left.get()).get_M21() * +(right.get()).get_M12()) + (+(left.get()).get_M22() * +(right.get()).get_M22())) + (+(left.get()).get_M23() * +(right.get()).get_M32())) + (+(left.get()).get_M24() * +(right.get()).get_M42())), ((((+(left.get()).get_M21() * +(right.get()).get_M13()) + (+(left.get()).get_M22() * +(right.get()).get_M23())) + (+(left.get()).get_M23() * +(right.get()).get_M33())) + (+(left.get()).get_M24() * +(right.get()).get_M43())), ((((+(left.get()).get_M21() * +(right.get()).get_M14()) + (+(left.get()).get_M22() * +(right.get()).get_M24())) + (+(left.get()).get_M23() * +(right.get()).get_M34())) + (+(left.get()).get_M24() * +(right.get()).get_M44())), ((((+(left.get()).get_M31() * +(right.get()).get_M11()) + (+(left.get()).get_M32() * +(right.get()).get_M21())) + (+(left.get()).get_M33() * +(right.get()).get_M31())) + (+(left.get()).get_M34() * +(right.get()).get_M41())), ((((+(left.get()).get_M31() * +(right.get()).get_M12()) + (+(left.get()).get_M32() * +(right.get()).get_M22())) + (+(left.get()).get_M33() * +(right.get()).get_M32())) + (+(left.get()).get_M34() * +(right.get()).get_M42())), ((((+(left.get()).get_M31() * +(right.get()).get_M13()) + (+(left.get()).get_M32() * +(right.get()).get_M23())) + (+(left.get()).get_M33() * +(right.get()).get_M33())) + (+(left.get()).get_M34() * +(right.get()).get_M43())), ((((+(left.get()).get_M31() * +(right.get()).get_M14()) + (+(left.get()).get_M32() * +(right.get()).get_M24())) + (+(left.get()).get_M33() * +(right.get()).get_M34())) + (+(left.get()).get_M34() * +(right.get()).get_M44())), ((((+(left.get()).get_M41() * +(right.get()).get_M11()) + (+(left.get()).get_M42() * +(right.get()).get_M21())) + (+(left.get()).get_M43() * +(right.get()).get_M31())) + (+(left.get()).get_M44() * +(right.get()).get_M41())), ((((+(left.get()).get_M41() * +(right.get()).get_M12()) + (+(left.get()).get_M42() * +(right.get()).get_M22())) + (+(left.get()).get_M43() * +(right.get()).get_M32())) + (+(left.get()).get_M44() * +(right.get()).get_M42())), ((((+(left.get()).get_M41() * +(right.get()).get_M13()) + (+(left.get()).get_M42() * +(right.get()).get_M23())) + (+(left.get()).get_M43() * +(right.get()).get_M33())) + (+(left.get()).get_M44() * +(right.get()).get_M43())), ((((+(left.get()).get_M41() * +(right.get()).get_M14()) + (+(left.get()).get_M42() * +(right.get()).get_M24())) + (+(left.get()).get_M43() * +(right.get()).get_M34())) + (+(left.get()).get_M44() * +(right.get()).get_M44()))));
  };

  function double4x4_MultAffine (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct((((+(left.get()).get_M11() * +(right.get()).get_M11()) + (+(left.get()).get_M12() * +(right.get()).get_M21())) + (+(left.get()).get_M13() * +(right.get()).get_M31())), (((+(left.get()).get_M11() * +(right.get()).get_M12()) + (+(left.get()).get_M12() * +(right.get()).get_M22())) + (+(left.get()).get_M13() * +(right.get()).get_M32())), (((+(left.get()).get_M11() * +(right.get()).get_M13()) + (+(left.get()).get_M12() * +(right.get()).get_M23())) + (+(left.get()).get_M13() * +(right.get()).get_M33())), ((((+(left.get()).get_M11() * +(right.get()).get_M14()) + (+(left.get()).get_M12() * +(right.get()).get_M24())) + (+(left.get()).get_M13() * +(right.get()).get_M34())) + +(left.get()).get_M14()), (((+(left.get()).get_M21() * +(right.get()).get_M11()) + (+(left.get()).get_M22() * +(right.get()).get_M21())) + (+(left.get()).get_M23() * +(right.get()).get_M31())), (((+(left.get()).get_M21() * +(right.get()).get_M12()) + (+(left.get()).get_M22() * +(right.get()).get_M22())) + (+(left.get()).get_M23() * +(right.get()).get_M32())), (((+(left.get()).get_M21() * +(right.get()).get_M13()) + (+(left.get()).get_M22() * +(right.get()).get_M23())) + (+(left.get()).get_M23() * +(right.get()).get_M33())), ((((+(left.get()).get_M21() * +(right.get()).get_M14()) + (+(left.get()).get_M22() * +(right.get()).get_M24())) + (+(left.get()).get_M23() * +(right.get()).get_M34())) + +(left.get()).get_M24()), (((+(left.get()).get_M31() * +(right.get()).get_M11()) + (+(left.get()).get_M32() * +(right.get()).get_M21())) + (+(left.get()).get_M33() * +(right.get()).get_M31())), (((+(left.get()).get_M31() * +(right.get()).get_M12()) + (+(left.get()).get_M32() * +(right.get()).get_M22())) + (+(left.get()).get_M33() * +(right.get()).get_M32())), (((+(left.get()).get_M31() * +(right.get()).get_M13()) + (+(left.get()).get_M32() * +(right.get()).get_M23())) + (+(left.get()).get_M33() * +(right.get()).get_M33())), ((((+(left.get()).get_M31() * +(right.get()).get_M14()) + (+(left.get()).get_M32() * +(right.get()).get_M24())) + (+(left.get()).get_M33() * +(right.get()).get_M34())) + +(left.get()).get_M34()), 0, 0, 0, 1));
  };

  function double4x4_op_Addition (left, right) {
    return $thisType.Add(left, right);
  };

  function double4x4_op_Equality (left, right) {
    return left.Equals(right);
  };

  function double4x4_op_Inequality (left, right) {
    return !left.Equals(right);
  };

  function double4x4_op_Multiply$27 (left, right) {
    return $thisType.Mult(left.MemberwiseClone(), right.MemberwiseClone());
  };

  function double4x4_op_Multiply$28 (matrix, vector) {
    return $thisType.Transform(matrix, vector);
  };

  function double4x4_op_Multiply$29 (vector, matrix) {
    return $thisType.TransformPremult(vector, matrix);
  };

  function double4x4_op_Multiply$2A (matrix, vector) {
    return $thisType.TransformPD(matrix, vector);
  };

  function double4x4_op_Multiply$2B (vector, matrix) {
    return $thisType.TransformPremultPD(vector, matrix);
  };

  function double4x4_op_Subtraction (left, right) {
    return $thisType.Substract(left, right);
  };

  function double4x4_Scale$2C (scale) {
    return $thisType.Scale(scale, scale, scale);
  };

  function double4x4_Scale$2D (scale) {
    return $thisType.Scale(scale.x, scale.y, scale.z);
  };

  function double4x4_Scale$2E (x, y, z) {
    var result = new $thisType();
    result.Row0 = $S05().CallStatic($T00(), "op_Multiply", null, $T00().UnitX.MemberwiseClone(), x);
    result.Row1 = $S05().CallStatic($T00(), "op_Multiply", null, $T00().UnitY.MemberwiseClone(), y);
    result.Row2 = $S05().CallStatic($T00(), "op_Multiply", null, $T00().UnitZ.MemberwiseClone(), z);
    result.Row3 = $T00().UnitW.MemberwiseClone();
    return result;
  };

  function double4x4_set_M11 (value) {
    this.Row0.x = +value;
  };

  function double4x4_set_M12 (value) {
    this.Row0.y = +value;
  };

  function double4x4_set_M13 (value) {
    this.Row0.z = +value;
  };

  function double4x4_set_M14 (value) {
    this.Row0.w = +value;
  };

  function double4x4_set_M21 (value) {
    this.Row1.x = +value;
  };

  function double4x4_set_M22 (value) {
    this.Row1.y = +value;
  };

  function double4x4_set_M23 (value) {
    this.Row1.z = +value;
  };

  function double4x4_set_M24 (value) {
    this.Row1.w = +value;
  };

  function double4x4_set_M31 (value) {
    this.Row2.x = +value;
  };

  function double4x4_set_M32 (value) {
    this.Row2.y = +value;
  };

  function double4x4_set_M33 (value) {
    this.Row2.z = +value;
  };

  function double4x4_set_M34 (value) {
    this.Row2.w = +value;
  };

  function double4x4_set_M41 (value) {
    this.Row3.x = +value;
  };

  function double4x4_set_M42 (value) {
    this.Row3.y = +value;
  };

  function double4x4_set_M43 (value) {
    this.Row3.z = +value;
  };

  function double4x4_set_M44 (value) {
    this.Row3.w = +value;
  };

  function double4x4_set_Parse (value) {
    $thisType.double4x4$Parse$value = value;
  };

  function double4x4_Substract (left, right) {
    return $S02().Construct((+left.get_M11() - +right.get_M11()), (+left.get_M12() - +right.get_M12()), (+left.get_M13() - +right.get_M13()), (+left.get_M14() - +right.get_M14()), (+left.get_M21() - +right.get_M21()), (+left.get_M22() - +right.get_M22()), (+left.get_M23() - +right.get_M23()), (+left.get_M24() - +right.get_M24()), (+left.get_M31() - +right.get_M31()), (+left.get_M32() - +right.get_M32()), (+left.get_M33() - +right.get_M33()), (+left.get_M34() - +right.get_M34()), (+left.get_M41() - +right.get_M41()), (+left.get_M42() - +right.get_M42()), (+left.get_M43() - +right.get_M43()), (+left.get_M44() - +right.get_M44()));
  };

  function double4x4_ToArray () {
    return JSIL.Array.New($T01(), [this.get_M11(), this.get_M12(), this.get_M13(), this.get_M14(), this.get_M21(), this.get_M22(), this.get_M23(), this.get_M24(), this.get_M31(), this.get_M32(), this.get_M33(), this.get_M34(), this.get_M41(), this.get_M42(), this.get_M43(), this.get_M44()]);
  };

  function double4x4_toString () {
    return $T07().Format("{0}\n{1}\n{2}\n{3}", JSIL.Array.New($T05(), [this.Row0, this.Row1, this.Row2, this.Row3]));
  };

  function double4x4_Transform (matrix, vector) {
    return $S01().Construct(((((+matrix.get_M11() * +vector.x) + (+matrix.get_M12() * +vector.y)) + (+matrix.get_M13() * +vector.z)) + (+matrix.get_M14() * +vector.w)), ((((+matrix.get_M21() * +vector.x) + (+matrix.get_M22() * +vector.y)) + (+matrix.get_M23() * +vector.z)) + (+matrix.get_M24() * +vector.w)), ((((+matrix.get_M31() * +vector.x) + (+matrix.get_M32() * +vector.y)) + (+matrix.get_M33() * +vector.z)) + (+matrix.get_M34() * +vector.w)), ((((+matrix.get_M41() * +vector.x) + (+matrix.get_M42() * +vector.y)) + (+matrix.get_M43() * +vector.z)) + (+matrix.get_M44() * +vector.w)));
  };

  function double4x4_TransformPD (matrix, vector) {
    var num = (((+matrix.get_M41() * +vector.x) + (+matrix.get_M42() * +vector.y)) + (+matrix.get_M43() * +vector.z)) + +matrix.get_M44();
    return $S04().Construct(+((((((+matrix.get_M11() * +vector.x) + (+matrix.get_M12() * +vector.y)) + (+matrix.get_M13() * +vector.z)) + +matrix.get_M14()) / num)), +((((((+matrix.get_M21() * +vector.x) + (+matrix.get_M22() * +vector.y)) + (+matrix.get_M23() * +vector.z)) + +matrix.get_M24()) / num)), +((((((+matrix.get_M31() * +vector.x) + (+matrix.get_M32() * +vector.y)) + (+matrix.get_M33() * +vector.z)) + +matrix.get_M34()) / num)));
  };

  function double4x4_TransformPremult (vector, matrix) {
    return $S01().Construct(((((+matrix.get_M11() * +vector.x) + (+matrix.get_M21() * +vector.y)) + (+matrix.get_M31() * +vector.z)) + (+matrix.get_M41() * +vector.w)), ((((+matrix.get_M12() * +vector.x) + (+matrix.get_M22() * +vector.y)) + (+matrix.get_M32() * +vector.z)) + (+matrix.get_M42() * +vector.w)), ((((+matrix.get_M13() * +vector.x) + (+matrix.get_M23() * +vector.y)) + (+matrix.get_M33() * +vector.z)) + (+matrix.get_M43() * +vector.w)), ((((+matrix.get_M14() * +vector.x) + (+matrix.get_M24() * +vector.y)) + (+matrix.get_M34() * +vector.z)) + (+matrix.get_M44() * +vector.w)));
  };

  function double4x4_TransformPremultPD (vector, matrix) {
    var num = (((+matrix.get_M14() * +vector.x) + (+matrix.get_M24() * +vector.y)) + (+matrix.get_M34() * +vector.z)) + +matrix.get_M44();
    return $S04().Construct(+((((((+matrix.get_M11() * +vector.x) + (+matrix.get_M21() * +vector.y)) + (+matrix.get_M31() * +vector.z)) + +matrix.get_M41()) / num)), +((((((+matrix.get_M12() * +vector.x) + (+matrix.get_M22() * +vector.y)) + (+matrix.get_M32() * +vector.z)) + +matrix.get_M42()) / num)), +((((((+matrix.get_M13() * +vector.x) + (+matrix.get_M23() * +vector.y)) + (+matrix.get_M33() * +vector.z)) + +matrix.get_M43()) / num)));
  };

  function double4x4_Transpose$2F () {
    JSIL.CopyMembers($thisType.Transpose(this), this);
  };

  function double4x4_Transpose$30 (mat) {
    return $S00().Construct(mat.get_Column0().MemberwiseClone(), mat.get_Column1().MemberwiseClone(), mat.get_Column2().MemberwiseClone(), mat.get_Column3().MemberwiseClone());
  };

  function double4x4_Transpose$31 (/* ref */ mat, /* ref */ result) {
    result.get().Row0 = (mat.get()).get_Column0().MemberwiseClone();
    result.get().Row1 = (mat.get()).get_Column1().MemberwiseClone();
    result.get().Row2 = (mat.get()).get_Column2().MemberwiseClone();
    result.get().Row3 = (mat.get()).get_Column3().MemberwiseClone();
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.double4x4", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 16, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm04.TypeRef("Fusee.Math.double4"), $asm04.TypeRef("Fusee.Math.double4"), 
          $asm04.TypeRef("Fusee.Math.double4"), $asm04.TypeRef("Fusee.Math.double4")
        ]), 
      double4x4__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double
        ]), 
      double4x4__ctor$01
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4x4_Add
    );

    $.Method({Static:true , Public:true }, "CreateFromAxisAngle", 
      new JSIL.MethodSignature(null, [
          $asm04.TypeRef("Fusee.Math.double3"), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_CreateFromAxisAngle$02
    );

    $.Method({Static:true , Public:true }, "CreateFromAxisAngle", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.double3"), $.Double]), 
      double4x4_CreateFromAxisAngle$03
    );

    $.Method({Static:true , Public:true }, "CreateOrthographic", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_CreateOrthographic$04
    );

    $.Method({Static:true , Public:true }, "CreateOrthographic", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double, $.Double
        ]), 
      double4x4_CreateOrthographic$05
    );

    $.Method({Static:true , Public:true }, "CreateOrthographicOffCenter", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_CreateOrthographicOffCenter$06
    );

    $.Method({Static:true , Public:true }, "CreateOrthographicOffCenter", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double
        ]), 
      double4x4_CreateOrthographicOffCenter$07
    );

    $.Method({Static:true , Public:true }, "CreateOrthographicOffCenterRH", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_CreateOrthographicOffCenterRH
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveFieldOfView", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_CreatePerspectiveFieldOfView$08
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveFieldOfView", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double, $.Double
        ]), 
      double4x4_CreatePerspectiveFieldOfView$09
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveFieldOfView_ROW", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_CreatePerspectiveFieldOfView_ROW$0A
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreatePerspectiveFieldOfView_ROW", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double, $.Double
        ]), 
      double4x4_CreatePerspectiveFieldOfView_ROW$0B
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreatePerspectiveOffCenter", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_CreatePerspectiveOffCenter$0C
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveOffCenter", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double
        ]), 
      double4x4_CreatePerspectiveOffCenter$0D
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveOffCenter_ROW", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_CreatePerspectiveOffCenter_ROW
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreatePerspectiveOffCenterRH", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_CreatePerspectiveOffCenterRH
    );

    $.Method({Static:true , Public:true }, "CreateRotationX", 
      new JSIL.MethodSignature(null, [$.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double4x4_CreateRotationX$0E
    );

    $.Method({Static:true , Public:true }, "CreateRotationX", 
      new JSIL.MethodSignature($.Type, [$.Double]), 
      double4x4_CreateRotationX$0F
    );

    $.Method({Static:true , Public:true }, "CreateRotationX_ROW", 
      new JSIL.MethodSignature(null, [$.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double4x4_CreateRotationX_ROW$10
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateRotationX_ROW", 
      new JSIL.MethodSignature($.Type, [$.Double]), 
      double4x4_CreateRotationX_ROW$11
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateRotationY", 
      new JSIL.MethodSignature(null, [$.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double4x4_CreateRotationY$12
    );

    $.Method({Static:true , Public:true }, "CreateRotationY", 
      new JSIL.MethodSignature($.Type, [$.Double]), 
      double4x4_CreateRotationY$13
    );

    $.Method({Static:true , Public:true }, "CreateRotationY_ROW", 
      new JSIL.MethodSignature(null, [$.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double4x4_CreateRotationY_ROW$14
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateRotationY_ROW", 
      new JSIL.MethodSignature($.Type, [$.Double]), 
      double4x4_CreateRotationY_ROW$15
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateRotationZ", 
      new JSIL.MethodSignature(null, [$.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double4x4_CreateRotationZ$16
    );

    $.Method({Static:true , Public:true }, "CreateRotationZ", 
      new JSIL.MethodSignature($.Type, [$.Double]), 
      double4x4_CreateRotationZ$17
    );

    $.Method({Static:true , Public:true }, "CreateTranslation", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_CreateTranslation$18
    );

    $.Method({Static:true , Public:true }, "CreateTranslation", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double4x4_CreateTranslation$19
    );

    $.Method({Static:true , Public:true }, "CreateTranslation", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double
        ]), 
      double4x4_CreateTranslation$1A
    );

    $.Method({Static:true , Public:true }, "CreateTranslation", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.double3")]), 
      double4x4_CreateTranslation$1B
    );

    $.Method({Static:true , Public:true }, "CreateTranslation_ROW", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_CreateTranslation_ROW$1C
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateTranslation_ROW", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double
        ]), 
      double4x4_CreateTranslation_ROW$1D
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      double4x4_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type]), 
      double4x4_Equals$1E
    );

    $.Method({Static:false, Public:true }, "get_Column0", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.double4")), 
      double4x4_get_Column0
    );

    $.Method({Static:false, Public:true }, "get_Column1", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.double4")), 
      double4x4_get_Column1
    );

    $.Method({Static:false, Public:true }, "get_Column2", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.double4")), 
      double4x4_get_Column2
    );

    $.Method({Static:false, Public:true }, "get_Column3", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.double4")), 
      double4x4_get_Column3
    );

    $.Method({Static:false, Public:true }, "get_Determinant", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_Determinant
    );

    $.Method({Static:false, Public:true }, "get_IsAffine", 
      JSIL.MethodSignature.Return($.Boolean), 
      double4x4_get_IsAffine
    );

    $.Method({Static:false, Public:true }, "get_M11", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M11
    );

    $.Method({Static:false, Public:true }, "get_M12", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M12
    );

    $.Method({Static:false, Public:true }, "get_M13", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M13
    );

    $.Method({Static:false, Public:true }, "get_M14", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M14
    );

    $.Method({Static:false, Public:true }, "get_M21", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M21
    );

    $.Method({Static:false, Public:true }, "get_M22", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M22
    );

    $.Method({Static:false, Public:true }, "get_M23", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M23
    );

    $.Method({Static:false, Public:true }, "get_M24", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M24
    );

    $.Method({Static:false, Public:true }, "get_M31", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M31
    );

    $.Method({Static:false, Public:true }, "get_M32", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M32
    );

    $.Method({Static:false, Public:true }, "get_M33", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M33
    );

    $.Method({Static:false, Public:true }, "get_M34", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M34
    );

    $.Method({Static:false, Public:true }, "get_M41", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M41
    );

    $.Method({Static:false, Public:true }, "get_M42", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M42
    );

    $.Method({Static:false, Public:true }, "get_M43", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M43
    );

    $.Method({Static:false, Public:true }, "get_M44", 
      JSIL.MethodSignature.Return($.Double), 
      double4x4_get_M44
    );

    $.Method({Static:false, Public:true }, "get_Offset", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.double3")), 
      double4x4_get_Offset
    );

    $.Method({Static:true , Public:true }, "get_Parse", 
      JSIL.MethodSignature.Return($asm07.TypeRef("System.Converter`2", [$.String, $.Type])), 
      double4x4_get_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32), 
      double4x4_GetHashCode
    );

    $.Method({Static:false, Public:true }, "Invert", 
      JSIL.MethodSignature.Void, 
      double4x4_Invert$1F
    );

    $.Method({Static:true , Public:true }, "Invert", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      double4x4_Invert$20
    );

    $.Method({Static:true , Public:true }, "InvertAffine", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      double4x4_InvertAffine
    );

    $.Method({Static:true , Public:true }, "LookAt", 
      new JSIL.MethodSignature($.Type, [
          $asm04.TypeRef("Fusee.Math.double3"), $asm04.TypeRef("Fusee.Math.double3"), 
          $asm04.TypeRef("Fusee.Math.double3")
        ]), 
      double4x4_LookAt$21
    );

    $.Method({Static:true , Public:true }, "LookAt", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double
        ]), 
      double4x4_LookAt$22
    );

    $.Method({Static:true , Public:true }, "LookAt_ROW", 
      new JSIL.MethodSignature($.Type, [
          $asm04.TypeRef("Fusee.Math.double3"), $asm04.TypeRef("Fusee.Math.double3"), 
          $asm04.TypeRef("Fusee.Math.double3")
        ]), 
      double4x4_LookAt_ROW$23
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "LookAt_ROW", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double
        ]), 
      double4x4_LookAt_ROW$24
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "LookAtRH", 
      new JSIL.MethodSignature($.Type, [
          $asm04.TypeRef("Fusee.Math.double3"), $asm04.TypeRef("Fusee.Math.double3"), 
          $asm04.TypeRef("Fusee.Math.double3")
        ]), 
      double4x4_LookAtRH
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4x4_Mult$25
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_Mult$26
    );

    $.Method({Static:true , Public:true }, "MultAffine", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      double4x4_MultAffine
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4x4_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      double4x4_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      double4x4_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4x4_op_Multiply$27
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double4"), [$.Type, $asm04.TypeRef("Fusee.Math.double4")]), 
      double4x4_op_Multiply$28
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double4"), [$asm04.TypeRef("Fusee.Math.double4"), $.Type]), 
      double4x4_op_Multiply$29
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double3"), [$.Type, $asm04.TypeRef("Fusee.Math.double3")]), 
      double4x4_op_Multiply$2A
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double3"), [$asm04.TypeRef("Fusee.Math.double3"), $.Type]), 
      double4x4_op_Multiply$2B
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4x4_op_Subtraction
    );

    $.Method({Static:true , Public:true }, "Scale", 
      new JSIL.MethodSignature($.Type, [$.Double]), 
      double4x4_Scale$2C
    );

    $.Method({Static:true , Public:true }, "Scale", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.double3")]), 
      double4x4_Scale$2D
    );

    $.Method({Static:true , Public:true }, "Scale", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double
        ]), 
      double4x4_Scale$2E
    );

    $.Method({Static:false, Public:true }, "set_M11", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M11
    );

    $.Method({Static:false, Public:true }, "set_M12", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M12
    );

    $.Method({Static:false, Public:true }, "set_M13", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M13
    );

    $.Method({Static:false, Public:true }, "set_M14", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M14
    );

    $.Method({Static:false, Public:true }, "set_M21", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M21
    );

    $.Method({Static:false, Public:true }, "set_M22", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M22
    );

    $.Method({Static:false, Public:true }, "set_M23", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M23
    );

    $.Method({Static:false, Public:true }, "set_M24", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M24
    );

    $.Method({Static:false, Public:true }, "set_M31", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M31
    );

    $.Method({Static:false, Public:true }, "set_M32", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M32
    );

    $.Method({Static:false, Public:true }, "set_M33", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M33
    );

    $.Method({Static:false, Public:true }, "set_M34", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M34
    );

    $.Method({Static:false, Public:true }, "set_M41", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M41
    );

    $.Method({Static:false, Public:true }, "set_M42", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M42
    );

    $.Method({Static:false, Public:true }, "set_M43", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M43
    );

    $.Method({Static:false, Public:true }, "set_M44", 
      JSIL.MethodSignature.Action($.Double), 
      double4x4_set_M44
    );

    $.Method({Static:true , Public:true }, "set_Parse", 
      JSIL.MethodSignature.Action($asm07.TypeRef("System.Converter`2", [$.String, $.Type])), 
      double4x4_set_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:true , Public:true }, "Substract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      double4x4_Substract
    );

    $.Method({Static:false, Public:false}, "ToArray", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Double])), 
      double4x4_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      double4x4_toString
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double4"), [$.Type, $asm04.TypeRef("Fusee.Math.double4")]), 
      double4x4_Transform
    );

    $.Method({Static:true , Public:true }, "TransformPD", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double3"), [$.Type, $asm04.TypeRef("Fusee.Math.double3")]), 
      double4x4_TransformPD
    );

    $.Method({Static:true , Public:true }, "TransformPremult", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double4"), [$asm04.TypeRef("Fusee.Math.double4"), $.Type]), 
      double4x4_TransformPremult
    );

    $.Method({Static:true , Public:true }, "TransformPremultPD", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double3"), [$asm04.TypeRef("Fusee.Math.double3"), $.Type]), 
      double4x4_TransformPremultPD
    );

    $.Method({Static:false, Public:true }, "Transpose", 
      JSIL.MethodSignature.Void, 
      double4x4_Transpose$2F
    );

    $.Method({Static:true , Public:true }, "Transpose", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      double4x4_Transpose$30
    );

    $.Method({Static:true , Public:true }, "Transpose", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      double4x4_Transpose$31
    );

    $.Field({Static:false, Public:true }, "Row0", $asm04.TypeRef("Fusee.Math.double4"))
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [1]; }); 
    $.Field({Static:false, Public:true }, "Row1", $asm04.TypeRef("Fusee.Math.double4"))
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [2]; }); 
    $.Field({Static:false, Public:true }, "Row2", $asm04.TypeRef("Fusee.Math.double4"))
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [3]; }); 
    $.Field({Static:false, Public:true }, "Row3", $asm04.TypeRef("Fusee.Math.double4"))
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [4]; }); 
    $.Field({Static:true , Public:true }, "Identity", $.Type); 
    $.Field({Static:true , Public:true }, "Zero", $.Type); 
    $.Field({Static:true , Public:false}, "double4x4$Parse$value", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]))
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    function double4x4__cctor () {
      $thisType.Identity = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.Identity = $S00().Construct($T00().UnitX.MemberwiseClone(), $T00().UnitY.MemberwiseClone(), $T00().UnitZ.MemberwiseClone(), $T00().UnitW.MemberwiseClone());
      $thisType.Zero = $S00().Construct($T00().Zero.MemberwiseClone(), $T00().Zero.MemberwiseClone(), $T00().Zero.MemberwiseClone(), $T00().Zero.MemberwiseClone());
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      double4x4__cctor
    );

    $.Property({Static:false, Public:true }, "Determinant", $.Double);

    $.Property({Static:false, Public:true }, "Column0", $asm04.TypeRef("Fusee.Math.double4"));

    $.Property({Static:false, Public:true }, "Column1", $asm04.TypeRef("Fusee.Math.double4"));

    $.Property({Static:false, Public:true }, "Column2", $asm04.TypeRef("Fusee.Math.double4"));

    $.Property({Static:false, Public:true }, "Column3", $asm04.TypeRef("Fusee.Math.double4"));

    $.Property({Static:false, Public:true }, "M11", $.Double);

    $.Property({Static:false, Public:true }, "M12", $.Double);

    $.Property({Static:false, Public:true }, "M13", $.Double);

    $.Property({Static:false, Public:true }, "M14", $.Double);

    $.Property({Static:false, Public:true }, "M21", $.Double);

    $.Property({Static:false, Public:true }, "M22", $.Double);

    $.Property({Static:false, Public:true }, "M23", $.Double);

    $.Property({Static:false, Public:true }, "M24", $.Double);

    $.Property({Static:false, Public:true }, "M31", $.Double);

    $.Property({Static:false, Public:true }, "M32", $.Double);

    $.Property({Static:false, Public:true }, "M33", $.Double);

    $.Property({Static:false, Public:true }, "M34", $.Double);

    $.Property({Static:false, Public:true }, "M41", $.Double);

    $.Property({Static:false, Public:true }, "M42", $.Double);

    $.Property({Static:false, Public:true }, "M43", $.Double);

    $.Property({Static:false, Public:true }, "M44", $.Double);

    $.Property({Static:false, Public:true }, "Offset", $asm04.TypeRef("Fusee.Math.double3"));

    $.Property({Static:false, Public:true }, "IsAffine", $.Boolean);

    $.Property({Static:true , Public:true }, "Parse", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]));

    $.ImplementInterfaces(
      /* 0 */ $asm07.TypeRef("System.IEquatable`1", [$.Type])
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm08.TypeRef("ProtoBuf.ProtoContractAttribute"));

})();

/* struct Fusee.Math.float2 */ 

(function float2$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm07.System.Single)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Math.float3)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Math.float4)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.System.Math)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm07.System.Double)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm04.Fusee.Math.MathHelper)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm07.System.Converter$b2.Of($asm07.System.String, $asm04.Fusee.Math.float2))) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm07.System.String)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm04.Fusee.Math.Quaternion)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float2"), [$asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float2"), [$asm07.TypeRef("System.Single"), $asm04.TypeRef("Fusee.Math.float2")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float2")]), $asm07.TypeRef("System.Single"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float2")])
      ]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float2")]), $asm07.TypeRef("System.Single"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float2")])
      ]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float2")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float2")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float2")])
      ]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("System.Single"), [$asm07.TypeRef("System.Single")]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float2")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float2")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float2")])
      ]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.Quaternion"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")])
      ]))) ();
  };

  function float2__ctor$00 (x, y) {
    this.x = +x;
    this.y = +y;
  };

  function float2__ctor$01 (v) {
    this.x = +v.x;
    this.y = +v.y;
  };

  function float2__ctor$02 (v) {
    this.x = +v.x;
    this.y = +v.y;
  };

  function float2__ctor$03 (v) {
    this.x = +v.x;
    this.y = +v.y;
  };

  function float2_Add$04 (right) {
    this.x += +right.x;
    this.y += +right.y;
  };

  function float2_Add$05 (/* ref */ right) {
    this.x += +right.get().x;
    this.y += +right.get().y;
  };

  function float2_Add$06 ($a, $b) {
    var b = new JSIL.BoxedVariable($b.MemberwiseClone());
    var a = new JSIL.BoxedVariable($a.MemberwiseClone());
    $thisType.Add(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  };

  function float2_Add$07 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((+a.get().x + +b.get().x), (+a.get().y + +b.get().y)));
  };

  function float2_BaryCentric$08 (a, b, c, u, v) {
    return $thisType.op_Addition(
      $thisType.op_Addition(a.MemberwiseClone(), $S01().CallStatic($thisType, "op_Multiply", null, u, $thisType.op_Subtraction(b.MemberwiseClone(), a).MemberwiseClone())).MemberwiseClone(), 
      $S01().CallStatic($thisType, "op_Multiply", null, v, $thisType.op_Subtraction(c.MemberwiseClone(), a).MemberwiseClone())
    );
  };

  function float2_BaryCentric$09 (/* ref */ a, /* ref */ b, /* ref */ c, u, v, /* ref */ result) {
    result.set(a.get().MemberwiseClone());
    var float = new JSIL.BoxedVariable(b.get().MemberwiseClone());
    $thisType.Subtract(/* ref */ float, /* ref */ a, /* ref */ float);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ float, u, /* ref */ float);
    $thisType.Add(/* ref */ result, /* ref */ float, /* ref */ result);
    float.set(c.get().MemberwiseClone());
    $thisType.Subtract(/* ref */ float, /* ref */ a, /* ref */ float);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ float, v, /* ref */ float);
    $thisType.Add(/* ref */ result, /* ref */ float, /* ref */ result);
  };

  function float2_Clamp$0A (vec, min, max) {
    vec.x = +(
      (+vec.x < +min.x)
         ? min.x
         : (
          (+vec.x > +max.x)
             ? max.x
             : vec.x)
    )
    ;
    vec.y = +(
      (+vec.y < +min.y)
         ? min.y
         : (
          (+vec.y > +max.y)
             ? max.y
             : vec.y)
    )
    ;
    return vec;
  };

  function float2_Clamp$0B (/* ref */ vec, /* ref */ min, /* ref */ max, /* ref */ result) {
    result.get().x = +(
      (+vec.get().x < +min.get().x)
         ? min.get().x
         : (
          (+vec.get().x > +max.get().x)
             ? max.get().x
             : vec.get().x)
    )
    ;
    result.get().y = +(
      (+vec.get().y < +min.get().y)
         ? min.get().y
         : (
          (+vec.get().y > +max.get().y)
             ? max.get().y
             : vec.get().y)
    )
    ;
  };

  function float2_ComponentMax$0C (a, b) {
    a.x = +(
      (+a.x > +b.x)
         ? a.x
         : b.x)
    ;
    a.y = +(
      (+a.y > +b.y)
         ? a.y
         : b.y)
    ;
    return a;
  };

  function float2_ComponentMax$0D (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(
      (+a.get().x > +b.get().x)
         ? a.get().x
         : b.get().x)
    ;
    result.get().y = +(
      (+a.get().y > +b.get().y)
         ? a.get().y
         : b.get().y)
    ;
  };

  function float2_ComponentMin$0E (a, b) {
    a.x = +(
      (+a.x < +b.x)
         ? a.x
         : b.x)
    ;
    a.y = +(
      (+a.y < +b.y)
         ? a.y
         : b.y)
    ;
    return a;
  };

  function float2_ComponentMin$0F (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(
      (+a.get().x < +b.get().x)
         ? a.get().x
         : b.get().x)
    ;
    result.get().y = +(
      (+a.get().y < +b.get().y)
         ? a.get().y
         : b.get().y)
    ;
  };

  function float2_Div$10 (f) {
    var num = +((1 / +f));
    this.x *= num;
    this.y *= num;
  };

  function float2_Div$11 (a, f) {
    var num = +((1 / +f));
    a.x *= num;
    a.y *= num;
    return a;
  };

  function float2_Div$12 (/* ref */ a, f, /* ref */ result) {
    var num = +((1 / +f));
    result.get().x = +a.get().x * num;
    result.get().y = +a.get().y * num;
  };

  function float2_Divide$13 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S03().CallStatic($thisType, "Divide", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  };

  function float2_Divide$14 (/* ref */ vector, scale, /* ref */ result) {
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vector, +((1 / +scale)), /* ref */ result);
  };

  function float2_Divide$15 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale.MemberwiseClone());
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S04().CallStatic($thisType, "Divide", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  };

  function float2_Divide$16 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct(+((+vector.get().x / +scale.get().x)), +((+vector.get().y / +scale.get().y))));
  };

  function float2_Dot$17 (left, right) {
    return ((+left.x * +right.x) + (+left.y * +right.y));
  };

  function float2_Dot$18 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set((+left.get().x * +right.get().x) + (+left.get().y * +right.get().y));
  };

  function float2_Object_Equals (obj) {
    return ($thisType.$Is(obj) && this.Equals($thisType.$Cast(obj)));
  };

  function float2_Equals$19 (other) {
    return ((+this.x === +other.x) && (+this.y === +other.y));
  };

  function float2_get_g () {
    return this.y;
  };

  function float2_get_Length () {
    return Math.fround(Math.sqrt(((+this.x * +this.x) + (+this.y * +this.y))));
  };

  function float2_get_LengthFast () {
    return +((1 / +$S05().CallStatic($T06(), "InverseSqrtFast", null, (+this.x * +this.x) + (+this.y * +this.y))));
  };

  function float2_get_LengthSquared () {
    return ((+this.x * +this.x) + (+this.y * +this.y));
  };

  function float2_get_Parse () {
    return $thisType.float2$Parse$value;
  };

  function float2_get_PerpendicularLeft () {
    return $S00().Construct(-this.y, this.x);
  };

  function float2_get_PerpendicularRight () {
    return $S00().Construct(this.y, -this.x);
  };

  function float2_get_r () {
    return this.x;
  };

  function float2_get_rg () {
    return this.get_xy();
  };

  function float2_get_xy () {
    return $S00().Construct(this.x, this.y);
  };

  function float2_GetHashCode () {
    return (((this.x).GetHashCode() | 0) ^ ((this.y).GetHashCode() | 0));
  };

  function float2_Lerp$1A (a, b, blend) {
    a.x = (+blend * (+b.x - +a.x)) + +a.x;
    a.y = (+blend * (+b.y - +a.y)) + +a.y;
    return a;
  };

  function float2_Lerp$1B (/* ref */ a, /* ref */ b, blend, /* ref */ result) {
    result.get().x = (+blend * (+b.get().x - +a.get().x)) + +a.get().x;
    result.get().y = (+blend * (+b.get().y - +a.get().y)) + +a.get().y;
  };

  function float2_Max (left, right) {
    return (
      (+left.get_LengthSquared() >= +right.get_LengthSquared())
         ? left
         : right)
    ;
  };

  function float2_Min (left, right) {
    return (
      (+left.get_LengthSquared() < +right.get_LengthSquared())
         ? left
         : right)
    ;
  };

  function float2_Mult$1C (f) {
    this.x *= +f;
    this.y *= +f;
  };

  function float2_Mult$1D (a, f) {
    a.x *= +f;
    a.y *= +f;
    return a;
  };

  function float2_Mult$1E (/* ref */ a, f, /* ref */ result) {
    result.get().x = +a.get().x * +f;
    result.get().y = +a.get().y * +f;
  };

  function float2_Multiply$1F ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  };

  function float2_Multiply$20 (/* ref */ vector, scale, /* ref */ result) {
    result.set($S00().Construct((+vector.get().x * +scale), (+vector.get().y * +scale)));
  };

  function float2_Multiply$21 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale.MemberwiseClone());
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S06().CallStatic($thisType, "Multiply", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  };

  function float2_Multiply$22 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct((+vector.get().x * +scale.get().x), (+vector.get().y * +scale.get().y)));
  };

  function float2_Normalize$23 () {
    var num = +((1 / +this.get_Length()));
    this.x *= num;
    this.y *= num;
  };

  function float2_Normalize$24 (vec) {
    var num = +((1 / +vec.get_Length()));
    vec.x *= num;
    vec.y *= num;
    return vec;
  };

  function float2_Normalize$25 (/* ref */ vec, /* ref */ result) {
    var num = +((1 / +(vec.get()).get_Length()));
    result.get().x = +vec.get().x * num;
    result.get().y = +vec.get().y * num;
  };

  function float2_NormalizeFast$26 () {
    var num = +$S05().CallStatic($T06(), "InverseSqrtFast", null, (+this.x * +this.x) + (+this.y * +this.y));
    this.x *= num;
    this.y *= num;
  };

  function float2_NormalizeFast$27 (vec) {
    var num = +$S05().CallStatic($T06(), "InverseSqrtFast", null, (+vec.x * +vec.x) + (+vec.y * +vec.y));
    vec.x *= num;
    vec.y *= num;
    return vec;
  };

  function float2_NormalizeFast$28 (/* ref */ vec, /* ref */ result) {
    var num = +$S05().CallStatic($T06(), "InverseSqrtFast", null, (+vec.get().x * +vec.get().x) + (+vec.get().y * +vec.get().y));
    result.get().x = +vec.get().x * num;
    result.get().y = +vec.get().y * num;
  };

  function float2_op_Addition (left, right) {
    left.x += +right.x;
    left.y += +right.y;
    return left;
  };

  function float2_op_Division (vec, scale) {
    var num = +((1 / +scale));
    vec.x *= num;
    vec.y *= num;
    return vec;
  };

  function float2_op_Equality (left, right) {
    return left.Equals(right);
  };

  function float2_op_Inequality (left, right) {
    return !left.Equals(right);
  };

  function float2_op_Multiply$29 (vec, scale) {
    vec.x *= +scale;
    vec.y *= +scale;
    return vec;
  };

  function float2_op_Multiply$2A (scale, vec) {
    vec.x *= +scale;
    vec.y *= +scale;
    return vec;
  };

  function float2_op_Multiply$2B (vec1, vec2) {
    vec1.x *= +vec2.x;
    vec1.y *= +vec2.y;
    return vec1;
  };

  function float2_op_Subtraction (left, right) {
    left.x -= +right.x;
    left.y -= +right.y;
    return left;
  };

  function float2_op_UnaryNegation (vec) {
    vec.x = -vec.x;
    vec.y = -vec.y;
    return vec;
  };

  function float2_Scale$2C (sx, sy) {
    this.x *= +sx;
    this.y *= +sy;
  };

  function float2_Scale$2D (scale) {
    this.x *= +scale.x;
    this.y *= +scale.y;
  };

  function float2_Scale$2E (/* ref */ scale) {
    this.x *= +scale.get().x;
    this.y *= +scale.get().y;
  };

  function float2_set_g (value) {
    this.y = +value;
  };

  function float2_set_Parse (value) {
    $thisType.float2$Parse$value = value;
  };

  function float2_set_r (value) {
    this.x = +value;
  };

  function float2_set_rg (value) {
    (this.xy = value.MemberwiseClone());
  };

  function float2_set_xy (value) {
    this.x = +value.x;
    this.y = +value.y;
  };

  function float2_Sub$2F (right) {
    this.x -= +right.x;
    this.y -= +right.y;
  };

  function float2_Sub$30 (/* ref */ right) {
    this.x -= +right.get().x;
    this.y -= +right.get().y;
  };

  function float2_Sub$31 (a, b) {
    a.x -= +b.x;
    a.y -= +b.y;
    return a;
  };

  function float2_Sub$32 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +a.get().x - +b.get().x;
    result.get().y = +a.get().y - +b.get().y;
  };

  function float2_Subtract$33 ($a, $b) {
    var b = new JSIL.BoxedVariable($b.MemberwiseClone());
    var a = new JSIL.BoxedVariable($a.MemberwiseClone());
    $thisType.Subtract(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  };

  function float2_Subtract$34 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((+a.get().x - +b.get().x), (+a.get().y - +b.get().y)));
  };

  function float2_ToArray () {
    return JSIL.Array.New($T00(), [this.x, this.y]);
  };

  function float2_toString () {
    return $T08().Format("({0}, {1})", this.x, this.y);
  };

  function float2_Transform$35 ($vec, $quat) {
    var quat = new JSIL.BoxedVariable($quat.MemberwiseClone());
    var vec = new JSIL.BoxedVariable($vec.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.Transform(/* ref */ vec, /* ref */ quat, /* ref */ result);
    return result.get();
  };

  function float2_Transform$36 (/* ref */ vec, /* ref */ quat, /* ref */ result) {
    var quaternion2 = new JSIL.BoxedVariable(new ($T09())());
    var quaternion3 = new JSIL.BoxedVariable(new ($T09())());
    var quaternion = new JSIL.BoxedVariable($S07().Construct(vec.get().x, vec.get().y, 0, 0));
    $T09().Invert(/* ref */ quat, /* ref */ quaternion2);
    $S08().CallStatic($T09(), "Multiply", null, /* ref */ quat, /* ref */ quaternion, /* ref */ quaternion3);
    $S08().CallStatic($T09(), "Multiply", null, /* ref */ quaternion3, /* ref */ quaternion2, /* ref */ quaternion);
    result.set($S00().Construct((quaternion.get()).get_x(), (quaternion.get()).get_y()));
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.float2", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.Single, $.Single]), 
      float2__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Type), 
      float2__ctor$01
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"));

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.float3")), 
      float2__ctor$02
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"));

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.float4")), 
      float2__ctor$03
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"));

    $.Method({Static:false, Public:true }, "Add", 
      JSIL.MethodSignature.Action($.Type), 
      float2_Add$04
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:false, Public:true }, "Add", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      float2_Add$05
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float2_Add$06
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_Add$07
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type, $.Single, 
          $.Single
        ]), 
      float2_BaryCentric$08
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_BaryCentric$09
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type
        ]), 
      float2_Clamp$0A
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_Clamp$0B
    );

    $.Method({Static:true , Public:true }, "ComponentMax", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float2_ComponentMax$0C
    );

    $.Method({Static:true , Public:true }, "ComponentMax", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_ComponentMax$0D
    );

    $.Method({Static:true , Public:true }, "ComponentMin", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float2_ComponentMin$0E
    );

    $.Method({Static:true , Public:true }, "ComponentMin", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_ComponentMin$0F
    );

    $.Method({Static:false, Public:true }, "Div", 
      JSIL.MethodSignature.Action($.Single), 
      float2_Div$10
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float2_Div$11
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_Div$12
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float2_Divide$13
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_Divide$14
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float2_Divide$15
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_Divide$16
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature($.Single, [$.Type, $.Type]), 
      float2_Dot$17
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Single])
        ]), 
      float2_Dot$18
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      float2_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type]), 
      float2_Equals$19
    );

    $.Method({Static:false, Public:true }, "get_g", 
      JSIL.MethodSignature.Return($.Single), 
      float2_get_g
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      JSIL.MethodSignature.Return($.Single), 
      float2_get_Length
    );

    $.Method({Static:false, Public:true }, "get_LengthFast", 
      JSIL.MethodSignature.Return($.Single), 
      float2_get_LengthFast
    );

    $.Method({Static:false, Public:true }, "get_LengthSquared", 
      JSIL.MethodSignature.Return($.Single), 
      float2_get_LengthSquared
    );

    $.Method({Static:true , Public:true }, "get_Parse", 
      JSIL.MethodSignature.Return($asm07.TypeRef("System.Converter`2", [$.String, $.Type])), 
      float2_get_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_PerpendicularLeft", 
      JSIL.MethodSignature.Return($.Type), 
      float2_get_PerpendicularLeft
    );

    $.Method({Static:false, Public:true }, "get_PerpendicularRight", 
      JSIL.MethodSignature.Return($.Type), 
      float2_get_PerpendicularRight
    );

    $.Method({Static:false, Public:true }, "get_r", 
      JSIL.MethodSignature.Return($.Single), 
      float2_get_r
    );

    $.Method({Static:false, Public:true }, "get_rg", 
      JSIL.MethodSignature.Return($.Type), 
      float2_get_rg
    );

    $.Method({Static:false, Public:true }, "get_xy", 
      JSIL.MethodSignature.Return($.Type), 
      float2_get_xy
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32), 
      float2_GetHashCode
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Single
        ]), 
      float2_Lerp$1A
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_Lerp$1B
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float2_Max
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float2_Min
    );

    $.Method({Static:false, Public:true }, "Mult", 
      JSIL.MethodSignature.Action($.Single), 
      float2_Mult$1C
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float2_Mult$1D
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_Mult$1E
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float2_Multiply$1F
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_Multiply$20
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float2_Multiply$21
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_Multiply$22
    );

    $.Method({Static:false, Public:true }, "Normalize", 
      JSIL.MethodSignature.Void, 
      float2_Normalize$23
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float2_Normalize$24
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float2_Normalize$25
    );

    $.Method({Static:false, Public:true }, "NormalizeFast", 
      JSIL.MethodSignature.Void, 
      float2_NormalizeFast$26
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float2_NormalizeFast$27
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float2_NormalizeFast$28
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float2_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Division", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float2_op_Division
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      float2_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      float2_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float2_op_Multiply$29
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Single, $.Type]), 
      float2_op_Multiply$2A
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float2_op_Multiply$2B
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float2_op_Subtraction
    );

    $.Method({Static:true , Public:true }, "op_UnaryNegation", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float2_op_UnaryNegation
    );

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [$.Single, $.Single]), 
      float2_Scale$2C
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      JSIL.MethodSignature.Action($.Type), 
      float2_Scale$2D
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      float2_Scale$2E
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "set_g", 
      JSIL.MethodSignature.Action($.Single), 
      float2_set_g
    );

    $.Method({Static:true , Public:true }, "set_Parse", 
      JSIL.MethodSignature.Action($asm07.TypeRef("System.Converter`2", [$.String, $.Type])), 
      float2_set_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "set_r", 
      JSIL.MethodSignature.Action($.Single), 
      float2_set_r
    );

    $.Method({Static:false, Public:true }, "set_rg", 
      JSIL.MethodSignature.Action($.Type), 
      float2_set_rg
    );

    $.Method({Static:false, Public:true }, "set_xy", 
      JSIL.MethodSignature.Action($.Type), 
      float2_set_xy
    );

    $.Method({Static:false, Public:true }, "Sub", 
      JSIL.MethodSignature.Action($.Type), 
      float2_Sub$2F
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:false, Public:true }, "Sub", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      float2_Sub$30
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float2_Sub$31
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_Sub$32
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float2_Subtract$33
    );

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_Subtract$34
    );

    $.Method({Static:false, Public:true }, "ToArray", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Single])), 
      float2_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      float2_toString
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.Quaternion")]), 
      float2_Transform$35
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float2_Transform$36
    );

    $.Field({Static:false, Public:true }, "x", $.Single)
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [1]; }); 
    $.Field({Static:false, Public:true }, "y", $.Single)
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [2]; }); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitX", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitY", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "Zero", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "One", $.Type); 
    $.Field({Static:true , Public:false}, "float2$Parse$value", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]))
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    function float2__cctor () {
      $thisType.UnitX = new $thisType();
      $thisType.UnitY = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.One = new $thisType();
      $thisType.UnitX = $S00().Construct(1, 0);
      $thisType.UnitY = $S00().Construct(0, 1);
      $thisType.Zero = $S00().Construct(0, 0);
      $thisType.One = $S00().Construct(1, 1);
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      float2__cctor
    );

    $.Property({Static:false, Public:true }, "Length", $.Single);

    $.Property({Static:false, Public:true }, "LengthFast", $.Single);

    $.Property({Static:false, Public:true }, "LengthSquared", $.Single);

    $.Property({Static:false, Public:true }, "PerpendicularRight", $.Type);

    $.Property({Static:false, Public:true }, "PerpendicularLeft", $.Type);

    $.Property({Static:false, Public:true }, "xy", $.Type);

    $.Property({Static:false, Public:true }, "r", $.Single);

    $.Property({Static:false, Public:true }, "g", $.Single);

    $.Property({Static:false, Public:true }, "rg", $.Type);

    $.Property({Static:true , Public:true }, "Parse", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]));

    $.ImplementInterfaces(
      /* 0 */ $asm07.TypeRef("System.IEquatable`1", [$.Type])
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm08.TypeRef("ProtoBuf.ProtoContractAttribute"));

})();

/* struct Fusee.Math.float3 */ 

(function float3$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm07.System.Single)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Math.float2)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Math.float4)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm04.Fusee.Math.double3)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.System.Math)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm07.System.Double)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm07.System.Object)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm04.Fusee.Math.MathHelper)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize(System.Array.Of($asm04.Fusee.Math.float3))) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm07.System.Converter$b2.Of($asm07.System.String, $asm04.Fusee.Math.float3))) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm07.System.String)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm04.Fusee.Math.float4x4)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm04.Fusee.Math.Quaternion)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float3"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$asm07.TypeRef("System.Single"), $asm04.TypeRef("Fusee.Math.float3")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")]), $asm07.TypeRef("System.Single"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")])
      ]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")]), $asm07.TypeRef("System.Single"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")])
      ]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")])
      ]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("System.Single"), [$asm07.TypeRef("System.Single")]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float2"), [$asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single")]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")])
      ]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float3"), [$asm04.TypeRef("Fusee.Math.double3")]))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$asm04.TypeRef("Fusee.Math.float3"), $asm07.TypeRef("System.Single")]))) ();
  };
  var $S0A = function () {
    return ($S0A = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4x4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")])
      ]))) ();
  };
  var $S0B = function () {
    return ($S0B = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float4"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S0C = function () {
    return ($S0C = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4x4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")])
      ]))) ();
  };
  var $S0D = function () {
    return ($S0D = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")])
      ]))) ();
  };
  var $S0E = function () {
    return ($S0E = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float3"), [$asm04.TypeRef("Fusee.Math.float4")]))) ();
  };
  var $S0F = function () {
    return ($S0F = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float4"), [$asm04.TypeRef("Fusee.Math.float3")]))) ();
  };

  function float3__ctor$00 (x, y, z) {
    this.x = +x;
    this.y = +y;
    this.z = +z;
  };

  function float3__ctor$01 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = 0;
  };

  function float3__ctor$02 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
  };

  function float3__ctor$03 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
  };

  function float3__ctor$04 (d3) {
    this.x = Math.fround(d3.x);
    this.y = Math.fround(d3.y);
    this.z = Math.fround(d3.z);
  };

  function float3_Add$05 (right) {
    this.x += +right.x;
    this.y += +right.y;
    this.z += +right.z;
  };

  function float3_Add$06 (/* ref */ right) {
    this.x += +right.get().x;
    this.y += +right.get().y;
    this.z += +right.get().z;
  };

  function float3_Add$07 ($a, $b) {
    var b = new JSIL.BoxedVariable($b.MemberwiseClone());
    var a = new JSIL.BoxedVariable($a.MemberwiseClone());
    $thisType.Add(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  };

  function float3_Add$08 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((+a.get().x + +b.get().x), (+a.get().y + +b.get().y), (+a.get().z + +b.get().z)));
  };

  function float3_BaryCentric$09 (a, b, c, u, v) {
    return $thisType.op_Addition(
      $thisType.op_Addition(a.MemberwiseClone(), $S01().CallStatic($thisType, "op_Multiply", null, u, $thisType.op_Subtraction(b.MemberwiseClone(), a).MemberwiseClone())).MemberwiseClone(), 
      $S01().CallStatic($thisType, "op_Multiply", null, v, $thisType.op_Subtraction(c.MemberwiseClone(), a).MemberwiseClone())
    );
  };

  function float3_BaryCentric$0A (/* ref */ a, /* ref */ b, /* ref */ c, u, v, /* ref */ result) {
    result.set(a.get().MemberwiseClone());
    var float = new JSIL.BoxedVariable(b.get().MemberwiseClone());
    $thisType.Subtract(/* ref */ float, /* ref */ a, /* ref */ float);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ float, u, /* ref */ float);
    $thisType.Add(/* ref */ result, /* ref */ float, /* ref */ result);
    float.set(c.get().MemberwiseClone());
    $thisType.Subtract(/* ref */ float, /* ref */ a, /* ref */ float);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ float, v, /* ref */ float);
    $thisType.Add(/* ref */ result, /* ref */ float, /* ref */ result);
  };

  function float3_CalculateAngle$0B (first, second) {
    if (!((+first.get_Length() <= 1.192093E-07) || (+second.get_Length() <= 1.192093E-07))) {
      var result = Math.fround(Math.acos(+((+$thisType.Dot(first, second) / (+first.get_Length() * +second.get_Length())))));
    } else {
      result = 0;
    }
    return result;
  };

  function float3_CalculateAngle$0C (/* ref */ first, /* ref */ second, /* ref */ result) {
    var num = new JSIL.BoxedVariable(0);
    $thisType.Dot(/* ref */ first, /* ref */ second, /* ref */ num);
    if (!((+(first.get()).get_Length() <= 1.192093E-07) || (+(second.get()).get_Length() <= 1.192093E-07))) {
      result.set(Math.fround(Math.acos(+((+num.get() / (+(first.get()).get_Length() * +(second.get()).get_Length()))))));
    } else {
      result.set(0);
    }
  };

  function float3_Clamp$0D (vec, min, max) {
    vec.x = +(
      (+vec.x < +min.x)
         ? min.x
         : (
          (+vec.x > +max.x)
             ? max.x
             : vec.x)
    )
    ;
    vec.y = +(
      (+vec.y < +min.y)
         ? min.y
         : (
          (+vec.y > +max.y)
             ? max.y
             : vec.y)
    )
    ;
    vec.z = +(
      (+vec.z < +min.z)
         ? min.z
         : (
          (+vec.z > +max.z)
             ? max.z
             : vec.z)
    )
    ;
    return vec;
  };

  function float3_Clamp$0E (/* ref */ vec, /* ref */ min, /* ref */ max, /* ref */ result) {
    result.get().x = +(
      (+vec.get().x < +min.get().x)
         ? min.get().x
         : (
          (+vec.get().x > +max.get().x)
             ? max.get().x
             : vec.get().x)
    )
    ;
    result.get().y = +(
      (+vec.get().y < +min.get().y)
         ? min.get().y
         : (
          (+vec.get().y > +max.get().y)
             ? max.get().y
             : vec.get().y)
    )
    ;
    result.get().z = +(
      (+vec.get().z < +min.get().z)
         ? min.get().z
         : (
          (+vec.get().z > +max.get().z)
             ? max.get().z
             : vec.get().z)
    )
    ;
  };

  function float3_ComponentMax$0F (a, b) {
    a.x = +(
      (+a.x > +b.x)
         ? a.x
         : b.x)
    ;
    a.y = +(
      (+a.y > +b.y)
         ? a.y
         : b.y)
    ;
    a.z = +(
      (+a.z > +b.z)
         ? a.z
         : b.z)
    ;
    return a;
  };

  function float3_ComponentMax$10 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(
      (+a.get().x > +b.get().x)
         ? a.get().x
         : b.get().x)
    ;
    result.get().y = +(
      (+a.get().y > +b.get().y)
         ? a.get().y
         : b.get().y)
    ;
    result.get().z = +(
      (+a.get().z > +b.get().z)
         ? a.get().z
         : b.get().z)
    ;
  };

  function float3_ComponentMin$11 (a, b) {
    a.x = +(
      (+a.x < +b.x)
         ? a.x
         : b.x)
    ;
    a.y = +(
      (+a.y < +b.y)
         ? a.y
         : b.y)
    ;
    a.z = +(
      (+a.z < +b.z)
         ? a.z
         : b.z)
    ;
    return a;
  };

  function float3_ComponentMin$12 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(
      (+a.get().x < +b.get().x)
         ? a.get().x
         : b.get().x)
    ;
    result.get().y = +(
      (+a.get().y < +b.get().y)
         ? a.get().y
         : b.get().y)
    ;
    result.get().z = +(
      (+a.get().z < +b.get().z)
         ? a.get().z
         : b.get().z)
    ;
  };

  function float3_Cross$13 ($left, $right) {
    var right = new JSIL.BoxedVariable($right);
    var left = new JSIL.BoxedVariable($left);
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.Cross(/* ref */ left, /* ref */ right, /* ref */ result);
    return result.get();
  };

  function float3_Cross$14 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S00().Construct(((+left.get().y * +right.get().z) - (+left.get().z * +right.get().y)), ((+left.get().z * +right.get().x) - (+left.get().x * +right.get().z)), ((+left.get().x * +right.get().y) - (+left.get().y * +right.get().x))));
  };

  function float3_Div$15 (f) {
    if (+f > 1.192093E-07) {
      var num = +((1 / +f));
      this.x *= num;
      this.y *= num;
      this.z *= num;
    }
  };

  function float3_Div$16 (a, f) {
    if (+f <= 1.192093E-07) {
      var result = $thisType.Zero.MemberwiseClone();
    } else {
      var num = +((1 / +f));
      a.x *= num;
      a.y *= num;
      a.z *= num;
      result = a.MemberwiseClone();
    }
    return result;
  };

  function float3_Div$17 (/* ref */ a, f, /* ref */ result) {
    if (+f <= 1.192093E-07) {
      var num = +((1 / +f));
      result.get().x = +a.get().x * num;
      result.get().y = +a.get().y * num;
      result.get().z = +a.get().z * num;
    } else {
      result.set($thisType.Zero.MemberwiseClone());
    }
  };

  function float3_Divide$18 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S03().CallStatic($thisType, "Divide", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  };

  function float3_Divide$19 (/* ref */ vector, scale, /* ref */ result) {
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vector, +((1 / +scale)), /* ref */ result);
  };

  function float3_Divide$1A ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale.MemberwiseClone());
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S04().CallStatic($thisType, "Divide", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  };

  function float3_Divide$1B (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct(+((+vector.get().x / +scale.get().x)), +((+vector.get().y / +scale.get().y)), +((+vector.get().z / +scale.get().z))));
  };

  function float3_Dot$1C (left, right) {
    return (((+left.x * +right.x) + (+left.y * +right.y)) + (+left.z * +right.z));
  };

  function float3_Dot$1D (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set(((+left.get().x * +right.get().x) + (+left.get().y * +right.get().y)) + (+left.get().z * +right.get().z));
  };

  function float3_Object_Equals (obj) {
    return ($thisType.$Is(obj) && this.Equals($thisType.$Cast(obj).MemberwiseClone()));
  };

  function float3_Equals$1E (other) {
    return (!(((Math.abs((+this.x - +other.x))) >= 1.192093E-07) || 
        ((Math.abs((+this.y - +other.y))) >= 1.192093E-07)) && ((Math.abs((+this.z - +other.z))) < 1.192093E-07));
  };

  function float3_get_b () {
    return this.z;
  };

  function float3_get_g () {
    return this.y;
  };

  function float3_get_Length () {
    return Math.fround(Math.sqrt((((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z))));
  };

  function float3_get_LengthFast () {
    return +((1 / +$S05().CallStatic($T07(), "InverseSqrtFast", null, ((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z))));
  };

  function float3_get_LengthSquared () {
    return (((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z));
  };

  function float3_get_Parse () {
    return $thisType.float3$Parse$value;
  };

  function float3_get_r () {
    return this.x;
  };

  function float3_get_xy () {
    return $S06().Construct(this.x, this.y);
  };

  function float3_get_xyz () {
    return $S00().Construct(this.x, this.y, this.z);
  };

  function float3_GetHashCode () {
    return ((((this.x).GetHashCode() | 0) ^ ((this.y).GetHashCode() | 0)) ^ ((this.z).GetHashCode() | 0));
  };

  function float3_Lerp$1F (a, b, blend) {
    a.x = (+blend * (+b.x - +a.x)) + +a.x;
    a.y = (+blend * (+b.y - +a.y)) + +a.y;
    a.z = (+blend * (+b.z - +a.z)) + +a.z;
    return a;
  };

  function float3_Lerp$20 (/* ref */ a, /* ref */ b, blend, /* ref */ result) {
    result.get().x = (+blend * (+b.get().x - +a.get().x)) + +a.get().x;
    result.get().y = (+blend * (+b.get().y - +a.get().y)) + +a.get().y;
    result.get().z = (+blend * (+b.get().z - +a.get().z)) + +a.get().z;
  };

  function float3_Max (left, right) {
    return (
      (+left.get_LengthSquared() >= +right.get_LengthSquared())
         ? left
         : right)
    ;
  };

  function float3_Min (left, right) {
    return (
      (+left.get_LengthSquared() < +right.get_LengthSquared())
         ? left
         : right)
    ;
  };

  function float3_Mult$21 (f) {
    this.x *= +f;
    this.y *= +f;
    this.z *= +f;
  };

  function float3_Mult$22 (a, f) {
    a.x *= +f;
    a.y *= +f;
    a.z *= +f;
    return a;
  };

  function float3_Mult$23 (/* ref */ a, f, /* ref */ result) {
    result.get().x = +a.get().x * +f;
    result.get().y = +a.get().y * +f;
    result.get().z = +a.get().z * +f;
  };

  function float3_Multiply$24 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  };

  function float3_Multiply$25 (/* ref */ vector, scale, /* ref */ result) {
    result.set($S00().Construct((+vector.get().x * +scale), (+vector.get().y * +scale), (+vector.get().z * +scale)));
  };

  function float3_Multiply$26 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale.MemberwiseClone());
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S07().CallStatic($thisType, "Multiply", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  };

  function float3_Multiply$27 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct((+vector.get().x * +scale.get().x), (+vector.get().y * +scale.get().y), (+vector.get().z * +scale.get().z)));
  };

  function float3_Normalize$28 () {
    if (+this.get_Length() > 1.192093E-07) {
      var num = +((1 / +this.get_Length()));
      this.x *= num;
      this.y *= num;
      this.z *= num;
    }
  };

  function float3_Normalize$29 (vec) {
    if (+vec.get_Length() > 1.192093E-07) {
      var num = +((1 / +vec.get_Length()));
      vec.x *= num;
      vec.y *= num;
      vec.z *= num;
    }
    return vec;
  };

  function float3_Normalize$2A (/* ref */ vec, /* ref */ result) {
    if (+(vec.get()).get_Length() > 1.192093E-07) {
      var num = +((1 / +(vec.get()).get_Length()));
      result.get().x = +vec.get().x * num;
      result.get().y = +vec.get().y * num;
      result.get().z = +vec.get().z * num;
    } else {
      result.set(vec.get().MemberwiseClone());
    }
  };

  function float3_NormalizeFast$2B () {
    var num = +$S05().CallStatic($T07(), "InverseSqrtFast", null, ((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z));
    this.x *= num;
    this.y *= num;
    this.z *= num;
  };

  function float3_NormalizeFast$2C (vec) {
    var num = +$S05().CallStatic($T07(), "InverseSqrtFast", null, ((+vec.x * +vec.x) + (+vec.y * +vec.y)) + (+vec.z * +vec.z));
    vec.x *= num;
    vec.y *= num;
    vec.z *= num;
    return vec;
  };

  function float3_NormalizeFast$2D (/* ref */ vec, /* ref */ result) {
    var num = +$S05().CallStatic($T07(), "InverseSqrtFast", null, ((+vec.get().x * +vec.get().x) + (+vec.get().y * +vec.get().y)) + (+vec.get().z * +vec.get().z));
    result.get().x = +vec.get().x * num;
    result.get().y = +vec.get().y * num;
    result.get().z = +vec.get().z * num;
  };

  function float3_op_Addition (left, right) {
    left.x += +right.x;
    left.y += +right.y;
    left.z += +right.z;
    return left;
  };

  function float3_op_Division (vec, scale) {
    if (!((-1.192093E-07 >= +scale) || (+scale >= 1.192093E-07))) {
      var result = $thisType.Zero.MemberwiseClone();
    } else {
      var num = +((1 / +scale));
      vec.x *= num;
      vec.y *= num;
      vec.z *= num;
      result = vec.MemberwiseClone();
    }
    return result;
  };

  function float3_op_Equality (left, right) {
    return left.Equals(right.MemberwiseClone());
  };

  function float3_op_Explicit (d3) {
    return $S08().Construct(d3);
  };

  function float3_op_Inequality (left, right) {
    return !left.Equals(right.MemberwiseClone());
  };

  function float3_op_Multiply$2E (vec, scale) {
    vec.x *= +scale;
    vec.y *= +scale;
    vec.z *= +scale;
    return vec;
  };

  function float3_op_Multiply$2F (scale, vec) {
    vec.x *= +scale;
    vec.y *= +scale;
    vec.z *= +scale;
    return vec;
  };

  function float3_op_Multiply$30 (vec1, vec2) {
    vec1.x *= +vec2.x;
    vec1.y *= +vec2.y;
    vec1.z *= +vec2.z;
    return vec1;
  };

  function float3_op_Subtraction (left, right) {
    left.x -= +right.x;
    left.y -= +right.y;
    left.z -= +right.z;
    return left;
  };

  function float3_op_UnaryNegation (vec) {
    vec.x = -vec.x;
    vec.y = -vec.y;
    vec.z = -vec.z;
    return vec;
  };

  function float3_OrthoNormalize (normal, tangent) {
    var array = JSIL.Array.New($thisType, 2);
    normal = $thisType.Normalize(normal.MemberwiseClone());
    var right = $S09().CallStatic($thisType, "op_Multiply", null, normal.MemberwiseClone(), $thisType.Dot(tangent, normal));
    tangent = $thisType.op_Subtraction(tangent.MemberwiseClone(), right);
    tangent = $thisType.Normalize(tangent.MemberwiseClone());
    array[0] = normal.MemberwiseClone();
    array[1] = tangent.MemberwiseClone();
    return array;
  };

  function float3_Scale$31 (sx, sy, sz) {
    this.x *= +sx;
    this.y *= +sy;
    this.z *= +sz;
  };

  function float3_Scale$32 (scale) {
    this.x *= +scale.x;
    this.y *= +scale.y;
    this.z *= +scale.z;
  };

  function float3_Scale$33 (/* ref */ scale) {
    this.x *= +scale.get().x;
    this.y *= +scale.get().y;
    this.z *= +scale.get().z;
  };

  function float3_set_b (value) {
    this.z = +value;
  };

  function float3_set_g (value) {
    this.y = +value;
  };

  function float3_set_Parse (value) {
    $thisType.float3$Parse$value = value;
  };

  function float3_set_r (value) {
    this.x = +value;
  };

  function float3_set_xy (value) {
    this.x = +value.x;
    this.y = +value.y;
  };

  function float3_set_xyz (value) {
    this.x = +value.x;
    this.y = +value.y;
    this.z = +value.z;
  };

  function float3_Sub$34 (right) {
    this.x -= +right.x;
    this.y -= +right.y;
    this.z -= +right.z;
  };

  function float3_Sub$35 (/* ref */ right) {
    this.x -= +right.get().x;
    this.y -= +right.get().y;
    this.z -= +right.get().z;
  };

  function float3_Sub$36 (a, b) {
    a.x -= +b.x;
    a.y -= +b.y;
    a.z -= +b.z;
    return a;
  };

  function float3_Sub$37 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +a.get().x - +b.get().x;
    result.get().y = +a.get().y - +b.get().y;
    result.get().z = +a.get().z - +b.get().z;
  };

  function float3_Subtract$38 ($a, $b) {
    var b = new JSIL.BoxedVariable($b.MemberwiseClone());
    var a = new JSIL.BoxedVariable($a.MemberwiseClone());
    $thisType.Subtract(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  };

  function float3_Subtract$39 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((+a.get().x - +b.get().x), (+a.get().y - +b.get().y), (+a.get().z - +b.get().z)));
  };

  function float3_ToArray () {
    return JSIL.Array.New($T00(), [this.x, this.y, this.z]);
  };

  function float3_toString () {
    return $T0A().Format("({0}, {1}, {2})", this.x, this.y, this.z);
  };

  function float3_Transform$3A ($vec, $mat) {
    var mat = new JSIL.BoxedVariable($mat.MemberwiseClone());
    var vec = new JSIL.BoxedVariable($vec.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $S0A().CallStatic($thisType, "Transform", null, /* ref */ vec, /* ref */ mat, /* ref */ result);
    return result.get();
  };

  function float3_Transform$3B (/* ref */ vec, /* ref */ mat, /* ref */ result) {
    var float = new JSIL.BoxedVariable($S0B().Construct(vec.get().x, vec.get().y, vec.get().z, 1));
    $S0C().CallStatic($T02(), "Transform", null, /* ref */ float, /* ref */ mat, /* ref */ float);
    result.set((float.get()).get_xyz().MemberwiseClone());
  };

  function float3_Transform$3C ($vec, $quat) {
    var quat = new JSIL.BoxedVariable($quat.MemberwiseClone());
    var vec = new JSIL.BoxedVariable($vec.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $S0D().CallStatic($thisType, "Transform", null, /* ref */ vec, /* ref */ quat, /* ref */ result);
    return result.get();
  };

  function float3_Transform$3D (/* ref */ vec, /* ref */ quat, /* ref */ result) {
    var float = new JSIL.BoxedVariable(new $thisType());
    var float2 = new JSIL.BoxedVariable(new $thisType());
    var xyz = new JSIL.BoxedVariable((quat.get()).get_xyz().MemberwiseClone());
    $thisType.Cross(/* ref */ xyz, /* ref */ vec, /* ref */ float);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vec, (quat.get()).get_w(), /* ref */ float2);
    $thisType.Add(/* ref */ float, /* ref */ float2, /* ref */ float);
    $thisType.Cross(/* ref */ xyz, /* ref */ float, /* ref */ float);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ float, 2, /* ref */ float);
    $thisType.Add(/* ref */ vec, /* ref */ float, /* ref */ result);
  };

  function float3_TransformNormal$3E (norm, mat) {
    mat.Invert();
    return $thisType.TransformNormalInverse(norm.MemberwiseClone(), mat);
  };

  function float3_TransformNormal$3F (/* ref */ norm, /* ref */ mat, /* ref */ result) {
    var float4x = new JSIL.BoxedVariable($T0B().Invert(mat.get().MemberwiseClone()).MemberwiseClone());
    $thisType.TransformNormalInverse(/* ref */ norm, /* ref */ float4x, /* ref */ result);
  };

  function float3_TransformNormalInverse$40 (norm, invMat) {
    var result = new $thisType();
    result.x = +$thisType.Dot(norm, $S0E().Construct(invMat.Row0));
    result.y = +$thisType.Dot(norm, $S0E().Construct(invMat.Row1));
    result.z = +$thisType.Dot(norm, $S0E().Construct(invMat.Row2));
    return result;
  };

  function float3_TransformNormalInverse$41 (/* ref */ norm, /* ref */ invMat, /* ref */ result) {
    result.get().x = ((+norm.get().x * +invMat.get().Row0.x) + (+norm.get().y * +invMat.get().Row0.y)) + (+norm.get().z * +invMat.get().Row0.z);
    result.get().y = ((+norm.get().x * +invMat.get().Row1.x) + (+norm.get().y * +invMat.get().Row1.y)) + (+norm.get().z * +invMat.get().Row1.z);
    result.get().z = ((+norm.get().x * +invMat.get().Row2.x) + (+norm.get().y * +invMat.get().Row2.y)) + (+norm.get().z * +invMat.get().Row2.z);
  };

  function float3_TransformPerspective$42 ($vec, $mat) {
    var mat = new JSIL.BoxedVariable($mat.MemberwiseClone());
    var vec = new JSIL.BoxedVariable($vec.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.TransformPerspective(/* ref */ vec, /* ref */ mat, /* ref */ result);
    return result.get();
  };

  function float3_TransformPerspective$43 (/* ref */ vec, /* ref */ mat, /* ref */ result) {
    var float = new JSIL.BoxedVariable($S0F().Construct(vec.get()));
    $S0C().CallStatic($T02(), "Transform", null, /* ref */ float, /* ref */ mat, /* ref */ float);
    if (+float.get().w > 1.192093E-07) {
      result.get().x = +((+float.get().x / +float.get().w));
      result.get().y = +((+float.get().y / +float.get().w));
      result.get().z = +((+float.get().z / +float.get().w));
    } else {
      result.set($thisType.Zero.MemberwiseClone());
    }
  };

  function float3_TransformPosition$44 (pos, mat) {
    var result = new $thisType();
    result.x = +$thisType.Dot(pos, $S0E().Construct(mat.get_Column0())) + +mat.Row3.x;
    result.y = +$thisType.Dot(pos, $S0E().Construct(mat.get_Column1())) + +mat.Row3.y;
    result.z = +$thisType.Dot(pos, $S0E().Construct(mat.get_Column2())) + +mat.Row3.z;
    return result;
  };

  function float3_TransformPosition$45 (/* ref */ pos, /* ref */ mat, /* ref */ result) {
    result.get().x = (((+pos.get().x * +mat.get().Row0.x) + (+pos.get().y * +mat.get().Row1.x)) + (+pos.get().z * +mat.get().Row2.x)) + +mat.get().Row3.x;
    result.get().y = (((+pos.get().x * +mat.get().Row0.y) + (+pos.get().y * +mat.get().Row1.y)) + (+pos.get().z * +mat.get().Row2.y)) + +mat.get().Row3.y;
    result.get().z = (((+pos.get().x * +mat.get().Row0.z) + (+pos.get().y * +mat.get().Row1.z)) + (+pos.get().z * +mat.get().Row2.z)) + +mat.get().Row3.z;
  };

  function float3_TransformVector$46 (vec, mat) {
    var result = new $thisType();
    result.x = +$thisType.Dot(vec, $S0E().Construct(mat.get_Column0()));
    result.y = +$thisType.Dot(vec, $S0E().Construct(mat.get_Column1()));
    result.z = +$thisType.Dot(vec, $S0E().Construct(mat.get_Column2()));
    return result;
  };

  function float3_TransformVector$47 (/* ref */ vec, /* ref */ mat, /* ref */ result) {
    result.get().x = ((+vec.get().x * +mat.get().Row0.x) + (+vec.get().y * +mat.get().Row1.x)) + (+vec.get().z * +mat.get().Row2.x);
    result.get().y = ((+vec.get().x * +mat.get().Row0.y) + (+vec.get().y * +mat.get().Row1.y)) + (+vec.get().z * +mat.get().Row2.y);
    result.get().z = ((+vec.get().x * +mat.get().Row0.z) + (+vec.get().y * +mat.get().Row1.z)) + (+vec.get().z * +mat.get().Row2.z);
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.float3", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 3, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single
        ]), 
      float3__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.float2")), 
      float3__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Type), 
      float3__ctor$02
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.float4")), 
      float3__ctor$03
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.double3")), 
      float3__ctor$04
    );

    $.Method({Static:false, Public:true }, "Add", 
      JSIL.MethodSignature.Action($.Type), 
      float3_Add$05
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:false, Public:true }, "Add", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      float3_Add$06
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_Add$07
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Add$08
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type, $.Single, 
          $.Single
        ]), 
      float3_BaryCentric$09
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_BaryCentric$0A
    );

    $.Method({Static:true , Public:true }, "CalculateAngle", 
      new JSIL.MethodSignature($.Single, [$.Type, $.Type]), 
      float3_CalculateAngle$0B
    );

    $.Method({Static:true , Public:true }, "CalculateAngle", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Single])
        ]), 
      float3_CalculateAngle$0C
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type
        ]), 
      float3_Clamp$0D
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Clamp$0E
    );

    $.Method({Static:true , Public:true }, "ComponentMax", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_ComponentMax$0F
    );

    $.Method({Static:true , Public:true }, "ComponentMax", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_ComponentMax$10
    );

    $.Method({Static:true , Public:true }, "ComponentMin", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_ComponentMin$11
    );

    $.Method({Static:true , Public:true }, "ComponentMin", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_ComponentMin$12
    );

    $.Method({Static:true , Public:true }, "Cross", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_Cross$13
    );

    $.Method({Static:true , Public:true }, "Cross", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Cross$14
    );

    $.Method({Static:false, Public:true }, "Div", 
      JSIL.MethodSignature.Action($.Single), 
      float3_Div$15
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float3_Div$16
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Div$17
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float3_Divide$18
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Divide$19
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_Divide$1A
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Divide$1B
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature($.Single, [$.Type, $.Type]), 
      float3_Dot$1C
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Single])
        ]), 
      float3_Dot$1D
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      float3_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type]), 
      float3_Equals$1E
    );

    $.Method({Static:false, Public:true }, "get_b", 
      JSIL.MethodSignature.Return($.Single), 
      float3_get_b
    );

    $.Method({Static:false, Public:true }, "get_g", 
      JSIL.MethodSignature.Return($.Single), 
      float3_get_g
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      JSIL.MethodSignature.Return($.Single), 
      float3_get_Length
    );

    $.Method({Static:false, Public:true }, "get_LengthFast", 
      JSIL.MethodSignature.Return($.Single), 
      float3_get_LengthFast
    );

    $.Method({Static:false, Public:true }, "get_LengthSquared", 
      JSIL.MethodSignature.Return($.Single), 
      float3_get_LengthSquared
    );

    $.Method({Static:true , Public:true }, "get_Parse", 
      JSIL.MethodSignature.Return($asm07.TypeRef("System.Converter`2", [$.String, $.Type])), 
      float3_get_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_r", 
      JSIL.MethodSignature.Return($.Single), 
      float3_get_r
    );

    $.Method({Static:false, Public:true }, "get_xy", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.float2")), 
      float3_get_xy
    );

    $.Method({Static:false, Public:true }, "get_xyz", 
      JSIL.MethodSignature.Return($.Type), 
      float3_get_xyz
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32), 
      float3_GetHashCode
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Single
        ]), 
      float3_Lerp$1F
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Lerp$20
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_Max
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_Min
    );

    $.Method({Static:false, Public:true }, "Mult", 
      JSIL.MethodSignature.Action($.Single), 
      float3_Mult$21
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float3_Mult$22
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Mult$23
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float3_Multiply$24
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Multiply$25
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_Multiply$26
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Multiply$27
    );

    $.Method({Static:false, Public:true }, "Normalize", 
      JSIL.MethodSignature.Void, 
      float3_Normalize$28
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float3_Normalize$29
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float3_Normalize$2A
    );

    $.Method({Static:false, Public:true }, "NormalizeFast", 
      JSIL.MethodSignature.Void, 
      float3_NormalizeFast$2B
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float3_NormalizeFast$2C
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float3_NormalizeFast$2D
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Division", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float3_op_Division
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      float3_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Explicit", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.double3")]), 
      float3_op_Explicit
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      float3_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float3_op_Multiply$2E
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Single, $.Type]), 
      float3_op_Multiply$2F
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_op_Multiply$30
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_op_Subtraction
    );

    $.Method({Static:true , Public:true }, "op_UnaryNegation", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float3_op_UnaryNegation
    );

    $.Method({Static:true , Public:true }, "OrthoNormalize", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Type]), [$.Type, $.Type]), 
      float3_OrthoNormalize
    );

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single
        ]), 
      float3_Scale$31
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      JSIL.MethodSignature.Action($.Type), 
      float3_Scale$32
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      float3_Scale$33
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "set_b", 
      JSIL.MethodSignature.Action($.Single), 
      float3_set_b
    );

    $.Method({Static:false, Public:true }, "set_g", 
      JSIL.MethodSignature.Action($.Single), 
      float3_set_g
    );

    $.Method({Static:true , Public:true }, "set_Parse", 
      JSIL.MethodSignature.Action($asm07.TypeRef("System.Converter`2", [$.String, $.Type])), 
      float3_set_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "set_r", 
      JSIL.MethodSignature.Action($.Single), 
      float3_set_r
    );

    $.Method({Static:false, Public:true }, "set_xy", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.float2")), 
      float3_set_xy
    );

    $.Method({Static:false, Public:true }, "set_xyz", 
      JSIL.MethodSignature.Action($.Type), 
      float3_set_xyz
    );

    $.Method({Static:false, Public:true }, "Sub", 
      JSIL.MethodSignature.Action($.Type), 
      float3_Sub$34
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:false, Public:true }, "Sub", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      float3_Sub$35
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_Sub$36
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Sub$37
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3_Subtract$38
    );

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Subtract$39
    );

    $.Method({Static:false, Public:true }, "ToArray", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Single])), 
      float3_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      float3_toString
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.float4x4")]), 
      float3_Transform$3A
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Transform$3B
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.Quaternion")]), 
      float3_Transform$3C
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_Transform$3D
    );

    $.Method({Static:true , Public:true }, "TransformNormal", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.float4x4")]), 
      float3_TransformNormal$3E
    );

    $.Method({Static:true , Public:true }, "TransformNormal", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_TransformNormal$3F
    );

    $.Method({Static:true , Public:true }, "TransformNormalInverse", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.float4x4")]), 
      float3_TransformNormalInverse$40
    );

    $.Method({Static:true , Public:true }, "TransformNormalInverse", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_TransformNormalInverse$41
    );

    $.Method({Static:true , Public:true }, "TransformPerspective", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.float4x4")]), 
      float3_TransformPerspective$42
    );

    $.Method({Static:true , Public:true }, "TransformPerspective", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_TransformPerspective$43
    );

    $.Method({Static:true , Public:true }, "TransformPosition", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.float4x4")]), 
      float3_TransformPosition$44
    );

    $.Method({Static:true , Public:true }, "TransformPosition", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_TransformPosition$45
    );

    $.Method({Static:true , Public:true }, "TransformVector", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.float4x4")]), 
      float3_TransformVector$46
    );

    $.Method({Static:true , Public:true }, "TransformVector", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3_TransformVector$47
    );

    $.Field({Static:false, Public:true }, "x", $.Single)
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [1]; }); 
    $.Field({Static:false, Public:true }, "y", $.Single)
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [2]; }); 
    $.Field({Static:false, Public:true }, "z", $.Single)
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [3]; }); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitX", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitY", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitZ", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "Zero", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "One", $.Type); 
    $.Field({Static:true , Public:false}, "float3$Parse$value", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]))
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    function float3__cctor () {
      $thisType.UnitX = new $thisType();
      $thisType.UnitY = new $thisType();
      $thisType.UnitZ = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.One = new $thisType();
      $thisType.UnitX = $S00().Construct(1, 0, 0);
      $thisType.UnitY = $S00().Construct(0, 1, 0);
      $thisType.UnitZ = $S00().Construct(0, 0, 1);
      $thisType.Zero = $S00().Construct(0, 0, 0);
      $thisType.One = $S00().Construct(1, 1, 1);
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      float3__cctor
    );

    $.Property({Static:false, Public:true }, "Length", $.Single);

    $.Property({Static:false, Public:true }, "LengthFast", $.Single);

    $.Property({Static:false, Public:true }, "LengthSquared", $.Single);

    $.Property({Static:false, Public:true }, "xy", $asm04.TypeRef("Fusee.Math.float2"));

    $.Property({Static:false, Public:true }, "xyz", $.Type);

    $.Property({Static:false, Public:true }, "r", $.Single);

    $.Property({Static:false, Public:true }, "g", $.Single);

    $.Property({Static:false, Public:true }, "b", $.Single);

    $.Property({Static:true , Public:true }, "Parse", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]));

    $.ImplementInterfaces(
      /* 0 */ $asm07.TypeRef("System.IEquatable`1", [$.Type])
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm08.TypeRef("ProtoBuf.ProtoContractAttribute"));

})();

/* struct Fusee.Math.float3x3 */ 

(function float3x3$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Math.float3)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm07.System.Single)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Math.float4x4)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.System.String)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float3x3"), [
        $asm04.TypeRef("Fusee.Math.float3"), $asm04.TypeRef("Fusee.Math.float3"), 
        $asm04.TypeRef("Fusee.Math.float3")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float3x3"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float3"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single")
      ]))) ();
  };

  function float3x3__ctor$00 (row0, row1, row2) {
    this.Row0 = row0.MemberwiseClone();
    this.Row1 = row1.MemberwiseClone();
    this.Row2 = row2.MemberwiseClone();
  };

  function float3x3__ctor$01 (m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    this.Row0 = $S02().Construct(m00, m01, m02);
    this.Row1 = $S02().Construct(m10, m11, m12);
    this.Row2 = $S02().Construct(m20, m21, m22);
  };

  function float3x3__ctor$02 (mat4) {
    this.Row0 = $S02().Construct(mat4.Row0.x, mat4.Row0.y, mat4.Row0.z);
    this.Row1 = $S02().Construct(mat4.Row1.x, mat4.Row1.y, mat4.Row1.z);
    this.Row2 = $S02().Construct(mat4.Row2.x, mat4.Row2.y, mat4.Row2.z);
  };

  function float3x3_Add (left, right) {
    return $S01().Construct((+left.get_M11() + +right.get_M11()), (+left.get_M12() + +right.get_M12()), (+left.get_M13() + +right.get_M13()), (+left.get_M21() + +right.get_M21()), (+left.get_M22() + +right.get_M22()), (+left.get_M23() + +right.get_M23()), (+left.get_M31() + +right.get_M31()), (+left.get_M32() + +right.get_M32()), (+left.get_M33() + +right.get_M33()));
  };

  function float3x3_Object_Equals (obj) {
    return ($thisType.$Is(obj) && this.Equals($thisType.$Cast(obj).MemberwiseClone()));
  };

  function float3x3_Equals$03 (other) {
    return (!(!$T00().op_Equality(this.Row0.MemberwiseClone(), other.Row0.MemberwiseClone()) || 
        !$T00().op_Equality(this.Row1.MemberwiseClone(), other.Row1.MemberwiseClone())) && $T00().op_Equality(this.Row2.MemberwiseClone(), other.Row2.MemberwiseClone()));
  };

  function float3x3_get_Column0 () {
    return $S02().Construct(this.Row0.x, this.Row1.x, this.Row2.x);
  };

  function float3x3_get_Column1 () {
    return $S02().Construct(this.Row0.y, this.Row1.y, this.Row2.y);
  };

  function float3x3_get_Column2 () {
    return $S02().Construct(this.Row0.z, this.Row1.z, this.Row2.z);
  };

  function float3x3_get_Determinant () {
    return (((((((+this.Row0.x * +this.Row1.y) * +this.Row2.z) + ((+this.Row0.y * +this.Row1.z) * +this.Row2.x)) + ((+this.Row0.z * +this.Row1.x) * +this.Row2.y)) - ((+this.Row0.z * +this.Row1.y) * +this.Row2.x)) - ((+this.Row0.y * +this.Row1.x) * +this.Row2.z)) - ((+this.Row0.x * +this.Row1.z) * +this.Row2.y));
  };

  function float3x3_get_IsAffine () {
    return $T00().op_Equality(this.get_Column2().MemberwiseClone(), $T00().UnitZ.MemberwiseClone());
  };

  function float3x3_get_M11 () {
    return this.Row0.x;
  };

  function float3x3_get_M12 () {
    return this.Row0.y;
  };

  function float3x3_get_M13 () {
    return this.Row0.z;
  };

  function float3x3_get_M21 () {
    return this.Row1.x;
  };

  function float3x3_get_M22 () {
    return this.Row1.y;
  };

  function float3x3_get_M23 () {
    return this.Row1.z;
  };

  function float3x3_get_M31 () {
    return this.Row2.x;
  };

  function float3x3_get_M32 () {
    return this.Row2.y;
  };

  function float3x3_get_M33 () {
    return this.Row2.z;
  };

  function float3x3_GetHashCode () {
    return ((((this.Row0).GetHashCode() | 0) ^ ((this.Row1).GetHashCode() | 0)) ^ ((this.Row2).GetHashCode() | 0));
  };

  function float3x3_Mult$04 ($left, $right) {
    var right = new JSIL.BoxedVariable($right.MemberwiseClone());
    var left = new JSIL.BoxedVariable($left.MemberwiseClone());
    var float3x = new JSIL.BoxedVariable(new $thisType());
    if ($thisType.op_Equality(left.get().MemberwiseClone(), $thisType.Identity.MemberwiseClone())) {
      var result = right.get().MemberwiseClone();
    } else if ($thisType.op_Equality(right.get().MemberwiseClone(), $thisType.Identity.MemberwiseClone())) {
      result = left.get().MemberwiseClone();
    } else if (!(!$thisType.op_Equality(left.get().MemberwiseClone(), $thisType.Zero.MemberwiseClone()) && !$thisType.op_Equality(right.get().MemberwiseClone(), $thisType.Zero.MemberwiseClone()))) {
      result = $thisType.Zero.MemberwiseClone();
    } else {
      $thisType.Mult(/* ref */ left, /* ref */ right, /* ref */ float3x);
      result = float3x.get().MemberwiseClone();
    }
    return result;
  };

  function float3x3_Mult$05 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S01().Construct((((+(left.get()).get_M11() * +(right.get()).get_M11()) + (+(left.get()).get_M12() * +(right.get()).get_M21())) + (+(left.get()).get_M13() * +(right.get()).get_M31())), (((+(left.get()).get_M11() * +(right.get()).get_M12()) + (+(left.get()).get_M12() * +(right.get()).get_M22())) + (+(left.get()).get_M13() * +(right.get()).get_M32())), (((+(left.get()).get_M11() * +(right.get()).get_M13()) + (+(left.get()).get_M12() * +(right.get()).get_M23())) + (+(left.get()).get_M13() * +(right.get()).get_M33())), (((+(left.get()).get_M21() * +(right.get()).get_M11()) + (+(left.get()).get_M22() * +(right.get()).get_M21())) + (+(left.get()).get_M23() * +(right.get()).get_M31())), (((+(left.get()).get_M21() * +(right.get()).get_M12()) + (+(left.get()).get_M22() * +(right.get()).get_M22())) + (+(left.get()).get_M23() * +(right.get()).get_M32())), (((+(left.get()).get_M21() * +(right.get()).get_M13()) + (+(left.get()).get_M22() * +(right.get()).get_M23())) + (+(left.get()).get_M23() * +(right.get()).get_M33())), (((+(left.get()).get_M31() * +(right.get()).get_M11()) + (+(left.get()).get_M32() * +(right.get()).get_M21())) + (+(left.get()).get_M33() * +(right.get()).get_M31())), (((+(left.get()).get_M31() * +(right.get()).get_M12()) + (+(left.get()).get_M32() * +(right.get()).get_M22())) + (+(left.get()).get_M33() * +(right.get()).get_M32())), (((+(left.get()).get_M31() * +(right.get()).get_M13()) + (+(left.get()).get_M32() * +(right.get()).get_M23())) + (+(left.get()).get_M33() * +(right.get()).get_M33()))));
  };

  function float3x3_op_Addition (left, right) {
    return $thisType.Add(left, right);
  };

  function float3x3_op_Equality (left, right) {
    return left.Equals(right.MemberwiseClone());
  };

  function float3x3_op_Inequality (left, right) {
    return !left.Equals(right.MemberwiseClone());
  };

  function float3x3_op_Multiply$06 (left, right) {
    return $thisType.Mult(left.MemberwiseClone(), right.MemberwiseClone());
  };

  function float3x3_op_Multiply$07 (matrix, vector) {
    return $S02().Construct((((+matrix.get_Column0().x * +vector.x) + (+matrix.get_Column1().x * +vector.y)) + (+matrix.get_Column2().x * +vector.z)), (((+matrix.get_Column0().y * +vector.x) + (+matrix.get_Column1().y * +vector.y)) + (+matrix.get_Column2().y * +vector.z)), (((+matrix.get_Column0().z * +vector.x) + (+matrix.get_Column1().z * +vector.y)) + (+matrix.get_Column2().z * +vector.z)));
  };

  function float3x3_op_Multiply$08 (vector, matrix) {
    return $S02().Construct((((+matrix.get_M11() * +vector.x) + (+matrix.get_M21() * +vector.y)) + (+matrix.get_M31() * +vector.z)), (((+matrix.get_M12() * +vector.x) + (+matrix.get_M22() * +vector.y)) + (+matrix.get_M32() * +vector.z)), (((+matrix.get_M13() * +vector.x) + (+matrix.get_M23() * +vector.y)) + (+matrix.get_M33() * +vector.z)));
  };

  function float3x3_op_Subtraction (left, right) {
    return $thisType.Substract(left, right);
  };

  function float3x3_set_M11 (value) {
    this.Row0.x = +value;
  };

  function float3x3_set_M12 (value) {
    this.Row0.y = +value;
  };

  function float3x3_set_M13 (value) {
    this.Row0.z = +value;
  };

  function float3x3_set_M21 (value) {
    this.Row1.x = +value;
  };

  function float3x3_set_M22 (value) {
    this.Row1.y = +value;
  };

  function float3x3_set_M23 (value) {
    this.Row1.z = +value;
  };

  function float3x3_set_M31 (value) {
    this.Row2.x = +value;
  };

  function float3x3_set_M32 (value) {
    this.Row2.y = +value;
  };

  function float3x3_set_M33 (value) {
    this.Row2.z = +value;
  };

  function float3x3_Substract (left, right) {
    return $S01().Construct((+left.get_M11() - +right.get_M11()), (+left.get_M12() - +right.get_M12()), (+left.get_M13() - +right.get_M13()), (+left.get_M21() - +right.get_M21()), (+left.get_M22() - +right.get_M22()), (+left.get_M23() - +right.get_M23()), (+left.get_M31() - +right.get_M31()), (+left.get_M32() - +right.get_M32()), (+left.get_M33() - +right.get_M33()));
  };

  function float3x3_ToArray () {
    return JSIL.Array.New($T01(), [this.get_M11(), this.get_M12(), this.get_M13(), this.get_M21(), this.get_M22(), this.get_M23(), this.get_M31(), this.get_M32(), this.get_M33()]);
  };

  function float3x3_toString () {
    return $T04().Format("{0}\n{1}\n{2}", this.Row0, this.Row1, this.Row2);
  };

  function float3x3_Transpose$09 () {
    JSIL.CopyMembers($thisType.Transpose(this), this);
  };

  function float3x3_Transpose$0A (mat) {
    return $S00().Construct(mat.get_Column0().MemberwiseClone(), mat.get_Column1().MemberwiseClone(), mat.get_Column2().MemberwiseClone());
  };

  function float3x3_Transpose$0B (/* ref */ mat, /* ref */ result) {
    result.get().Row0 = (mat.get()).get_Column0().MemberwiseClone();
    result.get().Row1 = (mat.get()).get_Column1().MemberwiseClone();
    result.get().Row2 = (mat.get()).get_Column2().MemberwiseClone();
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.float3x3", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 9, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm04.TypeRef("Fusee.Math.float3"), $asm04.TypeRef("Fusee.Math.float3"), 
          $asm04.TypeRef("Fusee.Math.float3")
        ]), 
      float3x3__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single
        ]), 
      float3x3__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.float4x4")), 
      float3x3__ctor$02
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3x3_Add
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      float3x3_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type]), 
      float3x3_Equals$03
    );

    $.Method({Static:false, Public:true }, "get_Column0", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.float3")), 
      float3x3_get_Column0
    );

    $.Method({Static:false, Public:true }, "get_Column1", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.float3")), 
      float3x3_get_Column1
    );

    $.Method({Static:false, Public:true }, "get_Column2", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.float3")), 
      float3x3_get_Column2
    );

    $.Method({Static:false, Public:true }, "get_Determinant", 
      JSIL.MethodSignature.Return($.Single), 
      float3x3_get_Determinant
    );

    $.Method({Static:false, Public:true }, "get_IsAffine", 
      JSIL.MethodSignature.Return($.Boolean), 
      float3x3_get_IsAffine
    );

    $.Method({Static:false, Public:true }, "get_M11", 
      JSIL.MethodSignature.Return($.Single), 
      float3x3_get_M11
    );

    $.Method({Static:false, Public:true }, "get_M12", 
      JSIL.MethodSignature.Return($.Single), 
      float3x3_get_M12
    );

    $.Method({Static:false, Public:true }, "get_M13", 
      JSIL.MethodSignature.Return($.Single), 
      float3x3_get_M13
    );

    $.Method({Static:false, Public:true }, "get_M21", 
      JSIL.MethodSignature.Return($.Single), 
      float3x3_get_M21
    );

    $.Method({Static:false, Public:true }, "get_M22", 
      JSIL.MethodSignature.Return($.Single), 
      float3x3_get_M22
    );

    $.Method({Static:false, Public:true }, "get_M23", 
      JSIL.MethodSignature.Return($.Single), 
      float3x3_get_M23
    );

    $.Method({Static:false, Public:true }, "get_M31", 
      JSIL.MethodSignature.Return($.Single), 
      float3x3_get_M31
    );

    $.Method({Static:false, Public:true }, "get_M32", 
      JSIL.MethodSignature.Return($.Single), 
      float3x3_get_M32
    );

    $.Method({Static:false, Public:true }, "get_M33", 
      JSIL.MethodSignature.Return($.Single), 
      float3x3_get_M33
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32), 
      float3x3_GetHashCode
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3x3_Mult$04
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float3x3_Mult$05
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3x3_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      float3x3_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      float3x3_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3x3_op_Multiply$06
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$.Type, $asm04.TypeRef("Fusee.Math.float3")]), 
      float3x3_op_Multiply$07
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$asm04.TypeRef("Fusee.Math.float3"), $.Type]), 
      float3x3_op_Multiply$08
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3x3_op_Subtraction
    );

    $.Method({Static:false, Public:true }, "set_M11", 
      JSIL.MethodSignature.Action($.Single), 
      float3x3_set_M11
    );

    $.Method({Static:false, Public:true }, "set_M12", 
      JSIL.MethodSignature.Action($.Single), 
      float3x3_set_M12
    );

    $.Method({Static:false, Public:true }, "set_M13", 
      JSIL.MethodSignature.Action($.Single), 
      float3x3_set_M13
    );

    $.Method({Static:false, Public:true }, "set_M21", 
      JSIL.MethodSignature.Action($.Single), 
      float3x3_set_M21
    );

    $.Method({Static:false, Public:true }, "set_M22", 
      JSIL.MethodSignature.Action($.Single), 
      float3x3_set_M22
    );

    $.Method({Static:false, Public:true }, "set_M23", 
      JSIL.MethodSignature.Action($.Single), 
      float3x3_set_M23
    );

    $.Method({Static:false, Public:true }, "set_M31", 
      JSIL.MethodSignature.Action($.Single), 
      float3x3_set_M31
    );

    $.Method({Static:false, Public:true }, "set_M32", 
      JSIL.MethodSignature.Action($.Single), 
      float3x3_set_M32
    );

    $.Method({Static:false, Public:true }, "set_M33", 
      JSIL.MethodSignature.Action($.Single), 
      float3x3_set_M33
    );

    $.Method({Static:true , Public:true }, "Substract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float3x3_Substract
    );

    $.Method({Static:false, Public:false}, "ToArray", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Single])), 
      float3x3_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      float3x3_toString
    );

    $.Method({Static:false, Public:true }, "Transpose", 
      JSIL.MethodSignature.Void, 
      float3x3_Transpose$09
    );

    $.Method({Static:true , Public:true }, "Transpose", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float3x3_Transpose$0A
    );

    $.Method({Static:true , Public:true }, "Transpose", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float3x3_Transpose$0B
    );

    $.Field({Static:false, Public:true }, "Row0", $asm04.TypeRef("Fusee.Math.float3")); 
    $.Field({Static:false, Public:true }, "Row1", $asm04.TypeRef("Fusee.Math.float3")); 
    $.Field({Static:false, Public:true }, "Row2", $asm04.TypeRef("Fusee.Math.float3")); 
    $.Field({Static:true , Public:true }, "Identity", $.Type); 
    $.Field({Static:true , Public:true }, "Zero", $.Type); 
    function float3x3__cctor () {
      $thisType.Identity = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.Identity = $S00().Construct($T00().UnitX.MemberwiseClone(), $T00().UnitY.MemberwiseClone(), $T00().UnitZ.MemberwiseClone());
      $thisType.Zero = $S01().Construct(0, 0, 0, 0, 0, 0, 0, 0, 0);
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      float3x3__cctor
    );

    $.Property({Static:false, Public:true }, "Determinant", $.Single);

    $.Property({Static:false, Public:true }, "Column0", $asm04.TypeRef("Fusee.Math.float3"));

    $.Property({Static:false, Public:true }, "Column1", $asm04.TypeRef("Fusee.Math.float3"));

    $.Property({Static:false, Public:true }, "Column2", $asm04.TypeRef("Fusee.Math.float3"));

    $.Property({Static:false, Public:true }, "M11", $.Single);

    $.Property({Static:false, Public:true }, "M12", $.Single);

    $.Property({Static:false, Public:true }, "M13", $.Single);

    $.Property({Static:false, Public:true }, "M21", $.Single);

    $.Property({Static:false, Public:true }, "M22", $.Single);

    $.Property({Static:false, Public:true }, "M23", $.Single);

    $.Property({Static:false, Public:true }, "M31", $.Single);

    $.Property({Static:false, Public:true }, "M32", $.Single);

    $.Property({Static:false, Public:true }, "M33", $.Single);

    $.Property({Static:false, Public:true }, "IsAffine", $.Boolean);

    $.ImplementInterfaces(
      /* 0 */ $asm07.TypeRef("System.IEquatable`1", [$.Type])
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Math.float4 */ 

(function float4$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm07.System.Single)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Math.float2)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Math.float3)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm04.Fusee.Math.double4)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.System.Object)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm07.System.Math)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm07.System.Double)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm04.Fusee.Math.MathHelper)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm07.System.Converter$b2.Of($asm07.System.String, $asm04.Fusee.Math.float4))) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm07.System.String)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm04.Fusee.Math.float4x4)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm04.Fusee.Math.Quaternion)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float4"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float4"), [$asm07.TypeRef("System.Single"), $asm04.TypeRef("Fusee.Math.float4")]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")]), $asm07.TypeRef("System.Single"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")])
      ]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")]), $asm07.TypeRef("System.Single"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")])
      ]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")])
      ]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("System.Single"), [$asm07.TypeRef("System.Single")]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float2"), [$asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single")]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float3"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")])
      ]))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float4"), [$asm04.TypeRef("Fusee.Math.double4")]))) ();
  };
  var $S0A = function () {
    return ($S0A = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("System.Double"), [$asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Int32")]))) ();
  };
  var $S0B = function () {
    return ($S0B = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4x4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")])
      ]))) ();
  };
  var $S0C = function () {
    return ($S0C = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")])
      ]))) ();
  };
  var $S0D = function () {
    return ($S0D = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.Quaternion"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S0E = function () {
    return ($S0E = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")])
      ]))) ();
  };

  function float4__ctor$00 (x, y, z, w) {
    JSIL.CopyMembers(new $thisType(), this);
    this.x = +x;
    this.y = +y;
    this.z = +z;
    this.w = +w;
  };

  function float4__ctor$01 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = 0;
    this.w = 0;
  };

  function float4__ctor$02 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
    this.w = 0;
  };

  function float4__ctor$03 (v, ww) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
    this.w = +ww;
  };

  function float4__ctor$04 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
    this.w = +v.w;
  };

  function float4__ctor$05 (d4) {
    this.x = Math.fround(d4.x);
    this.y = Math.fround(d4.y);
    this.z = Math.fround(d4.z);
    this.w = Math.fround(d4.w);
  };

  function float4_Add$06 (right) {
    this.x += +right.x;
    this.y += +right.y;
    this.z += +right.z;
    this.w += +right.w;
  };

  function float4_Add$07 (/* ref */ right) {
    this.x += +right.get().x;
    this.y += +right.get().y;
    this.z += +right.get().z;
    this.w += +right.get().w;
  };

  function float4_Add$08 ($a, $b) {
    var b = new JSIL.BoxedVariable($b.MemberwiseClone());
    var a = new JSIL.BoxedVariable($a.MemberwiseClone());
    $thisType.Add(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  };

  function float4_Add$09 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((+a.get().x + +b.get().x), (+a.get().y + +b.get().y), (+a.get().z + +b.get().z), (+a.get().w + +b.get().w)));
  };

  function float4_BaryCentric$0A (a, b, c, u, v) {
    return $thisType.op_Addition(
      $thisType.op_Addition(a.MemberwiseClone(), $S01().CallStatic($thisType, "op_Multiply", null, u, $thisType.op_Subtraction(b.MemberwiseClone(), a).MemberwiseClone())).MemberwiseClone(), 
      $S01().CallStatic($thisType, "op_Multiply", null, v, $thisType.op_Subtraction(c.MemberwiseClone(), a).MemberwiseClone())
    );
  };

  function float4_BaryCentric$0B (/* ref */ a, /* ref */ b, /* ref */ c, u, v, /* ref */ result) {
    result.set(a.get().MemberwiseClone());
    var float = new JSIL.BoxedVariable(b.get().MemberwiseClone());
    $thisType.Subtract(/* ref */ float, /* ref */ a, /* ref */ float);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ float, u, /* ref */ float);
    $thisType.Add(/* ref */ result, /* ref */ float, /* ref */ result);
    float.set(c.get().MemberwiseClone());
    $thisType.Subtract(/* ref */ float, /* ref */ a, /* ref */ float);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ float, v, /* ref */ float);
    $thisType.Add(/* ref */ result, /* ref */ float, /* ref */ result);
  };

  function float4_Clamp$0C (vec, min, max) {
    vec.x = +(
      (+vec.x < +min.x)
         ? min.x
         : (
          (+vec.x > +max.x)
             ? max.x
             : vec.x)
    )
    ;
    vec.y = +(
      (+vec.y < +min.y)
         ? min.y
         : (
          (+vec.y > +max.y)
             ? max.y
             : vec.y)
    )
    ;
    vec.z = +(
      (+vec.x < +min.z)
         ? min.z
         : (
          (+vec.z > +max.z)
             ? max.z
             : vec.z)
    )
    ;
    vec.w = +(
      (+vec.y < +min.w)
         ? min.w
         : (
          (+vec.w > +max.w)
             ? max.w
             : vec.w)
    )
    ;
    return vec;
  };

  function float4_Clamp$0D (/* ref */ vec, /* ref */ min, /* ref */ max, /* ref */ result) {
    result.get().x = +(
      (+vec.get().x < +min.get().x)
         ? min.get().x
         : (
          (+vec.get().x > +max.get().x)
             ? max.get().x
             : vec.get().x)
    )
    ;
    result.get().y = +(
      (+vec.get().y < +min.get().y)
         ? min.get().y
         : (
          (+vec.get().y > +max.get().y)
             ? max.get().y
             : vec.get().y)
    )
    ;
    result.get().z = +(
      (+vec.get().x < +min.get().z)
         ? min.get().z
         : (
          (+vec.get().z > +max.get().z)
             ? max.get().z
             : vec.get().z)
    )
    ;
    result.get().w = +(
      (+vec.get().y < +min.get().w)
         ? min.get().w
         : (
          (+vec.get().w > +max.get().w)
             ? max.get().w
             : vec.get().w)
    )
    ;
  };

  function float4_Div$0E (f) {
    var num = +((1 / +f));
    this.x *= num;
    this.y *= num;
    this.z *= num;
    this.w *= num;
  };

  function float4_Div$0F (a, f) {
    var num = +((1 / +f));
    a.x *= num;
    a.y *= num;
    a.z *= num;
    a.w *= num;
    return a;
  };

  function float4_Div$10 (/* ref */ a, f, /* ref */ result) {
    var num = +((1 / +f));
    result.get().x = +a.get().x * num;
    result.get().y = +a.get().y * num;
    result.get().z = +a.get().z * num;
    result.get().w = +a.get().w * num;
  };

  function float4_Divide$11 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S03().CallStatic($thisType, "Divide", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  };

  function float4_Divide$12 (/* ref */ vector, scale, /* ref */ result) {
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vector, +((1 / +scale)), /* ref */ result);
  };

  function float4_Divide$13 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale.MemberwiseClone());
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S04().CallStatic($thisType, "Divide", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  };

  function float4_Divide$14 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct(+((+vector.get().x / +scale.get().x)), +((+vector.get().y / +scale.get().y)), +((+vector.get().z / +scale.get().z)), +((+vector.get().w / +scale.get().w))));
  };

  function float4_Dot$15 (left, right) {
    return ((((+left.x * +right.x) + (+left.y * +right.y)) + (+left.z * +right.z)) + (+left.w * +right.w));
  };

  function float4_Dot$16 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set((((+left.get().x * +right.get().x) + (+left.get().y * +right.get().y)) + (+left.get().z * +right.get().z)) + (+left.get().w * +right.get().w));
  };

  function float4_Object_Equals (obj) {
    return ($thisType.$Is(obj) && this.Equals($thisType.$Cast(obj).MemberwiseClone()));
  };

  function float4_Equals$17 (other) {
    return (!(((Math.abs((+this.x - +other.x))) >= 1.192093E-07) || 
        ((Math.abs((+this.y - +other.y))) >= 1.192093E-07) || 
        ((Math.abs((+this.z - +other.z))) >= 1.192093E-07)) && ((Math.abs((+this.w - +other.w))) < 1.192093E-07));
  };

  function float4_get_a () {
    return this.w;
  };

  function float4_get_b () {
    return this.z;
  };

  function float4_get_g () {
    return this.y;
  };

  function float4_get_Length () {
    return Math.fround(Math.sqrt(((((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z)) + (+this.w * +this.w))));
  };

  function float4_get_LengthFast () {
    return +((1 / +$S05().CallStatic($T07(), "InverseSqrtFast", null, (((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z)) + (+this.w * +this.w))));
  };

  function float4_get_LengthSquared () {
    return ((((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z)) + (+this.w * +this.w));
  };

  function float4_get_Parse () {
    return $thisType.float4$Parse$value;
  };

  function float4_get_r () {
    return this.x;
  };

  function float4_get_rg () {
    return this.get_xy();
  };

  function float4_get_rgb () {
    return this.get_xyz();
  };

  function float4_get_xy () {
    return $S06().Construct(this.x, this.y);
  };

  function float4_get_xyz () {
    return $S07().Construct(this.x, this.y, this.z);
  };

  function float4_GetHashCode () {
    return (((((this.x).GetHashCode() | 0) ^ ((this.y).GetHashCode() | 0)) ^ ((this.z).GetHashCode() | 0)) ^ ((this.w).GetHashCode() | 0));
  };

  function float4_Lerp$18 (a, b, blend) {
    a.x = (+blend * (+b.x - +a.x)) + +a.x;
    a.y = (+blend * (+b.y - +a.y)) + +a.y;
    a.z = (+blend * (+b.z - +a.z)) + +a.z;
    a.w = (+blend * (+b.w - +a.w)) + +a.w;
    return a;
  };

  function float4_Lerp$19 (/* ref */ a, /* ref */ b, blend, /* ref */ result) {
    result.get().x = (+blend * (+b.get().x - +a.get().x)) + +a.get().x;
    result.get().y = (+blend * (+b.get().y - +a.get().y)) + +a.get().y;
    result.get().z = (+blend * (+b.get().z - +a.get().z)) + +a.get().z;
    result.get().w = (+blend * (+b.get().w - +a.get().w)) + +a.get().w;
  };

  function float4_Max$1A (a, b) {
    a.x = +(
      (+a.x > +b.x)
         ? a.x
         : b.x)
    ;
    a.y = +(
      (+a.y > +b.y)
         ? a.y
         : b.y)
    ;
    a.z = +(
      (+a.z > +b.z)
         ? a.z
         : b.z)
    ;
    a.w = +(
      (+a.w > +b.w)
         ? a.w
         : b.w)
    ;
    return a;
  };

  function float4_Max$1B (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(
      (+a.get().x > +b.get().x)
         ? a.get().x
         : b.get().x)
    ;
    result.get().y = +(
      (+a.get().y > +b.get().y)
         ? a.get().y
         : b.get().y)
    ;
    result.get().z = +(
      (+a.get().z > +b.get().z)
         ? a.get().z
         : b.get().z)
    ;
    result.get().w = +(
      (+a.get().w > +b.get().w)
         ? a.get().w
         : b.get().w)
    ;
  };

  function float4_Min$1C (a, b) {
    a.x = +(
      (+a.x < +b.x)
         ? a.x
         : b.x)
    ;
    a.y = +(
      (+a.y < +b.y)
         ? a.y
         : b.y)
    ;
    a.z = +(
      (+a.z < +b.z)
         ? a.z
         : b.z)
    ;
    a.w = +(
      (+a.w < +b.w)
         ? a.w
         : b.w)
    ;
    return a;
  };

  function float4_Min$1D (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(
      (+a.get().x < +b.get().x)
         ? a.get().x
         : b.get().x)
    ;
    result.get().y = +(
      (+a.get().y < +b.get().y)
         ? a.get().y
         : b.get().y)
    ;
    result.get().z = +(
      (+a.get().z < +b.get().z)
         ? a.get().z
         : b.get().z)
    ;
    result.get().w = +(
      (+a.get().w < +b.get().w)
         ? a.get().w
         : b.get().w)
    ;
  };

  function float4_Mult$1E (f) {
    this.x *= +f;
    this.y *= +f;
    this.z *= +f;
    this.w *= +f;
  };

  function float4_Mult$1F (a, f) {
    a.x *= +f;
    a.y *= +f;
    a.z *= +f;
    a.w *= +f;
    return a;
  };

  function float4_Mult$20 (/* ref */ a, f, /* ref */ result) {
    result.get().x = +a.get().x * +f;
    result.get().y = +a.get().y * +f;
    result.get().z = +a.get().z * +f;
    result.get().w = +a.get().w * +f;
  };

  function float4_Multiply$21 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  };

  function float4_Multiply$22 (/* ref */ vector, scale, /* ref */ result) {
    result.set($S00().Construct((+vector.get().x * +scale), (+vector.get().y * +scale), (+vector.get().z * +scale), (+vector.get().w * +scale)));
  };

  function float4_Multiply$23 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale.MemberwiseClone());
    var vector = new JSIL.BoxedVariable($vector.MemberwiseClone());
    $S08().CallStatic($thisType, "Multiply", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  };

  function float4_Multiply$24 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct((+vector.get().x * +scale.get().x), (+vector.get().y * +scale.get().y), (+vector.get().z * +scale.get().z), (+vector.get().w * +scale.get().w)));
  };

  function float4_Normalize$25 () {
    var num = +((1 / +this.get_Length()));
    this.x *= num;
    this.y *= num;
    this.z *= num;
    this.w *= num;
  };

  function float4_Normalize$26 (vec) {
    var num = +((1 / +vec.get_Length()));
    vec.x *= num;
    vec.y *= num;
    vec.z *= num;
    vec.w *= num;
    return vec;
  };

  function float4_Normalize$27 (/* ref */ vec, /* ref */ result) {
    var num = +((1 / +(vec.get()).get_Length()));
    result.get().x = +vec.get().x * num;
    result.get().y = +vec.get().y * num;
    result.get().z = +vec.get().z * num;
    result.get().w = +vec.get().w * num;
  };

  function float4_NormalizeFast$28 () {
    var num = +$S05().CallStatic($T07(), "InverseSqrtFast", null, (((+this.x * +this.x) + (+this.y * +this.y)) + (+this.z * +this.z)) + (+this.w * +this.w));
    this.x *= num;
    this.y *= num;
    this.z *= num;
    this.w *= num;
  };

  function float4_NormalizeFast$29 (vec) {
    var num = +$S05().CallStatic($T07(), "InverseSqrtFast", null, (((+vec.x * +vec.x) + (+vec.y * +vec.y)) + (+vec.z * +vec.z)) + (+vec.w * +vec.w));
    vec.x *= num;
    vec.y *= num;
    vec.z *= num;
    vec.w *= num;
    return vec;
  };

  function float4_NormalizeFast$2A (/* ref */ vec, /* ref */ result) {
    var num = +$S05().CallStatic($T07(), "InverseSqrtFast", null, (((+vec.get().x * +vec.get().x) + (+vec.get().y * +vec.get().y)) + (+vec.get().z * +vec.get().z)) + (+vec.get().w * +vec.get().w));
    result.get().x = +vec.get().x * num;
    result.get().y = +vec.get().y * num;
    result.get().z = +vec.get().z * num;
    result.get().w = +vec.get().w * num;
  };

  function float4_op_Addition (left, right) {
    left.x += +right.x;
    left.y += +right.y;
    left.z += +right.z;
    left.w += +right.w;
    return left;
  };

  function float4_op_Division (vec, scale) {
    var num = +((1 / +scale));
    vec.x *= num;
    vec.y *= num;
    vec.z *= num;
    vec.w *= num;
    return vec;
  };

  function float4_op_Equality (left, right) {
    return left.Equals(right.MemberwiseClone());
  };

  function float4_op_Explicit (d4) {
    return $S09().Construct(d4);
  };

  function float4_op_Inequality (left, right) {
    return !left.Equals(right.MemberwiseClone());
  };

  function float4_op_Multiply$2B (vec, scale) {
    vec.x *= +scale;
    vec.y *= +scale;
    vec.z *= +scale;
    vec.w *= +scale;
    return vec;
  };

  function float4_op_Multiply$2C (left, right) {
    left.x *= +right.x;
    left.y *= +right.y;
    left.z *= +right.z;
    left.w *= +right.w;
    return left;
  };

  function float4_op_Multiply$2D (scale, vec) {
    vec.x *= +scale;
    vec.y *= +scale;
    vec.z *= +scale;
    vec.w *= +scale;
    return vec;
  };

  function float4_op_Subtraction (left, right) {
    left.x -= +right.x;
    left.y -= +right.y;
    left.z -= +right.z;
    left.w -= +right.w;
    return left;
  };

  function float4_op_UnaryNegation (vec) {
    vec.x = -vec.x;
    vec.y = -vec.y;
    vec.z = -vec.z;
    vec.w = -vec.w;
    return vec;
  };

  function float4_Round$2E () {
    this.x = Math.fround($S0A().CallStatic($T05(), "Round", null, this.x, 6));
    this.y = Math.fround($S0A().CallStatic($T05(), "Round", null, this.y, 6));
    this.z = Math.fround($S0A().CallStatic($T05(), "Round", null, this.z, 6));
    this.w = Math.fround($S0A().CallStatic($T05(), "Round", null, this.w, 6));
  };

  function float4_Round$2F (vec) {
    return $S00().Construct(Math.fround($S0A().CallStatic($T05(), "Round", null, vec.x, 6)), Math.fround($S0A().CallStatic($T05(), "Round", null, vec.y, 6)), Math.fround($S0A().CallStatic($T05(), "Round", null, vec.z, 6)), Math.fround($S0A().CallStatic($T05(), "Round", null, vec.w, 6)));
  };

  function float4_Scale$30 (sx, sy, sz, sw) {
    this.x *= +sx;
    this.y *= +sy;
    this.z *= +sz;
    this.w *= +sw;
  };

  function float4_Scale$31 (scale) {
    this.x *= +scale.x;
    this.y *= +scale.y;
    this.z *= +scale.z;
    this.w *= +scale.w;
  };

  function float4_Scale$32 (/* ref */ scale) {
    this.x *= +scale.get().x;
    this.y *= +scale.get().y;
    this.z *= +scale.get().z;
    this.w *= +scale.get().w;
  };

  function float4_set_a (value) {
    this.w = +value;
  };

  function float4_set_b (value) {
    this.z = +value;
  };

  function float4_set_g (value) {
    this.y = +value;
  };

  function float4_set_Parse (value) {
    $thisType.float4$Parse$value = value;
  };

  function float4_set_r (value) {
    this.x = +value;
  };

  function float4_set_rg (value) {
    (this.xy = value.MemberwiseClone());
  };

  function float4_set_rgb (value) {
    (this.xyz = value.MemberwiseClone());
  };

  function float4_set_xy (value) {
    this.x = +value.x;
    this.y = +value.y;
  };

  function float4_set_xyz (value) {
    this.x = +value.x;
    this.y = +value.y;
    this.z = +value.z;
  };

  function float4_Sub$33 (right) {
    this.x -= +right.x;
    this.y -= +right.y;
    this.z -= +right.z;
    this.w -= +right.w;
  };

  function float4_Sub$34 (/* ref */ right) {
    this.x -= +right.get().x;
    this.y -= +right.get().y;
    this.z -= +right.get().z;
    this.w -= +right.get().w;
  };

  function float4_Sub$35 (a, b) {
    a.x -= +b.x;
    a.y -= +b.y;
    a.z -= +b.z;
    a.w -= +b.w;
    return a;
  };

  function float4_Sub$36 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +a.get().x - +b.get().x;
    result.get().y = +a.get().y - +b.get().y;
    result.get().z = +a.get().z - +b.get().z;
    result.get().w = +a.get().w - +b.get().w;
  };

  function float4_Subtract$37 ($a, $b) {
    var b = new JSIL.BoxedVariable($b.MemberwiseClone());
    var a = new JSIL.BoxedVariable($a.MemberwiseClone());
    $thisType.Subtract(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  };

  function float4_Subtract$38 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((+a.get().x - +b.get().x), (+a.get().y - +b.get().y), (+a.get().z - +b.get().z), (+a.get().w - +b.get().w)));
  };

  function float4_ToArray () {
    return JSIL.Array.New($T00(), [this.x, this.y, this.z, this.w]);
  };

  function float4_toString () {
    return $T09().Format("({0}, {1}, {2}, {3})", JSIL.Array.New($T04(), [this.x, this.y, this.z, this.w]));
  };

  function float4_Transform$39 ($vec, $mat) {
    var mat = new JSIL.BoxedVariable($mat.MemberwiseClone());
    var vec = new JSIL.BoxedVariable($vec.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $S0B().CallStatic($thisType, "Transform", null, /* ref */ vec, /* ref */ mat, /* ref */ result);
    return result.get();
  };

  function float4_Transform$3A (/* ref */ vec, /* ref */ mat, /* ref */ result) {
    result.set($S00().Construct(((((+vec.get().x * +mat.get().Row0.x) + (+vec.get().y * +mat.get().Row1.x)) + (+vec.get().z * +mat.get().Row2.x)) + (+vec.get().w * +mat.get().Row3.x)), ((((+vec.get().x * +mat.get().Row0.y) + (+vec.get().y * +mat.get().Row1.y)) + (+vec.get().z * +mat.get().Row2.y)) + (+vec.get().w * +mat.get().Row3.y)), ((((+vec.get().x * +mat.get().Row0.z) + (+vec.get().y * +mat.get().Row1.z)) + (+vec.get().z * +mat.get().Row2.z)) + (+vec.get().w * +mat.get().Row3.z)), ((((+vec.get().x * +mat.get().Row0.w) + (+vec.get().y * +mat.get().Row1.w)) + (+vec.get().z * +mat.get().Row2.w)) + (+vec.get().w * +mat.get().Row3.w))));
  };

  function float4_Transform$3B ($vec, $quat) {
    var quat = new JSIL.BoxedVariable($quat.MemberwiseClone());
    var vec = new JSIL.BoxedVariable($vec.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $S0C().CallStatic($thisType, "Transform", null, /* ref */ vec, /* ref */ quat, /* ref */ result);
    return result.get();
  };

  function float4_Transform$3C (/* ref */ vec, /* ref */ quat, /* ref */ result) {
    var quaternion2 = new JSIL.BoxedVariable(new ($T0B())());
    var quaternion3 = new JSIL.BoxedVariable(new ($T0B())());
    var quaternion = new JSIL.BoxedVariable($S0D().Construct(vec.get().x, vec.get().y, vec.get().z, vec.get().w));
    $T0B().Invert(/* ref */ quat, /* ref */ quaternion2);
    $S0E().CallStatic($T0B(), "Multiply", null, /* ref */ quat, /* ref */ quaternion, /* ref */ quaternion3);
    $S0E().CallStatic($T0B(), "Multiply", null, /* ref */ quaternion3, /* ref */ quaternion2, /* ref */ quaternion);
    result.set($S00().Construct((quaternion.get()).get_x(), (quaternion.get()).get_y(), (quaternion.get()).get_z(), (quaternion.get()).get_w()));
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.float4", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 4, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single
        ]), 
      float4__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.float2")), 
      float4__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.float3")), 
      float4__ctor$02
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.float3"), $.Single]), 
      float4__ctor$03
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($.Type), 
      float4__ctor$04
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.double4")), 
      float4__ctor$05
    );

    $.Method({Static:false, Public:true }, "Add", 
      JSIL.MethodSignature.Action($.Type), 
      float4_Add$06
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:false, Public:true }, "Add", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      float4_Add$07
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4_Add$08
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Add$09
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type, $.Single, 
          $.Single
        ]), 
      float4_BaryCentric$0A
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_BaryCentric$0B
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type
        ]), 
      float4_Clamp$0C
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Clamp$0D
    );

    $.Method({Static:false, Public:true }, "Div", 
      JSIL.MethodSignature.Action($.Single), 
      float4_Div$0E
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float4_Div$0F
    );

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Div$10
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float4_Divide$11
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Divide$12
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4_Divide$13
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Divide$14
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature($.Single, [$.Type, $.Type]), 
      float4_Dot$15
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Single])
        ]), 
      float4_Dot$16
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      float4_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type]), 
      float4_Equals$17
    );

    $.Method({Static:false, Public:true }, "get_a", 
      JSIL.MethodSignature.Return($.Single), 
      float4_get_a
    );

    $.Method({Static:false, Public:true }, "get_b", 
      JSIL.MethodSignature.Return($.Single), 
      float4_get_b
    );

    $.Method({Static:false, Public:true }, "get_g", 
      JSIL.MethodSignature.Return($.Single), 
      float4_get_g
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      JSIL.MethodSignature.Return($.Single), 
      float4_get_Length
    );

    $.Method({Static:false, Public:true }, "get_LengthFast", 
      JSIL.MethodSignature.Return($.Single), 
      float4_get_LengthFast
    );

    $.Method({Static:false, Public:true }, "get_LengthSquared", 
      JSIL.MethodSignature.Return($.Single), 
      float4_get_LengthSquared
    );

    $.Method({Static:true , Public:true }, "get_Parse", 
      JSIL.MethodSignature.Return($asm07.TypeRef("System.Converter`2", [$.String, $.Type])), 
      float4_get_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_r", 
      JSIL.MethodSignature.Return($.Single), 
      float4_get_r
    );

    $.Method({Static:false, Public:true }, "get_rg", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.float2")), 
      float4_get_rg
    );

    $.Method({Static:false, Public:true }, "get_rgb", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.float3")), 
      float4_get_rgb
    );

    $.Method({Static:false, Public:true }, "get_xy", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.float2")), 
      float4_get_xy
    );

    $.Method({Static:false, Public:true }, "get_xyz", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.float3")), 
      float4_get_xyz
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32), 
      float4_GetHashCode
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Single
        ]), 
      float4_Lerp$18
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Lerp$19
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4_Max$1A
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Max$1B
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4_Min$1C
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Min$1D
    );

    $.Method({Static:false, Public:true }, "Mult", 
      JSIL.MethodSignature.Action($.Single), 
      float4_Mult$1E
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float4_Mult$1F
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Mult$20
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float4_Multiply$21
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Multiply$22
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4_Multiply$23
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Multiply$24
    );

    $.Method({Static:false, Public:true }, "Normalize", 
      JSIL.MethodSignature.Void, 
      float4_Normalize$25
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float4_Normalize$26
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float4_Normalize$27
    );

    $.Method({Static:false, Public:true }, "NormalizeFast", 
      JSIL.MethodSignature.Void, 
      float4_NormalizeFast$28
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float4_NormalizeFast$29
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float4_NormalizeFast$2A
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Division", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float4_op_Division
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      float4_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Explicit", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.double4")]), 
      float4_op_Explicit
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      float4_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      float4_op_Multiply$2B
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4_op_Multiply$2C
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Single, $.Type]), 
      float4_op_Multiply$2D
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4_op_Subtraction
    );

    $.Method({Static:true , Public:true }, "op_UnaryNegation", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float4_op_UnaryNegation
    );

    $.Method({Static:false, Public:true }, "Round", 
      JSIL.MethodSignature.Void, 
      float4_Round$2E
    );

    $.Method({Static:true , Public:true }, "Round", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float4_Round$2F
    );

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single
        ]), 
      float4_Scale$30
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      JSIL.MethodSignature.Action($.Type), 
      float4_Scale$31
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      float4_Scale$32
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "set_a", 
      JSIL.MethodSignature.Action($.Single), 
      float4_set_a
    );

    $.Method({Static:false, Public:true }, "set_b", 
      JSIL.MethodSignature.Action($.Single), 
      float4_set_b
    );

    $.Method({Static:false, Public:true }, "set_g", 
      JSIL.MethodSignature.Action($.Single), 
      float4_set_g
    );

    $.Method({Static:true , Public:true }, "set_Parse", 
      JSIL.MethodSignature.Action($asm07.TypeRef("System.Converter`2", [$.String, $.Type])), 
      float4_set_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "set_r", 
      JSIL.MethodSignature.Action($.Single), 
      float4_set_r
    );

    $.Method({Static:false, Public:true }, "set_rg", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.float2")), 
      float4_set_rg
    );

    $.Method({Static:false, Public:true }, "set_rgb", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.float3")), 
      float4_set_rgb
    );

    $.Method({Static:false, Public:true }, "set_xy", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.float2")), 
      float4_set_xy
    );

    $.Method({Static:false, Public:true }, "set_xyz", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.float3")), 
      float4_set_xyz
    );

    $.Method({Static:false, Public:true }, "Sub", 
      JSIL.MethodSignature.Action($.Type), 
      float4_Sub$33
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:false, Public:true }, "Sub", 
      JSIL.MethodSignature.Action($jsilcore.TypeRef("JSIL.Reference", [$.Type])), 
      float4_Sub$34
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4_Sub$35
    );

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Sub$36
    );

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4_Subtract$37
    );

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Subtract$38
    );

    $.Method({Static:false, Public:true }, "ToArray", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Single])), 
      float4_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      float4_toString
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.float4x4")]), 
      float4_Transform$39
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Transform$3A
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.Quaternion")]), 
      float4_Transform$3B
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4_Transform$3C
    );

    $.Field({Static:false, Public:true }, "x", $.Single)
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [1]; }); 
    $.Field({Static:false, Public:true }, "y", $.Single)
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [2]; }); 
    $.Field({Static:false, Public:true }, "z", $.Single)
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [3]; }); 
    $.Field({Static:false, Public:true }, "w", $.Single)
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [4]; }); 
    $.Field({Static:true , Public:true }, "UnitX", $.Type); 
    $.Field({Static:true , Public:true }, "UnitY", $.Type); 
    $.Field({Static:true , Public:true }, "UnitZ", $.Type); 
    $.Field({Static:true , Public:true }, "UnitW", $.Type); 
    $.Field({Static:true , Public:true }, "Zero", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "One", $.Type); 
    $.Field({Static:true , Public:false}, "float4$Parse$value", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]))
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    function float4__cctor () {
      $thisType.UnitX = new $thisType();
      $thisType.UnitY = new $thisType();
      $thisType.UnitZ = new $thisType();
      $thisType.UnitW = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.One = new $thisType();
      $thisType.UnitX = $S00().Construct(1, 0, 0, 0);
      $thisType.UnitY = $S00().Construct(0, 1, 0, 0);
      $thisType.UnitZ = $S00().Construct(0, 0, 1, 0);
      $thisType.UnitW = $S00().Construct(0, 0, 0, 1);
      $thisType.Zero = $S00().Construct(0, 0, 0, 0);
      $thisType.One = $S00().Construct(1, 1, 1, 1);
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      float4__cctor
    );

    $.Property({Static:false, Public:true }, "Length", $.Single);

    $.Property({Static:false, Public:true }, "LengthFast", $.Single);

    $.Property({Static:false, Public:true }, "LengthSquared", $.Single);

    $.Property({Static:false, Public:true }, "xy", $asm04.TypeRef("Fusee.Math.float2"));

    $.Property({Static:false, Public:true }, "xyz", $asm04.TypeRef("Fusee.Math.float3"));

    $.Property({Static:false, Public:true }, "r", $.Single);

    $.Property({Static:false, Public:true }, "g", $.Single);

    $.Property({Static:false, Public:true }, "b", $.Single);

    $.Property({Static:false, Public:true }, "rg", $asm04.TypeRef("Fusee.Math.float2"));

    $.Property({Static:false, Public:true }, "rgb", $asm04.TypeRef("Fusee.Math.float3"));

    $.Property({Static:false, Public:true }, "a", $.Single);

    $.Property({Static:true , Public:true }, "Parse", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]));

    $.ImplementInterfaces(
      /* 0 */ $asm07.TypeRef("System.IEquatable`1", [$.Type])
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm08.TypeRef("ProtoBuf.ProtoContractAttribute"));

})();

/* struct Fusee.Math.float4x4 */ 

(function float4x4$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Math.float4)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm07.System.Single)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Math.double4x4)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm04.Fusee.Math.float3)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.System.Math)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm07.System.Double)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm07.System.ArgumentOutOfRangeException)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm07.System.Object)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm07.System.ApplicationException)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm07.System.Converter$b2.Of($asm07.System.String, $asm04.Fusee.Math.float4x4))) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm07.System.String)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float4x4"), [
        $asm04.TypeRef("Fusee.Math.float4"), $asm04.TypeRef("Fusee.Math.float4"), 
        $asm04.TypeRef("Fusee.Math.float4"), $asm04.TypeRef("Fusee.Math.float4")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float4"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float4x4"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("System.ArgumentOutOfRangeException"), [$asm07.TypeRef("System.String")]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm07.TypeRef("System.Single"), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4x4")])]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float3"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("System.ApplicationException"), [$asm07.TypeRef("System.String")]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float4x4"), [$asm04.TypeRef("Fusee.Math.double4x4")]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float4"), [$asm04.TypeRef("Fusee.Math.float4"), $asm07.TypeRef("System.Single")]))) ();
  };

  function float4x4__ctor$00 (row0, row1, row2, row3) {
    this.Row0 = row0.MemberwiseClone();
    this.Row1 = row1.MemberwiseClone();
    this.Row2 = row2.MemberwiseClone();
    this.Row3 = row3.MemberwiseClone();
  };

  function float4x4__ctor$01 (m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    this.Row0 = $S01().Construct(m00, m01, m02, m03);
    this.Row1 = $S01().Construct(m10, m11, m12, m13);
    this.Row2 = $S01().Construct(m20, m21, m22, m23);
    this.Row3 = $S01().Construct(m30, m31, m32, m33);
  };

  function float4x4__ctor$02 (d4x4) {
    this.Row0 = $T00().op_Explicit(d4x4.Row0);
    this.Row1 = $T00().op_Explicit(d4x4.Row1);
    this.Row2 = $T00().op_Explicit(d4x4.Row2);
    this.Row3 = $T00().op_Explicit(d4x4.Row3);
  };

  function float4x4_Add (left, right) {
    return $S02().Construct((+left.get_M11() + +right.get_M11()), (+left.get_M12() + +right.get_M12()), (+left.get_M13() + +right.get_M13()), (+left.get_M14() + +right.get_M14()), (+left.get_M21() + +right.get_M21()), (+left.get_M22() + +right.get_M22()), (+left.get_M23() + +right.get_M23()), (+left.get_M24() + +right.get_M24()), (+left.get_M31() + +right.get_M31()), (+left.get_M32() + +right.get_M32()), (+left.get_M33() + +right.get_M33()), (+left.get_M34() + +right.get_M34()), (+left.get_M41() + +right.get_M41()), (+left.get_M42() + +right.get_M42()), (+left.get_M43() + +right.get_M43()), (+left.get_M44() + +right.get_M44()));
  };

  function float4x4_CreateFromAxisAngle$03 (axis, angle, /* ref */ result) {
    var num = Math.fround(Math.cos(-angle));
    var num2 = Math.fround(Math.sin(-angle));
    var num3 = 1 - num;
    axis.Normalize();
    result.set($S02().Construct((((num3 * +axis.x) * +axis.x) + num), (((num3 * +axis.x) * +axis.y) + (num2 * +axis.z)), (((num3 * +axis.x) * +axis.z) - (num2 * +axis.y)), 0, (((num3 * +axis.x) * +axis.y) - (num2 * +axis.z)), (((num3 * +axis.y) * +axis.y) + num), (((num3 * +axis.y) * +axis.z) + (num2 * +axis.x)), 0, (((num3 * +axis.x) * +axis.z) + (num2 * +axis.y)), (((num3 * +axis.y) * +axis.z) - (num2 * +axis.x)), (((num3 * +axis.z) * +axis.z) + num), 0, 0, 0, 0, 1));
  };

  function float4x4_CreateFromAxisAngle$04 (axis, angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateFromAxisAngle(axis.MemberwiseClone(), angle, /* ref */ result);
    return result.get();
  };

  function float4x4_CreateOrthographic$05 (width, height, zNear, zFar, /* ref */ result) {
    $thisType.CreateOrthographicOffCenter(
      +((-width / 2)), 
      +((+width / 2)), 
      +((-height / 2)), 
      +((+height / 2)), 
      zNear, 
      zFar, 
      /* ref */ result
    );
  };

  function float4x4_CreateOrthographic$06 (width, height, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateOrthographicOffCenter(
      +((-width / 2)), 
      +((+width / 2)), 
      +((-height / 2)), 
      +((+height / 2)), 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  };

  function float4x4_CreateOrthographicOffCenter$07 (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    result.set(new $thisType());
    var num = +((1 / (+right - +left)));
    var num2 = +((1 / (+top - +bottom)));
    var num3 = +((1 / (+zFar - +zNear)));
    (result.get()).set_M11(2 * num);
    (result.get()).set_M22(2 * num2);
    (result.get()).set_M33(2 * num3);
    (result.get()).set_M14(-(+right + +left) * num);
    (result.get()).set_M24(-(+top + +bottom) * num2);
    (result.get()).set_M34(-(+zFar + +zNear) * num3);
    (result.get()).set_M44(1);
  };

  function float4x4_CreateOrthographicOffCenter$08 (left, right, bottom, top, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateOrthographicOffCenter(
      left, 
      right, 
      bottom, 
      top, 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  };

  function float4x4_CreateOrthographicOffCenterRH (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    result.set(new $thisType());
    var num = +((1 / (+right - +left)));
    var num2 = +((1 / (+top - +bottom)));
    var num3 = +((1 / (+zFar - +zNear)));
    (result.get()).set_M11(2 * num);
    (result.get()).set_M22(2 * num2);
    (result.get()).set_M33(-2 * num3);
    (result.get()).set_M14(-(+right + +left) * num);
    (result.get()).set_M24(-(+top + +bottom) * num2);
    (result.get()).set_M34(-(+zFar + +zNear) * num3);
    (result.get()).set_M44(1);
  };

  function float4x4_CreatePerspectiveFieldOfView$09 (fovy, aspect, zNear, zFar, /* ref */ result) {
    if (!((+fovy > 0) && (+fovy <= 3.1415926535897931))) {
      throw $S03().Construct("fovy");
    }
    if (+aspect <= 0) {
      throw $S03().Construct("aspect");
    }
    if (+zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    if (+zFar <= 0) {
      throw $S03().Construct("zFar");
    }
    if (+zNear >= +zFar) {
      throw $S03().Construct("zNear");
    }
    var num = +zNear * Math.fround(Math.tan((0.5 * +fovy)));
    var num2 = -num;
    $thisType.CreatePerspectiveOffCenter(
      num2 * +aspect, 
      num * +aspect, 
      num2, 
      num, 
      zNear, 
      zFar, 
      /* ref */ result
    );
  };

  function float4x4_CreatePerspectiveFieldOfView$0A (fovy, aspect, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreatePerspectiveFieldOfView(
      fovy, 
      aspect, 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  };

  function float4x4_CreatePerspectiveFieldOfView_ROW$0B (fovy, aspect, zNear, zFar, /* ref */ result) {
    if (!((+fovy > 0) && (+fovy <= 3.1415926535897931))) {
      throw $S03().Construct("fovy");
    }
    if (+aspect <= 0) {
      throw $S03().Construct("aspect");
    }
    if (+zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    if (+zFar <= 0) {
      throw $S03().Construct("zFar");
    }
    if (+zNear >= +zFar) {
      throw $S03().Construct("zNear");
    }
    var num = +zNear * Math.fround(Math.tan((0.5 * +fovy)));
    var num2 = -num;
    $thisType.CreatePerspectiveOffCenter_ROW(
      num2 * +aspect, 
      num * +aspect, 
      num2, 
      num, 
      zNear, 
      zFar, 
      /* ref */ result
    );
  };

  function float4x4_CreatePerspectiveFieldOfView_ROW$0C (fovy, aspect, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreatePerspectiveFieldOfView_ROW(
      fovy, 
      aspect, 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  };

  function float4x4_CreatePerspectiveOffCenter$0D (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    if (+zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    if (+zFar <= 0) {
      throw $S03().Construct("zFar");
    }
    if (+zNear >= +zFar) {
      throw $S03().Construct("zNear");
    }
    var m2 = +(((2 * +zNear) / (+top - +bottom)));
    var m4 = +(((+top + +bottom) / (+bottom - +top)));
    result.set($S02().Construct(+(((2 * +zNear) / (+right - +left))), 0, +(((+left + +right) / (+left - +right))), 0, 0, m2, m4, 0, 0, 0, +(((+zFar + +zNear) / (+zFar - +zNear))), +((-((2 * +zFar) * +zNear) / (+zFar - +zNear))), 0, 0, 1, 0));
  };

  function float4x4_CreatePerspectiveOffCenter$0E (left, right, bottom, top, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreatePerspectiveOffCenter(
      left, 
      right, 
      bottom, 
      top, 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  };

  function float4x4_CreatePerspectiveOffCenter_ROW (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    if (+zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    if (+zFar <= 0) {
      throw $S03().Construct("zFar");
    }
    if (+zNear >= +zFar) {
      throw $S03().Construct("zNear");
    }
    var m2 = +(((2 * +zNear) / (+top - +bottom)));
    var m4 = +(((+top + +bottom) / (+bottom - +top)));
    result.set($S02().Construct(+(((2 * +zNear) / (+right - +left))), 0, 0, 0, 0, m2, 0, 0, +(((+left + +right) / (+left - +right))), m4, +(((+zFar + +zNear) / (+zFar - +zNear))), 1, 0, 0, +((-((2 * +zFar) * +zNear) / (+zFar - +zNear))), 0));
  };

  function float4x4_CreatePerspectiveOffCenterRH (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    if (+zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    if (+zFar <= 0) {
      throw $S03().Construct("zFar");
    }
    if (+zNear >= +zFar) {
      throw $S03().Construct("zNear");
    }
    var m = +(((2 * +zNear) / (+right - +left)));
    var m2 = +(((2 * +zNear) / (+top - +bottom)));
    var m3 = +(((+right + +left) / (+right - +left)));
    var m4 = +(((+top + +bottom) / (+top - +bottom)));
    result.set($S02().Construct(m, 0, m3, 0, 0, m2, m4, 0, 0, 0, +((-(+zFar + +zNear) / (+zFar - +zNear))), +((-((2 * +zFar) * +zNear) / (+zFar - +zNear))), 0, 0, -1, 0));
  };

  function float4x4_CreateRotationX$0F (angle, /* ref */ result) {
    var num = Math.fround(Math.cos(angle));
    var num2 = Math.fround(Math.sin(angle));
    result.get().Row0 = $T00().UnitX.MemberwiseClone();
    result.get().Row1 = $S01().Construct(0, num, -num2, 0);
    result.get().Row2 = $S01().Construct(0, num2, num, 0);
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  };

  function float4x4_CreateRotationX$10 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationX(angle, /* ref */ result);
    return result.get();
  };

  function float4x4_CreateRotationX_ROW$11 (angle, /* ref */ result) {
    var num = Math.fround(Math.cos(angle));
    var num2 = Math.fround(Math.sin(angle));
    result.get().Row0 = $T00().UnitX.MemberwiseClone();
    result.get().Row1 = $S01().Construct(0, num, num2, 0);
    result.get().Row2 = $S01().Construct(0, -num2, num, 0);
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  };

  function float4x4_CreateRotationX_ROW$12 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationX_ROW(angle, /* ref */ result);
    return result.get();
  };

  function float4x4_CreateRotationY$13 (angle, /* ref */ result) {
    var num = Math.fround(Math.cos(angle));
    var num2 = Math.fround(Math.sin(angle));
    result.get().Row0 = $S01().Construct(num, 0, num2, 0);
    result.get().Row1 = $T00().UnitY.MemberwiseClone();
    result.get().Row2 = $S01().Construct(-num2, 0, num, 0);
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  };

  function float4x4_CreateRotationY$14 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationY(angle, /* ref */ result);
    return result.get();
  };

  function float4x4_CreateRotationY_ROW$15 (angle, /* ref */ result) {
    var num = Math.fround(Math.cos(angle));
    var num2 = Math.fround(Math.sin(angle));
    result.get().Row0 = $S01().Construct(num, 0, -num2, 0);
    result.get().Row1 = $T00().UnitY.MemberwiseClone();
    result.get().Row2 = $S01().Construct(num2, 0, num, 0);
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  };

  function float4x4_CreateRotationY_ROW$16 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationY_ROW(angle, /* ref */ result);
    return result.get();
  };

  function float4x4_CreateRotationZ$17 (angle, /* ref */ result) {
    var num = Math.fround(Math.cos(angle));
    var num2 = Math.fround(Math.sin(angle));
    result.get().Row0 = $S01().Construct(num, -num2, 0, 0);
    result.get().Row1 = $S01().Construct(num2, num, 0, 0);
    result.get().Row2 = $T00().UnitZ.MemberwiseClone();
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  };

  function float4x4_CreateRotationZ$18 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationZ(angle, /* ref */ result);
    return result.get();
  };

  function float4x4_CreateScale$19 (scale, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    (result.get()).set_M11(scale);
    (result.get()).set_M22(scale);
    (result.get()).set_M33(scale);
  };

  function float4x4_CreateScale$1A (scale) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $S04().CallStatic($thisType, "CreateScale", null, scale, /* ref */ result);
    return result.get();
  };

  function float4x4_CreateScale$1B (x, y, z, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    (result.get()).set_M11(x);
    (result.get()).set_M22(y);
    (result.get()).set_M33(z);
  };

  function float4x4_CreateScale$1C (/* ref */ vector, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    (result.get()).set_M11(vector.get().x);
    (result.get()).set_M22(vector.get().y);
    (result.get()).set_M33(vector.get().z);
  };

  function float4x4_CreateScale$1D (x, y, z) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateScale(x, y, z, /* ref */ result);
    return result.get();
  };

  function float4x4_CreateScale$1E (vector) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateScale(vector.x, vector.y, vector.z, /* ref */ result);
    return result.get();
  };

  function float4x4_CreateTranslation$1F (x, y, z, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    (result.get()).set_M14(x);
    (result.get()).set_M24(y);
    (result.get()).set_M34(z);
  };

  function float4x4_CreateTranslation$20 (/* ref */ vector, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    (result.get()).set_M14(vector.get().x);
    (result.get()).set_M24(vector.get().y);
    (result.get()).set_M34(vector.get().z);
  };

  function float4x4_CreateTranslation$21 (x, y, z) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateTranslation(x, y, z, /* ref */ result);
    return result.get();
  };

  function float4x4_CreateTranslation$22 (vector) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateTranslation(vector.x, vector.y, vector.z, /* ref */ result);
    return result.get();
  };

  function float4x4_CreateTranslation_ROW$23 (x, y, z, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    result.get().Row3 = $S01().Construct(x, y, z, 1);
  };

  function float4x4_CreateTranslation_ROW$24 (x, y, z) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateTranslation_ROW(x, y, z, /* ref */ result);
    return result.get();
  };

  function float4x4_Object_Equals (obj) {
    return ($thisType.$Is(obj) && this.Equals($thisType.$Cast(obj).MemberwiseClone()));
  };

  function float4x4_Equals$25 (other) {
    return (!(!$T00().op_Equality(this.Row0.MemberwiseClone(), other.Row0.MemberwiseClone()) || 
        !$T00().op_Equality(this.Row1.MemberwiseClone(), other.Row1.MemberwiseClone()) || 
        !$T00().op_Equality(this.Row2.MemberwiseClone(), other.Row2.MemberwiseClone())) && $T00().op_Equality(this.Row3.MemberwiseClone(), other.Row3.MemberwiseClone()));
  };

  function float4x4_get_Column0 () {
    return $S01().Construct(this.Row0.x, this.Row1.x, this.Row2.x, this.Row3.x);
  };

  function float4x4_get_Column1 () {
    return $S01().Construct(this.Row0.y, this.Row1.y, this.Row2.y, this.Row3.y);
  };

  function float4x4_get_Column2 () {
    return $S01().Construct(this.Row0.z, this.Row1.z, this.Row2.z, this.Row3.z);
  };

  function float4x4_get_Column3 () {
    return $S01().Construct(this.Row0.w, this.Row1.w, this.Row2.w, this.Row3.w);
  };

  function float4x4_get_Determinant () {
    return ((((((((((((((((((((((((((+this.Row0.x * +this.Row1.y) * +this.Row2.z) * +this.Row3.w) - (((+this.Row0.x * +this.Row1.y) * +this.Row2.w) * +this.Row3.z)) + (((+this.Row0.x * +this.Row1.z) * +this.Row2.w) * +this.Row3.y)) - (((+this.Row0.x * +this.Row1.z) * +this.Row2.y) * +this.Row3.w)) + (((+this.Row0.x * +this.Row1.w) * +this.Row2.y) * +this.Row3.z)) - (((+this.Row0.x * +this.Row1.w) * +this.Row2.z) * +this.Row3.y)) - (((+this.Row0.y * +this.Row1.z) * +this.Row2.w) * +this.Row3.x)) + (((+this.Row0.y * +this.Row1.z) * +this.Row2.x) * +this.Row3.w)) - (((+this.Row0.y * +this.Row1.w) * +this.Row2.x) * +this.Row3.z)) + (((+this.Row0.y * +this.Row1.w) * +this.Row2.z) * +this.Row3.x)) - (((+this.Row0.y * +this.Row1.x) * +this.Row2.z) * +this.Row3.w)) + (((+this.Row0.y * +this.Row1.x) * +this.Row2.w) * +this.Row3.z)) + (((+this.Row0.z * +this.Row1.w) * +this.Row2.x) * +this.Row3.y)) - (((+this.Row0.z * +this.Row1.w) * +this.Row2.y) * +this.Row3.x)) + (((+this.Row0.z * +this.Row1.x) * +this.Row2.y) * +this.Row3.w)) - (((+this.Row0.z * +this.Row1.x) * +this.Row2.w) * +this.Row3.y)) + (((+this.Row0.z * +this.Row1.y) * +this.Row2.w) * +this.Row3.x)) - (((+this.Row0.z * +this.Row1.y) * +this.Row2.x) * +this.Row3.w)) - (((+this.Row0.w * +this.Row1.x) * +this.Row2.y) * +this.Row3.z)) + (((+this.Row0.w * +this.Row1.x) * +this.Row2.z) * +this.Row3.y)) - (((+this.Row0.w * +this.Row1.y) * +this.Row2.z) * +this.Row3.x)) + (((+this.Row0.w * +this.Row1.y) * +this.Row2.x) * +this.Row3.z)) - (((+this.Row0.w * +this.Row1.z) * +this.Row2.x) * +this.Row3.y)) + (((+this.Row0.w * +this.Row1.z) * +this.Row2.y) * +this.Row3.x));
  };

  function float4x4_get_IsAffine () {
    return $T00().op_Equality(this.Row3.MemberwiseClone(), $T00().UnitW.MemberwiseClone());
  };

  function float4x4_get_M11 () {
    return this.Row0.x;
  };

  function float4x4_get_M12 () {
    return this.Row0.y;
  };

  function float4x4_get_M13 () {
    return this.Row0.z;
  };

  function float4x4_get_M14 () {
    return this.Row0.w;
  };

  function float4x4_get_M21 () {
    return this.Row1.x;
  };

  function float4x4_get_M22 () {
    return this.Row1.y;
  };

  function float4x4_get_M23 () {
    return this.Row1.z;
  };

  function float4x4_get_M24 () {
    return this.Row1.w;
  };

  function float4x4_get_M31 () {
    return this.Row2.x;
  };

  function float4x4_get_M32 () {
    return this.Row2.y;
  };

  function float4x4_get_M33 () {
    return this.Row2.z;
  };

  function float4x4_get_M34 () {
    return this.Row2.w;
  };

  function float4x4_get_M41 () {
    return this.Row3.x;
  };

  function float4x4_get_M42 () {
    return this.Row3.y;
  };

  function float4x4_get_M43 () {
    return this.Row3.z;
  };

  function float4x4_get_M44 () {
    return this.Row3.w;
  };

  function float4x4_get_Offset () {
    return $S05().Construct(this.Row0.w, this.Row1.w, this.Row2.w);
  };

  function float4x4_get_Parse () {
    return $thisType.float4x4$Parse$value;
  };

  function float4x4_GetHashCode () {
    return (((((this.Row0).GetHashCode() | 0) ^ ((this.Row1).GetHashCode() | 0)) ^ ((this.Row2).GetHashCode() | 0)) ^ ((this.Row3).GetHashCode() | 0));
  };

  function float4x4_Invert$26 () {
    JSIL.CopyMembers($thisType.Invert(this).MemberwiseClone(), this);
  };

  function float4x4_Invert$27 (mat) {
    if (!(!$thisType.op_Equality(mat.MemberwiseClone(), $thisType.Identity.MemberwiseClone()) && !$thisType.op_Equality(mat.MemberwiseClone(), $thisType.Zero.MemberwiseClone()))) {
      var result = mat.MemberwiseClone();
    } else {
      mat.Transpose();
      var num = +mat.get_M33() * +mat.get_M44();
      var num2 = +mat.get_M34() * +mat.get_M43();
      var num3 = +mat.get_M32() * +mat.get_M44();
      var num4 = +mat.get_M34() * +mat.get_M42();
      var num5 = +mat.get_M32() * +mat.get_M43();
      var num6 = +mat.get_M33() * +mat.get_M42();
      var num7 = +mat.get_M31() * +mat.get_M44();
      var num8 = +mat.get_M34() * +mat.get_M41();
      var num9 = +mat.get_M31() * +mat.get_M43();
      var num10 = +mat.get_M33() * +mat.get_M41();
      var num11 = +mat.get_M31() * +mat.get_M42();
      var num12 = +mat.get_M32() * +mat.get_M41();
      var num13 = ((num * +mat.get_M22()) + (num4 * +mat.get_M23())) + (num5 * +mat.get_M24());
      num13 -= ((num2 * +mat.get_M22()) + (num3 * +mat.get_M23())) + (num6 * +mat.get_M24());
      var num14 = ((num2 * +mat.get_M21()) + (num7 * +mat.get_M23())) + (num10 * +mat.get_M24());
      num14 -= ((num * +mat.get_M21()) + (num8 * +mat.get_M23())) + (num9 * +mat.get_M24());
      var num15 = ((num3 * +mat.get_M21()) + (num8 * +mat.get_M22())) + (num11 * +mat.get_M24());
      num15 -= ((num4 * +mat.get_M21()) + (num7 * +mat.get_M22())) + (num12 * +mat.get_M24());
      var num16 = ((num6 * +mat.get_M21()) + (num9 * +mat.get_M22())) + (num12 * +mat.get_M23());
      num16 -= ((num5 * +mat.get_M21()) + (num10 * +mat.get_M22())) + (num11 * +mat.get_M23());
      var num17 = ((num2 * +mat.get_M12()) + (num3 * +mat.get_M13())) + (num6 * +mat.get_M14());
      num17 -= ((num * +mat.get_M12()) + (num4 * +mat.get_M13())) + (num5 * +mat.get_M14());
      var num18 = ((num * +mat.get_M11()) + (num8 * +mat.get_M13())) + (num9 * +mat.get_M14());
      num18 -= ((num2 * +mat.get_M11()) + (num7 * +mat.get_M13())) + (num10 * +mat.get_M14());
      var num19 = ((num4 * +mat.get_M11()) + (num7 * +mat.get_M12())) + (num12 * +mat.get_M14());
      num19 -= ((num3 * +mat.get_M11()) + (num8 * +mat.get_M12())) + (num11 * +mat.get_M14());
      var num20 = ((num5 * +mat.get_M11()) + (num10 * +mat.get_M12())) + (num11 * +mat.get_M13());
      num20 -= ((num6 * +mat.get_M11()) + (num9 * +mat.get_M12())) + (num12 * +mat.get_M13());
      num = +mat.get_M13() * +mat.get_M24();
      num2 = +mat.get_M14() * +mat.get_M23();
      num3 = +mat.get_M12() * +mat.get_M24();
      num4 = +mat.get_M14() * +mat.get_M22();
      num5 = +mat.get_M12() * +mat.get_M23();
      num6 = +mat.get_M13() * +mat.get_M22();
      num7 = +mat.get_M11() * +mat.get_M24();
      num8 = +mat.get_M14() * +mat.get_M21();
      num9 = +mat.get_M11() * +mat.get_M23();
      num10 = +mat.get_M13() * +mat.get_M21();
      num11 = +mat.get_M11() * +mat.get_M22();
      num12 = +mat.get_M12() * +mat.get_M21();
      var num21 = ((num * +mat.get_M42()) + (num4 * +mat.get_M43())) + (num5 * +mat.get_M44());
      num21 -= ((num2 * +mat.get_M42()) + (num3 * +mat.get_M43())) + (num6 * +mat.get_M44());
      var num22 = ((num2 * +mat.get_M41()) + (num7 * +mat.get_M43())) + (num10 * +mat.get_M44());
      num22 -= ((num * +mat.get_M41()) + (num8 * +mat.get_M43())) + (num9 * +mat.get_M44());
      var num23 = ((num3 * +mat.get_M41()) + (num8 * +mat.get_M42())) + (num11 * +mat.get_M44());
      num23 -= ((num4 * +mat.get_M41()) + (num7 * +mat.get_M42())) + (num12 * +mat.get_M44());
      var num24 = ((num6 * +mat.get_M41()) + (num9 * +mat.get_M42())) + (num12 * +mat.get_M43());
      num24 -= ((num5 * +mat.get_M41()) + (num10 * +mat.get_M42())) + (num11 * +mat.get_M43());
      var num25 = ((num3 * +mat.get_M33()) + (num6 * +mat.get_M34())) + (num2 * +mat.get_M32());
      num25 -= ((num5 * +mat.get_M34()) + (num * +mat.get_M32())) + (num4 * +mat.get_M33());
      var num26 = ((num9 * +mat.get_M34()) + (num * +mat.get_M31())) + (num8 * +mat.get_M33());
      num26 -= ((num7 * +mat.get_M33()) + (num10 * +mat.get_M34())) + (num2 * +mat.get_M31());
      var num27 = ((num7 * +mat.get_M32()) + (num12 * +mat.get_M34())) + (num4 * +mat.get_M31());
      num27 -= ((num11 * +mat.get_M34()) + (num3 * +mat.get_M31())) + (num8 * +mat.get_M32());
      var num28 = ((num11 * +mat.get_M33()) + (num5 * +mat.get_M31())) + (num10 * +mat.get_M32());
      num28 -= ((num9 * +mat.get_M32()) + (num12 * +mat.get_M33())) + (num6 * +mat.get_M31());
      var num29 = (((+mat.get_M11() * num13) + (+mat.get_M12() * num14)) + (+mat.get_M13() * num15)) + (+mat.get_M14() * num16);
      if (!((num29 <= 1.192093E-07) && (num29 >= -1.192093E-07))) {
        num29 = +((1 / num29));
        $thisType.prototype._ctor.call(mat, 
          num29 * num13, 
          num29 * num14, 
          num29 * num15, 
          num29 * num16, 
          num29 * num17, 
          num29 * num18, 
          num29 * num19, 
          num29 * num20, 
          num29 * num21, 
          num29 * num22, 
          num29 * num23, 
          num29 * num24, 
          num29 * num25, 
          num29 * num26, 
          num29 * num27, 
          num29 * num28
        );
      } else {
        mat.Transpose();
      }
      result = mat.MemberwiseClone();
    }
    return result;
  };

  function float4x4_InvertAffine (mat) {
    throw $S06().Construct("InvertAffine is broken (probably since column order notation)");
  };

  function float4x4_LookAt$28 (eye, target, up) {
    var float = $T03().Normalize($T03().op_Subtraction(target.MemberwiseClone(), eye).MemberwiseClone());
    var float2 = $T03().Normalize($T03().Cross(up.MemberwiseClone(), float.MemberwiseClone()).MemberwiseClone());
    var left = $T03().Cross(float.MemberwiseClone(), float2.MemberwiseClone()).MemberwiseClone();
    return $S02().Construct(float2.x, float2.y, float2.z, -$T03().Dot(float2, eye), left.x, left.y, left.z, -$T03().Dot(left, eye), float.x, float.y, float.z, -$T03().Dot(float, eye), 0, 0, 0, 1);
  };

  function float4x4_LookAt$29 (eyeX, eyeY, eyeZ, targetX, targetY, targetZ, upX, upY, upZ) {
    return $thisType.LookAt($S05().Construct(eyeX, eyeY, eyeZ), $S05().Construct(targetX, targetY, targetZ), $S05().Construct(upX, upY, upZ));
  };

  function float4x4_LookAt_ROW$2A (eye, target, up) {
    var float = $T03().Normalize($T03().op_Subtraction(target.MemberwiseClone(), eye).MemberwiseClone());
    var float2 = $T03().Normalize($T03().Cross(up.MemberwiseClone(), float.MemberwiseClone()).MemberwiseClone());
    var left = $T03().Cross(float.MemberwiseClone(), float2.MemberwiseClone()).MemberwiseClone();
    return $S00().Construct($S01().Construct(float2.x, left.x, float.x, 0), $S01().Construct(float2.y, left.y, float.y, 0), $S01().Construct(float2.z, left.z, float.z, 0), $S01().Construct(-$T03().Dot(float2, eye), -$T03().Dot(left, eye), -$T03().Dot(float, eye), 1));
  };

  function float4x4_LookAt_ROW$2B (eyeX, eyeY, eyeZ, targetX, targetY, targetZ, upX, upY, upZ) {
    return $thisType.LookAt_ROW($S05().Construct(eyeX, eyeY, eyeZ), $S05().Construct(targetX, targetY, targetZ), $S05().Construct(upX, upY, upZ));
  };

  function float4x4_LookAtRH (eye, target, up) {
    var float = $T03().Normalize($T03().op_Subtraction(eye.MemberwiseClone(), target).MemberwiseClone());
    var float2 = $T03().Normalize($T03().Cross(up.MemberwiseClone(), float.MemberwiseClone()).MemberwiseClone());
    var left = $T03().Cross(float.MemberwiseClone(), float2.MemberwiseClone()).MemberwiseClone();
    return $S02().Construct(float2.x, float2.y, float2.z, -$T03().Dot(float2, eye), left.x, left.y, left.z, -$T03().Dot(left, eye), float.x, float.y, float.z, -$T03().Dot(float, eye), 0, 0, 0, 1);
  };

  function float4x4_Mult$2C ($left, $right) {
    var right = new JSIL.BoxedVariable($right);
    var left = new JSIL.BoxedVariable($left);
    var float4x = new JSIL.BoxedVariable(new $thisType());
    if ($thisType.op_Equality(left.get().MemberwiseClone(), $thisType.Identity.MemberwiseClone())) {
      var result = right.get().MemberwiseClone();
    } else if ($thisType.op_Equality(right.get().MemberwiseClone(), $thisType.Identity.MemberwiseClone())) {
      result = left.get().MemberwiseClone();
    } else if (!(!$thisType.op_Equality(left.get().MemberwiseClone(), $thisType.Zero.MemberwiseClone()) && !$thisType.op_Equality(right.get().MemberwiseClone(), $thisType.Zero.MemberwiseClone()))) {
      result = $thisType.Zero.MemberwiseClone();
    } else {
      if (!(!(left.get()).get_IsAffine() || !(right.get()).get_IsAffine())) {
        $thisType.MultAffine(/* ref */ left, /* ref */ right, /* ref */ float4x);
      } else {
        $thisType.Mult(/* ref */ left, /* ref */ right, /* ref */ float4x);
      }
      result = float4x.get().MemberwiseClone();
    }
    return result;
  };

  function float4x4_Mult$2D (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct(((((+(left.get()).get_M11() * +(right.get()).get_M11()) + (+(left.get()).get_M12() * +(right.get()).get_M21())) + (+(left.get()).get_M13() * +(right.get()).get_M31())) + (+(left.get()).get_M14() * +(right.get()).get_M41())), ((((+(left.get()).get_M11() * +(right.get()).get_M12()) + (+(left.get()).get_M12() * +(right.get()).get_M22())) + (+(left.get()).get_M13() * +(right.get()).get_M32())) + (+(left.get()).get_M14() * +(right.get()).get_M42())), ((((+(left.get()).get_M11() * +(right.get()).get_M13()) + (+(left.get()).get_M12() * +(right.get()).get_M23())) + (+(left.get()).get_M13() * +(right.get()).get_M33())) + (+(left.get()).get_M14() * +(right.get()).get_M43())), ((((+(left.get()).get_M11() * +(right.get()).get_M14()) + (+(left.get()).get_M12() * +(right.get()).get_M24())) + (+(left.get()).get_M13() * +(right.get()).get_M34())) + (+(left.get()).get_M14() * +(right.get()).get_M44())), ((((+(left.get()).get_M21() * +(right.get()).get_M11()) + (+(left.get()).get_M22() * +(right.get()).get_M21())) + (+(left.get()).get_M23() * +(right.get()).get_M31())) + (+(left.get()).get_M24() * +(right.get()).get_M41())), ((((+(left.get()).get_M21() * +(right.get()).get_M12()) + (+(left.get()).get_M22() * +(right.get()).get_M22())) + (+(left.get()).get_M23() * +(right.get()).get_M32())) + (+(left.get()).get_M24() * +(right.get()).get_M42())), ((((+(left.get()).get_M21() * +(right.get()).get_M13()) + (+(left.get()).get_M22() * +(right.get()).get_M23())) + (+(left.get()).get_M23() * +(right.get()).get_M33())) + (+(left.get()).get_M24() * +(right.get()).get_M43())), ((((+(left.get()).get_M21() * +(right.get()).get_M14()) + (+(left.get()).get_M22() * +(right.get()).get_M24())) + (+(left.get()).get_M23() * +(right.get()).get_M34())) + (+(left.get()).get_M24() * +(right.get()).get_M44())), ((((+(left.get()).get_M31() * +(right.get()).get_M11()) + (+(left.get()).get_M32() * +(right.get()).get_M21())) + (+(left.get()).get_M33() * +(right.get()).get_M31())) + (+(left.get()).get_M34() * +(right.get()).get_M41())), ((((+(left.get()).get_M31() * +(right.get()).get_M12()) + (+(left.get()).get_M32() * +(right.get()).get_M22())) + (+(left.get()).get_M33() * +(right.get()).get_M32())) + (+(left.get()).get_M34() * +(right.get()).get_M42())), ((((+(left.get()).get_M31() * +(right.get()).get_M13()) + (+(left.get()).get_M32() * +(right.get()).get_M23())) + (+(left.get()).get_M33() * +(right.get()).get_M33())) + (+(left.get()).get_M34() * +(right.get()).get_M43())), ((((+(left.get()).get_M31() * +(right.get()).get_M14()) + (+(left.get()).get_M32() * +(right.get()).get_M24())) + (+(left.get()).get_M33() * +(right.get()).get_M34())) + (+(left.get()).get_M34() * +(right.get()).get_M44())), ((((+(left.get()).get_M41() * +(right.get()).get_M11()) + (+(left.get()).get_M42() * +(right.get()).get_M21())) + (+(left.get()).get_M43() * +(right.get()).get_M31())) + (+(left.get()).get_M44() * +(right.get()).get_M41())), ((((+(left.get()).get_M41() * +(right.get()).get_M12()) + (+(left.get()).get_M42() * +(right.get()).get_M22())) + (+(left.get()).get_M43() * +(right.get()).get_M32())) + (+(left.get()).get_M44() * +(right.get()).get_M42())), ((((+(left.get()).get_M41() * +(right.get()).get_M13()) + (+(left.get()).get_M42() * +(right.get()).get_M23())) + (+(left.get()).get_M43() * +(right.get()).get_M33())) + (+(left.get()).get_M44() * +(right.get()).get_M43())), ((((+(left.get()).get_M41() * +(right.get()).get_M14()) + (+(left.get()).get_M42() * +(right.get()).get_M24())) + (+(left.get()).get_M43() * +(right.get()).get_M34())) + (+(left.get()).get_M44() * +(right.get()).get_M44()))));
  };

  function float4x4_MultAffine (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct((((+(left.get()).get_M11() * +(right.get()).get_M11()) + (+(left.get()).get_M12() * +(right.get()).get_M21())) + (+(left.get()).get_M13() * +(right.get()).get_M31())), (((+(left.get()).get_M11() * +(right.get()).get_M12()) + (+(left.get()).get_M12() * +(right.get()).get_M22())) + (+(left.get()).get_M13() * +(right.get()).get_M32())), (((+(left.get()).get_M11() * +(right.get()).get_M13()) + (+(left.get()).get_M12() * +(right.get()).get_M23())) + (+(left.get()).get_M13() * +(right.get()).get_M33())), ((((+(left.get()).get_M11() * +(right.get()).get_M14()) + (+(left.get()).get_M12() * +(right.get()).get_M24())) + (+(left.get()).get_M13() * +(right.get()).get_M34())) + +(left.get()).get_M14()), (((+(left.get()).get_M21() * +(right.get()).get_M11()) + (+(left.get()).get_M22() * +(right.get()).get_M21())) + (+(left.get()).get_M23() * +(right.get()).get_M31())), (((+(left.get()).get_M21() * +(right.get()).get_M12()) + (+(left.get()).get_M22() * +(right.get()).get_M22())) + (+(left.get()).get_M23() * +(right.get()).get_M32())), (((+(left.get()).get_M21() * +(right.get()).get_M13()) + (+(left.get()).get_M22() * +(right.get()).get_M23())) + (+(left.get()).get_M23() * +(right.get()).get_M33())), ((((+(left.get()).get_M21() * +(right.get()).get_M14()) + (+(left.get()).get_M22() * +(right.get()).get_M24())) + (+(left.get()).get_M23() * +(right.get()).get_M34())) + +(left.get()).get_M24()), (((+(left.get()).get_M31() * +(right.get()).get_M11()) + (+(left.get()).get_M32() * +(right.get()).get_M21())) + (+(left.get()).get_M33() * +(right.get()).get_M31())), (((+(left.get()).get_M31() * +(right.get()).get_M12()) + (+(left.get()).get_M32() * +(right.get()).get_M22())) + (+(left.get()).get_M33() * +(right.get()).get_M32())), (((+(left.get()).get_M31() * +(right.get()).get_M13()) + (+(left.get()).get_M32() * +(right.get()).get_M23())) + (+(left.get()).get_M33() * +(right.get()).get_M33())), ((((+(left.get()).get_M31() * +(right.get()).get_M14()) + (+(left.get()).get_M32() * +(right.get()).get_M24())) + (+(left.get()).get_M33() * +(right.get()).get_M34())) + +(left.get()).get_M34()), 0, 0, 0, 1));
  };

  function float4x4_op_Addition (left, right) {
    return $thisType.Add(left, right);
  };

  function float4x4_op_Equality (left, right) {
    return left.Equals(right.MemberwiseClone());
  };

  function float4x4_op_Explicit (d4x4) {
    return $S07().Construct(d4x4);
  };

  function float4x4_op_Inequality (left, right) {
    return !left.Equals(right.MemberwiseClone());
  };

  function float4x4_op_Multiply$2E (left, right) {
    return $thisType.Mult(left.MemberwiseClone(), right.MemberwiseClone());
  };

  function float4x4_op_Multiply$2F (matrix, vector) {
    return $thisType.Transform(matrix, vector);
  };

  function float4x4_op_Multiply$30 (vector, matrix) {
    return $thisType.TransformPremult(vector, matrix);
  };

  function float4x4_op_Multiply$31 (matrix, vector) {
    return $thisType.TransformPD(matrix, vector);
  };

  function float4x4_op_Multiply$32 (vector, matrix) {
    return $thisType.TransformPremultPD(vector, matrix);
  };

  function float4x4_op_Subtraction (left, right) {
    return $thisType.Substract(left, right);
  };

  function float4x4_Round$33 () {
    (this.Row0).Round();
    (this.Row1).Round();
    (this.Row2).Round();
    (this.Row3).Round();
  };

  function float4x4_Round$34 (mat) {
    return $S00().Construct($T00().Round(mat.Row0.MemberwiseClone()).MemberwiseClone(), $T00().Round(mat.Row1.MemberwiseClone()).MemberwiseClone(), $T00().Round(mat.Row2.MemberwiseClone()).MemberwiseClone(), $T00().Round(mat.Row3.MemberwiseClone()).MemberwiseClone());
  };

  function float4x4_Scale$35 (scale) {
    return $thisType.Scale(scale, scale, scale);
  };

  function float4x4_Scale$36 (scale) {
    return $thisType.Scale(scale.x, scale.y, scale.z);
  };

  function float4x4_Scale$37 (x, y, z) {
    var result = new $thisType();
    result.Row0 = $S08().CallStatic($T00(), "op_Multiply", null, $T00().UnitX.MemberwiseClone(), x);
    result.Row1 = $S08().CallStatic($T00(), "op_Multiply", null, $T00().UnitY.MemberwiseClone(), y);
    result.Row2 = $S08().CallStatic($T00(), "op_Multiply", null, $T00().UnitZ.MemberwiseClone(), z);
    result.Row3 = $T00().UnitW.MemberwiseClone();
    return result;
  };

  function float4x4_set_M11 (value) {
    this.Row0.x = +value;
  };

  function float4x4_set_M12 (value) {
    this.Row0.y = +value;
  };

  function float4x4_set_M13 (value) {
    this.Row0.z = +value;
  };

  function float4x4_set_M14 (value) {
    this.Row0.w = +value;
  };

  function float4x4_set_M21 (value) {
    this.Row1.x = +value;
  };

  function float4x4_set_M22 (value) {
    this.Row1.y = +value;
  };

  function float4x4_set_M23 (value) {
    this.Row1.z = +value;
  };

  function float4x4_set_M24 (value) {
    this.Row1.w = +value;
  };

  function float4x4_set_M31 (value) {
    this.Row2.x = +value;
  };

  function float4x4_set_M32 (value) {
    this.Row2.y = +value;
  };

  function float4x4_set_M33 (value) {
    this.Row2.z = +value;
  };

  function float4x4_set_M34 (value) {
    this.Row2.w = +value;
  };

  function float4x4_set_M41 (value) {
    this.Row3.x = +value;
  };

  function float4x4_set_M42 (value) {
    this.Row3.y = +value;
  };

  function float4x4_set_M43 (value) {
    this.Row3.z = +value;
  };

  function float4x4_set_M44 (value) {
    this.Row3.w = +value;
  };

  function float4x4_set_Parse (value) {
    $thisType.float4x4$Parse$value = value;
  };

  function float4x4_Substract (left, right) {
    return $S02().Construct((+left.get_M11() - +right.get_M11()), (+left.get_M12() - +right.get_M12()), (+left.get_M13() - +right.get_M13()), (+left.get_M14() - +right.get_M14()), (+left.get_M21() - +right.get_M21()), (+left.get_M22() - +right.get_M22()), (+left.get_M23() - +right.get_M23()), (+left.get_M24() - +right.get_M24()), (+left.get_M31() - +right.get_M31()), (+left.get_M32() - +right.get_M32()), (+left.get_M33() - +right.get_M33()), (+left.get_M34() - +right.get_M34()), (+left.get_M41() - +right.get_M41()), (+left.get_M42() - +right.get_M42()), (+left.get_M43() - +right.get_M43()), (+left.get_M44() - +right.get_M44()));
  };

  function float4x4_ToArray () {
    return JSIL.Array.New($T01(), [this.get_M11(), this.get_M12(), this.get_M13(), this.get_M14(), this.get_M21(), this.get_M22(), this.get_M23(), this.get_M24(), this.get_M31(), this.get_M32(), this.get_M33(), this.get_M34(), this.get_M41(), this.get_M42(), this.get_M43(), this.get_M44()]);
  };

  function float4x4_toString () {
    return $T0A().Format("{0}\n{1}\n{2}\n{3}", JSIL.Array.New($T07(), [this.Row0, this.Row1, this.Row2, this.Row3]));
  };

  function float4x4_Transform (matrix, vector) {
    return $S01().Construct(((((+matrix.get_M11() * +vector.x) + (+matrix.get_M12() * +vector.y)) + (+matrix.get_M13() * +vector.z)) + (+matrix.get_M14() * +vector.w)), ((((+matrix.get_M21() * +vector.x) + (+matrix.get_M22() * +vector.y)) + (+matrix.get_M23() * +vector.z)) + (+matrix.get_M24() * +vector.w)), ((((+matrix.get_M31() * +vector.x) + (+matrix.get_M32() * +vector.y)) + (+matrix.get_M33() * +vector.z)) + (+matrix.get_M34() * +vector.w)), ((((+matrix.get_M41() * +vector.x) + (+matrix.get_M42() * +vector.y)) + (+matrix.get_M43() * +vector.z)) + (+matrix.get_M44() * +vector.w)));
  };

  function float4x4_TransformPD (matrix, vector) {
    var num = (((+matrix.get_M41() * +vector.x) + (+matrix.get_M42() * +vector.y)) + (+matrix.get_M43() * +vector.z)) + +matrix.get_M44();
    return $S05().Construct(+((((((+matrix.get_M11() * +vector.x) + (+matrix.get_M12() * +vector.y)) + (+matrix.get_M13() * +vector.z)) + +matrix.get_M14()) / num)), +((((((+matrix.get_M21() * +vector.x) + (+matrix.get_M22() * +vector.y)) + (+matrix.get_M23() * +vector.z)) + +matrix.get_M24()) / num)), +((((((+matrix.get_M31() * +vector.x) + (+matrix.get_M32() * +vector.y)) + (+matrix.get_M33() * +vector.z)) + +matrix.get_M34()) / num)));
  };

  function float4x4_TransformPremult (vector, matrix) {
    return $S01().Construct(((((+matrix.get_M11() * +vector.x) + (+matrix.get_M21() * +vector.y)) + (+matrix.get_M31() * +vector.z)) + (+matrix.get_M41() * +vector.w)), ((((+matrix.get_M12() * +vector.x) + (+matrix.get_M22() * +vector.y)) + (+matrix.get_M32() * +vector.z)) + (+matrix.get_M42() * +vector.w)), ((((+matrix.get_M13() * +vector.x) + (+matrix.get_M23() * +vector.y)) + (+matrix.get_M33() * +vector.z)) + (+matrix.get_M43() * +vector.w)), ((((+matrix.get_M14() * +vector.x) + (+matrix.get_M24() * +vector.y)) + (+matrix.get_M34() * +vector.z)) + (+matrix.get_M44() * +vector.w)));
  };

  function float4x4_TransformPremultPD (vector, matrix) {
    var num = (((+matrix.get_M14() * +vector.x) + (+matrix.get_M24() * +vector.y)) + (+matrix.get_M34() * +vector.z)) + +matrix.get_M44();
    return $S05().Construct(+((((((+matrix.get_M11() * +vector.x) + (+matrix.get_M21() * +vector.y)) + (+matrix.get_M31() * +vector.z)) + +matrix.get_M41()) / num)), +((((((+matrix.get_M12() * +vector.x) + (+matrix.get_M22() * +vector.y)) + (+matrix.get_M32() * +vector.z)) + +matrix.get_M42()) / num)), +((((((+matrix.get_M13() * +vector.x) + (+matrix.get_M23() * +vector.y)) + (+matrix.get_M33() * +vector.z)) + +matrix.get_M43()) / num)));
  };

  function float4x4_Transpose$38 () {
    JSIL.CopyMembers($thisType.Transpose(this), this);
  };

  function float4x4_Transpose$39 (mat) {
    return $S00().Construct(mat.get_Column0().MemberwiseClone(), mat.get_Column1().MemberwiseClone(), mat.get_Column2().MemberwiseClone(), mat.get_Column3().MemberwiseClone());
  };

  function float4x4_Transpose$3A (/* ref */ mat, /* ref */ result) {
    result.get().Row0 = (mat.get()).get_Column0().MemberwiseClone();
    result.get().Row1 = (mat.get()).get_Column1().MemberwiseClone();
    result.get().Row2 = (mat.get()).get_Column2().MemberwiseClone();
    result.get().Row3 = (mat.get()).get_Column3().MemberwiseClone();
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.float4x4", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 16, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm04.TypeRef("Fusee.Math.float4"), $asm04.TypeRef("Fusee.Math.float4"), 
          $asm04.TypeRef("Fusee.Math.float4"), $asm04.TypeRef("Fusee.Math.float4")
        ]), 
      float4x4__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single
        ]), 
      float4x4__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.double4x4")), 
      float4x4__ctor$02
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4x4_Add
    );

    $.Method({Static:true , Public:true }, "CreateFromAxisAngle", 
      new JSIL.MethodSignature(null, [
          $asm04.TypeRef("Fusee.Math.float3"), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_CreateFromAxisAngle$03
    );

    $.Method({Static:true , Public:true }, "CreateFromAxisAngle", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.float3"), $.Single]), 
      float4x4_CreateFromAxisAngle$04
    );

    $.Method({Static:true , Public:true }, "CreateOrthographic", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_CreateOrthographic$05
    );

    $.Method({Static:true , Public:true }, "CreateOrthographic", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single, $.Single
        ]), 
      float4x4_CreateOrthographic$06
    );

    $.Method({Static:true , Public:true }, "CreateOrthographicOffCenter", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_CreateOrthographicOffCenter$07
    );

    $.Method({Static:true , Public:true }, "CreateOrthographicOffCenter", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single
        ]), 
      float4x4_CreateOrthographicOffCenter$08
    );

    $.Method({Static:true , Public:true }, "CreateOrthographicOffCenterRH", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_CreateOrthographicOffCenterRH
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveFieldOfView", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_CreatePerspectiveFieldOfView$09
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveFieldOfView", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single, $.Single
        ]), 
      float4x4_CreatePerspectiveFieldOfView$0A
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveFieldOfView_ROW", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_CreatePerspectiveFieldOfView_ROW$0B
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreatePerspectiveFieldOfView_ROW", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single, $.Single
        ]), 
      float4x4_CreatePerspectiveFieldOfView_ROW$0C
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreatePerspectiveOffCenter", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_CreatePerspectiveOffCenter$0D
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveOffCenter", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single
        ]), 
      float4x4_CreatePerspectiveOffCenter$0E
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveOffCenter_ROW", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_CreatePerspectiveOffCenter_ROW
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreatePerspectiveOffCenterRH", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_CreatePerspectiveOffCenterRH
    );

    $.Method({Static:true , Public:true }, "CreateRotationX", 
      new JSIL.MethodSignature(null, [$.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float4x4_CreateRotationX$0F
    );

    $.Method({Static:true , Public:true }, "CreateRotationX", 
      new JSIL.MethodSignature($.Type, [$.Single]), 
      float4x4_CreateRotationX$10
    );

    $.Method({Static:true , Public:true }, "CreateRotationX_ROW", 
      new JSIL.MethodSignature(null, [$.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float4x4_CreateRotationX_ROW$11
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateRotationX_ROW", 
      new JSIL.MethodSignature($.Type, [$.Single]), 
      float4x4_CreateRotationX_ROW$12
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateRotationY", 
      new JSIL.MethodSignature(null, [$.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float4x4_CreateRotationY$13
    );

    $.Method({Static:true , Public:true }, "CreateRotationY", 
      new JSIL.MethodSignature($.Type, [$.Single]), 
      float4x4_CreateRotationY$14
    );

    $.Method({Static:true , Public:true }, "CreateRotationY_ROW", 
      new JSIL.MethodSignature(null, [$.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float4x4_CreateRotationY_ROW$15
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateRotationY_ROW", 
      new JSIL.MethodSignature($.Type, [$.Single]), 
      float4x4_CreateRotationY_ROW$16
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateRotationZ", 
      new JSIL.MethodSignature(null, [$.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float4x4_CreateRotationZ$17
    );

    $.Method({Static:true , Public:true }, "CreateRotationZ", 
      new JSIL.MethodSignature($.Type, [$.Single]), 
      float4x4_CreateRotationZ$18
    );

    $.Method({Static:true , Public:true }, "CreateScale", 
      new JSIL.MethodSignature(null, [$.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float4x4_CreateScale$19
    );

    $.Method({Static:true , Public:true }, "CreateScale", 
      new JSIL.MethodSignature($.Type, [$.Single]), 
      float4x4_CreateScale$1A
    );

    $.Method({Static:true , Public:true }, "CreateScale", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_CreateScale$1B
    );

    $.Method({Static:true , Public:true }, "CreateScale", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float4x4_CreateScale$1C
    );

    $.Method({Static:true , Public:true }, "CreateScale", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single
        ]), 
      float4x4_CreateScale$1D
    );

    $.Method({Static:true , Public:true }, "CreateScale", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.float3")]), 
      float4x4_CreateScale$1E
    );

    $.Method({Static:true , Public:true }, "CreateTranslation", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_CreateTranslation$1F
    );

    $.Method({Static:true , Public:true }, "CreateTranslation", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float4x4_CreateTranslation$20
    );

    $.Method({Static:true , Public:true }, "CreateTranslation", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single
        ]), 
      float4x4_CreateTranslation$21
    );

    $.Method({Static:true , Public:true }, "CreateTranslation", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.float3")]), 
      float4x4_CreateTranslation$22
    );

    $.Method({Static:true , Public:true }, "CreateTranslation_ROW", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_CreateTranslation_ROW$23
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateTranslation_ROW", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single
        ]), 
      float4x4_CreateTranslation_ROW$24
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      float4x4_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type]), 
      float4x4_Equals$25
    );

    $.Method({Static:false, Public:true }, "get_Column0", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.float4")), 
      float4x4_get_Column0
    );

    $.Method({Static:false, Public:true }, "get_Column1", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.float4")), 
      float4x4_get_Column1
    );

    $.Method({Static:false, Public:true }, "get_Column2", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.float4")), 
      float4x4_get_Column2
    );

    $.Method({Static:false, Public:true }, "get_Column3", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.float4")), 
      float4x4_get_Column3
    );

    $.Method({Static:false, Public:true }, "get_Determinant", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_Determinant
    );

    $.Method({Static:false, Public:true }, "get_IsAffine", 
      JSIL.MethodSignature.Return($.Boolean), 
      float4x4_get_IsAffine
    );

    $.Method({Static:false, Public:true }, "get_M11", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M11
    );

    $.Method({Static:false, Public:true }, "get_M12", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M12
    );

    $.Method({Static:false, Public:true }, "get_M13", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M13
    );

    $.Method({Static:false, Public:true }, "get_M14", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M14
    );

    $.Method({Static:false, Public:true }, "get_M21", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M21
    );

    $.Method({Static:false, Public:true }, "get_M22", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M22
    );

    $.Method({Static:false, Public:true }, "get_M23", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M23
    );

    $.Method({Static:false, Public:true }, "get_M24", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M24
    );

    $.Method({Static:false, Public:true }, "get_M31", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M31
    );

    $.Method({Static:false, Public:true }, "get_M32", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M32
    );

    $.Method({Static:false, Public:true }, "get_M33", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M33
    );

    $.Method({Static:false, Public:true }, "get_M34", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M34
    );

    $.Method({Static:false, Public:true }, "get_M41", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M41
    );

    $.Method({Static:false, Public:true }, "get_M42", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M42
    );

    $.Method({Static:false, Public:true }, "get_M43", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M43
    );

    $.Method({Static:false, Public:true }, "get_M44", 
      JSIL.MethodSignature.Return($.Single), 
      float4x4_get_M44
    );

    $.Method({Static:false, Public:true }, "get_Offset", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.float3")), 
      float4x4_get_Offset
    );

    $.Method({Static:true , Public:true }, "get_Parse", 
      JSIL.MethodSignature.Return($asm07.TypeRef("System.Converter`2", [$.String, $.Type])), 
      float4x4_get_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32), 
      float4x4_GetHashCode
    );

    $.Method({Static:false, Public:true }, "Invert", 
      JSIL.MethodSignature.Void, 
      float4x4_Invert$26
    );

    $.Method({Static:true , Public:true }, "Invert", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float4x4_Invert$27
    );

    $.Method({Static:true , Public:true }, "InvertAffine", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float4x4_InvertAffine
    );

    $.Method({Static:true , Public:true }, "LookAt", 
      new JSIL.MethodSignature($.Type, [
          $asm04.TypeRef("Fusee.Math.float3"), $asm04.TypeRef("Fusee.Math.float3"), 
          $asm04.TypeRef("Fusee.Math.float3")
        ]), 
      float4x4_LookAt$28
    );

    $.Method({Static:true , Public:true }, "LookAt", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single
        ]), 
      float4x4_LookAt$29
    );

    $.Method({Static:true , Public:true }, "LookAt_ROW", 
      new JSIL.MethodSignature($.Type, [
          $asm04.TypeRef("Fusee.Math.float3"), $asm04.TypeRef("Fusee.Math.float3"), 
          $asm04.TypeRef("Fusee.Math.float3")
        ]), 
      float4x4_LookAt_ROW$2A
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "LookAt_ROW", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single
        ]), 
      float4x4_LookAt_ROW$2B
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "LookAtRH", 
      new JSIL.MethodSignature($.Type, [
          $asm04.TypeRef("Fusee.Math.float3"), $asm04.TypeRef("Fusee.Math.float3"), 
          $asm04.TypeRef("Fusee.Math.float3")
        ]), 
      float4x4_LookAtRH
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4x4_Mult$2C
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_Mult$2D
    );

    $.Method({Static:true , Public:true }, "MultAffine", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      float4x4_MultAffine
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4x4_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      float4x4_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Explicit", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.double4x4")]), 
      float4x4_op_Explicit
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      float4x4_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4x4_op_Multiply$2E
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float4"), [$.Type, $asm04.TypeRef("Fusee.Math.float4")]), 
      float4x4_op_Multiply$2F
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float4"), [$asm04.TypeRef("Fusee.Math.float4"), $.Type]), 
      float4x4_op_Multiply$30
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$.Type, $asm04.TypeRef("Fusee.Math.float3")]), 
      float4x4_op_Multiply$31
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$asm04.TypeRef("Fusee.Math.float3"), $.Type]), 
      float4x4_op_Multiply$32
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4x4_op_Subtraction
    );

    $.Method({Static:false, Public:true }, "Round", 
      JSIL.MethodSignature.Void, 
      float4x4_Round$33
    );

    $.Method({Static:true , Public:true }, "Round", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float4x4_Round$34
    );

    $.Method({Static:true , Public:true }, "Scale", 
      new JSIL.MethodSignature($.Type, [$.Single]), 
      float4x4_Scale$35
    );

    $.Method({Static:true , Public:true }, "Scale", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.float3")]), 
      float4x4_Scale$36
    );

    $.Method({Static:true , Public:true }, "Scale", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single
        ]), 
      float4x4_Scale$37
    );

    $.Method({Static:false, Public:true }, "set_M11", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M11
    );

    $.Method({Static:false, Public:true }, "set_M12", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M12
    );

    $.Method({Static:false, Public:true }, "set_M13", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M13
    );

    $.Method({Static:false, Public:true }, "set_M14", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M14
    );

    $.Method({Static:false, Public:true }, "set_M21", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M21
    );

    $.Method({Static:false, Public:true }, "set_M22", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M22
    );

    $.Method({Static:false, Public:true }, "set_M23", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M23
    );

    $.Method({Static:false, Public:true }, "set_M24", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M24
    );

    $.Method({Static:false, Public:true }, "set_M31", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M31
    );

    $.Method({Static:false, Public:true }, "set_M32", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M32
    );

    $.Method({Static:false, Public:true }, "set_M33", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M33
    );

    $.Method({Static:false, Public:true }, "set_M34", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M34
    );

    $.Method({Static:false, Public:true }, "set_M41", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M41
    );

    $.Method({Static:false, Public:true }, "set_M42", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M42
    );

    $.Method({Static:false, Public:true }, "set_M43", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M43
    );

    $.Method({Static:false, Public:true }, "set_M44", 
      JSIL.MethodSignature.Action($.Single), 
      float4x4_set_M44
    );

    $.Method({Static:true , Public:true }, "set_Parse", 
      JSIL.MethodSignature.Action($asm07.TypeRef("System.Converter`2", [$.String, $.Type])), 
      float4x4_set_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:true , Public:true }, "Substract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      float4x4_Substract
    );

    $.Method({Static:false, Public:false}, "ToArray", 
      JSIL.MethodSignature.Return($jsilcore.TypeRef("System.Array", [$.Single])), 
      float4x4_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      float4x4_toString
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float4"), [$.Type, $asm04.TypeRef("Fusee.Math.float4")]), 
      float4x4_Transform
    );

    $.Method({Static:true , Public:true }, "TransformPD", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$.Type, $asm04.TypeRef("Fusee.Math.float3")]), 
      float4x4_TransformPD
    );

    $.Method({Static:true , Public:true }, "TransformPremult", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float4"), [$asm04.TypeRef("Fusee.Math.float4"), $.Type]), 
      float4x4_TransformPremult
    );

    $.Method({Static:true , Public:true }, "TransformPremultPD", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$asm04.TypeRef("Fusee.Math.float3"), $.Type]), 
      float4x4_TransformPremultPD
    );

    $.Method({Static:false, Public:true }, "Transpose", 
      JSIL.MethodSignature.Void, 
      float4x4_Transpose$38
    );

    $.Method({Static:true , Public:true }, "Transpose", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      float4x4_Transpose$39
    );

    $.Method({Static:true , Public:true }, "Transpose", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      float4x4_Transpose$3A
    );

    $.Field({Static:false, Public:true }, "Row0", $asm04.TypeRef("Fusee.Math.float4"))
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [1]; }); 
    $.Field({Static:false, Public:true }, "Row1", $asm04.TypeRef("Fusee.Math.float4"))
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [2]; }); 
    $.Field({Static:false, Public:true }, "Row2", $asm04.TypeRef("Fusee.Math.float4"))
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [3]; }); 
    $.Field({Static:false, Public:true }, "Row3", $asm04.TypeRef("Fusee.Math.float4"))
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [4]; }); 
    $.Field({Static:true , Public:true }, "Identity", $.Type); 
    $.Field({Static:true , Public:true }, "Zero", $.Type); 
    $.Field({Static:true , Public:false}, "float4x4$Parse$value", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]))
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    function float4x4__cctor () {
      $thisType.Identity = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.Identity = $S00().Construct($T00().UnitX.MemberwiseClone(), $T00().UnitY.MemberwiseClone(), $T00().UnitZ.MemberwiseClone(), $T00().UnitW.MemberwiseClone());
      $thisType.Zero = $S00().Construct($T00().Zero.MemberwiseClone(), $T00().Zero.MemberwiseClone(), $T00().Zero.MemberwiseClone(), $T00().Zero.MemberwiseClone());
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      float4x4__cctor
    );

    $.Property({Static:false, Public:true }, "Determinant", $.Single);

    $.Property({Static:false, Public:true }, "Column0", $asm04.TypeRef("Fusee.Math.float4"));

    $.Property({Static:false, Public:true }, "Column1", $asm04.TypeRef("Fusee.Math.float4"));

    $.Property({Static:false, Public:true }, "Column2", $asm04.TypeRef("Fusee.Math.float4"));

    $.Property({Static:false, Public:true }, "Column3", $asm04.TypeRef("Fusee.Math.float4"));

    $.Property({Static:false, Public:true }, "M11", $.Single);

    $.Property({Static:false, Public:true }, "M12", $.Single);

    $.Property({Static:false, Public:true }, "M13", $.Single);

    $.Property({Static:false, Public:true }, "M14", $.Single);

    $.Property({Static:false, Public:true }, "M21", $.Single);

    $.Property({Static:false, Public:true }, "M22", $.Single);

    $.Property({Static:false, Public:true }, "M23", $.Single);

    $.Property({Static:false, Public:true }, "M24", $.Single);

    $.Property({Static:false, Public:true }, "M31", $.Single);

    $.Property({Static:false, Public:true }, "M32", $.Single);

    $.Property({Static:false, Public:true }, "M33", $.Single);

    $.Property({Static:false, Public:true }, "M34", $.Single);

    $.Property({Static:false, Public:true }, "M41", $.Single);

    $.Property({Static:false, Public:true }, "M42", $.Single);

    $.Property({Static:false, Public:true }, "M43", $.Single);

    $.Property({Static:false, Public:true }, "M44", $.Single);

    $.Property({Static:false, Public:true }, "Offset", $asm04.TypeRef("Fusee.Math.float3"));

    $.Property({Static:false, Public:true }, "IsAffine", $.Boolean);

    $.Property({Static:true , Public:true }, "Parse", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]));

    $.ImplementInterfaces(
      /* 0 */ $asm07.TypeRef("System.IEquatable`1", [$.Type])
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm08.TypeRef("ProtoBuf.ProtoContractAttribute"));

})();

/* class Fusee.Math.NamespaceDoc */ 

(function NamespaceDoc$Members () {
  var $, $thisType;
  function NamespaceDoc__ctor () {
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.Object"), 
      Name: "Fusee.Math.NamespaceDoc", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      NamespaceDoc__ctor
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Math.M */ 

(function M$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm07.System.Type)) ();
  };

  function M_Saturate$b1 (T, val, lower, upper) {
    var $im00 = $asm07.System.IComparable$b1.Of(T).CompareTo;
    return (
      (($im00.Call(lower, null, JSIL.CloneParameter(T, val)) | 0) < 0)
         ? (
          (($im00.Call(val, null, JSIL.CloneParameter(T, upper)) | 0) < 0)
             ? val
             : upper)

         : lower)
    ;
  };

  JSIL.MakeStaticClass("Fusee.Math.M", true, [], function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:true , Public:true }, "Saturate", 
      new JSIL.MethodSignature("!!0", [
          "!!0", "!!0", 
          "!!0"
        ], ["T"]), 
      M_Saturate$b1
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Math.QuaternionD */ 

(function QuaternionD$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Math.double3)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm07.System.Double)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm07.System.Object)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.System.Math)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm04.Fusee.Math.double4)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm07.System.String)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.QuaternionD"), [
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double3"), [
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double")
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.QuaternionD"), [$asm04.TypeRef("Fusee.Math.double3"), $asm07.TypeRef("System.Double")]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double3"), [$asm04.TypeRef("Fusee.Math.double3"), $asm07.TypeRef("System.Double")]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double3"), [$asm07.TypeRef("System.Double"), $asm04.TypeRef("Fusee.Math.double3")]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")])
      ]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")]), $asm07.TypeRef("System.Double"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")])
      ]))) ();
  };

  function QuaternionD__ctor$00 (v, w) {
    this._xyz = v.MemberwiseClone();
    this._w = +w;
  };

  function QuaternionD__ctor$01 (xx, yy, zz, w) {
    $thisType.prototype._ctor.call(this, $S01().Construct(xx, yy, zz), w);
  };

  function QuaternionD_Add$02 (left, right) {
    return $S02().Construct($T00().op_Addition(
        left.get_xyz().MemberwiseClone(), 
        right.get_xyz()
      ).MemberwiseClone(), (+left.get_w() + +right.get_w()));
  };

  function QuaternionD_Add$03 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct($T00().op_Addition(
          (left.get()).get_xyz().MemberwiseClone(), 
          (right.get()).get_xyz()
        ).MemberwiseClone(), (+(left.get()).get_w() + +(right.get()).get_w())));
  };

  function QuaternionD_Conjugate$04 () {
    (this.xyz = $T00().op_UnaryNegation(this.xyz.MemberwiseClone()));
  };

  function QuaternionD_Conjugate$05 (q) {
    return $S02().Construct($T00().op_UnaryNegation(q.get_xyz().MemberwiseClone()).MemberwiseClone(), q.get_w());
  };

  function QuaternionD_Conjugate$06 (/* ref */ q, /* ref */ result) {
    result.set($S02().Construct($T00().op_UnaryNegation((q.get()).get_xyz().MemberwiseClone()).MemberwiseClone(), (q.get()).get_w()));
  };

  function QuaternionD_Object_Equals (other) {
    return ($thisType.$Is(other) && $thisType.op_Equality(this, $thisType.$Cast(other).MemberwiseClone()));
  };

  function QuaternionD_Equals$07 (other) {
    return ($T00().op_Equality(
        this.get_xyz(), 
        other.get_xyz()
      ) && ((Math.abs((+this.get_w() - +other.get_w()))) < 1.11022302462516E-16));
  };

  function QuaternionD_FromAxisAngle (axis, angle) {
    if (+axis.get_LengthSquared() > 1.11022302462516E-16) {
      var result = $thisType.Identity.MemberwiseClone();
    } else {
      var identity = $thisType.Identity.MemberwiseClone();
      angle *= 0.5;
      axis.Normalize();
      (identity.xyz = $S03().CallStatic($T00(), "op_Multiply", null, axis.MemberwiseClone(), Math.sin(angle)));
      identity.set_w(Math.cos(angle));
      result = $thisType.Normalize(identity.MemberwiseClone()).MemberwiseClone();
    }
    return result;
  };

  function QuaternionD_get_Length () {
    return Math.sqrt(((+this.get_w() * +this.get_w()) + +(this.get_xyz()).get_LengthSquared()));
  };

  function QuaternionD_get_LengthSquared () {
    return ((+this.get_w() * +this.get_w()) + +(this.get_xyz()).get_LengthSquared());
  };

  function QuaternionD_get_w () {
    return this._w;
  };

  function QuaternionD_get_x () {
    return this._xyz.x;
  };

  function QuaternionD_get_xyz () {
    return this._xyz;
  };

  function QuaternionD_get_y () {
    return this._xyz.y;
  };

  function QuaternionD_get_z () {
    return this._xyz.z;
  };

  function QuaternionD_GetHashCode () {
    return (((this.get_xyz().MemberwiseClone()).GetHashCode() | 0) ^ ((this.get_w()).GetHashCode() | 0));
  };

  function QuaternionD_Invert$08 ($q) {
    var q = new JSIL.BoxedVariable($q.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.Invert(/* ref */ q, /* ref */ result);
    return result.get();
  };

  function QuaternionD_Invert$09 (/* ref */ q, /* ref */ result) {
    var lengthSquared = +(q.get()).get_LengthSquared();
    if (lengthSquared > 1.11022302462516E-16) {
      var num = +((1 / lengthSquared));
      result.set($S02().Construct($S03().CallStatic($T00(), "op_Multiply", null, (q.get()).get_xyz().MemberwiseClone(), -num).MemberwiseClone(), (+(q.get()).get_w() * num)));
    } else {
      result.set(q.get().MemberwiseClone());
    }
  };

  function QuaternionD_Mult$0A (left, right) {
    return $S02().Construct($T00().op_Addition(
        $T00().op_Addition(
          $S04().CallStatic($T00(), "op_Multiply", null, 
            right.get_w(), 
            left.get_xyz().MemberwiseClone()
          ).MemberwiseClone(), 
          $S04().CallStatic($T00(), "op_Multiply", null, 
            left.get_w(), 
            right.get_xyz().MemberwiseClone()
          )
        ).MemberwiseClone(), 
        $T00().Cross(
          left.get_xyz().MemberwiseClone(), 
          right.get_xyz().MemberwiseClone()
        )
      ).MemberwiseClone(), ((+left.get_w() * +right.get_w()) - +$T00().Dot(
          left.get_xyz(), 
          right.get_xyz()
        )));
  };

  function QuaternionD_Mult$0B (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct($T00().op_Addition(
          $T00().op_Addition(
            $S04().CallStatic($T00(), "op_Multiply", null, 
              (right.get()).get_w(), 
              (left.get()).get_xyz().MemberwiseClone()
            ).MemberwiseClone(), 
            $S04().CallStatic($T00(), "op_Multiply", null, 
              (left.get()).get_w(), 
              (right.get()).get_xyz().MemberwiseClone()
            )
          ).MemberwiseClone(), 
          $T00().Cross(
            (left.get()).get_xyz().MemberwiseClone(), 
            (right.get()).get_xyz().MemberwiseClone()
          )
        ).MemberwiseClone(), ((+(left.get()).get_w() * +(right.get()).get_w()) - +$T00().Dot(
            (left.get()).get_xyz(), 
            (right.get()).get_xyz()
          ))));
  };

  function QuaternionD_Multiply$0C ($left, $right) {
    var right = new JSIL.BoxedVariable($right.MemberwiseClone());
    var left = new JSIL.BoxedVariable($left.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $S05().CallStatic($thisType, "Multiply", null, /* ref */ left, /* ref */ right, /* ref */ result);
    return result.get();
  };

  function QuaternionD_Multiply$0D (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S00().Construct(((((+(left.get()).get_w() * +(right.get()).get_x()) + (+(left.get()).get_x() * +(right.get()).get_w())) + (+(left.get()).get_y() * +(right.get()).get_z())) - (+(left.get()).get_z() * +(right.get()).get_y())), ((((+(left.get()).get_w() * +(right.get()).get_y()) + (+(left.get()).get_y() * +(right.get()).get_w())) + (+(left.get()).get_z() * +(right.get()).get_x())) - (+(left.get()).get_x() * +(right.get()).get_z())), ((((+(left.get()).get_w() * +(right.get()).get_z()) + (+(left.get()).get_z() * +(right.get()).get_w())) + (+(left.get()).get_x() * +(right.get()).get_y())) - (+(left.get()).get_y() * +(right.get()).get_x())), ((((+(left.get()).get_w() * +(right.get()).get_w()) - (+(left.get()).get_x() * +(right.get()).get_x())) - (+(left.get()).get_y() * +(right.get()).get_y())) - (+(left.get()).get_z() * +(right.get()).get_z()))));
  };

  function QuaternionD_Multiply$0E (/* ref */ quaternionD, scale, /* ref */ result) {
    result.set($S00().Construct((+(quaternionD.get()).get_x() * +scale), (+(quaternionD.get()).get_y() * +scale), (+(quaternionD.get()).get_z() * +scale), (+(quaternionD.get()).get_w() * +scale)));
  };

  function QuaternionD_Multiply$0F (quaternionD, scale) {
    return $S00().Construct((+quaternionD.get_x() * +scale), (+quaternionD.get_y() * +scale), (+quaternionD.get_z() * +scale), (+quaternionD.get_w() * +scale));
  };

  function QuaternionD_Normalize$10 () {
    var $temp00;
    if (+this.get_Length() > 1.11022302462516E-16) {
      var num = +((1 / +this.get_Length()));
      (this.xyz = $S03().CallStatic($T00(), "op_Multiply", null, this.xyz.MemberwiseClone(), num));
      ($temp00 = +this.get_w() * num, 
        this.set_w($temp00), 
        $temp00);
    }
  };

  function QuaternionD_Normalize$11 ($q) {
    var q = new JSIL.BoxedVariable($q);
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.Normalize(/* ref */ q, /* ref */ result);
    return result.get();
  };

  function QuaternionD_Normalize$12 (/* ref */ q, /* ref */ result) {
    if (+(q.get()).get_Length() <= 1.1920930376163597E-07) {
      var num = 0;
    } else {
      num = +((1 / +(q.get()).get_Length()));
    }
    result.set($S02().Construct($S03().CallStatic($T00(), "op_Multiply", null, (q.get()).get_xyz().MemberwiseClone(), num).MemberwiseClone(), (+(q.get()).get_w() * num)));
  };

  function QuaternionD_op_Addition (left, right) {
    var $temp00;
    (left.xyz = $T00().op_Addition(left.xyz.MemberwiseClone(), right.get_xyz()));
    ($temp00 = +left.get_w() + +right.get_w(), 
      left.set_w($temp00), 
      $temp00);
    return left;
  };

  function QuaternionD_op_Equality (left, right) {
    return left.Equals(right.MemberwiseClone());
  };

  function QuaternionD_op_Inequality (left, right) {
    return !left.Equals(right.MemberwiseClone());
  };

  function QuaternionD_op_Multiply$13 ($left, $right) {
    var right = new JSIL.BoxedVariable($right.MemberwiseClone());
    var left = new JSIL.BoxedVariable($left.MemberwiseClone());
    $S05().CallStatic($thisType, "Multiply", null, /* ref */ left, /* ref */ right, /* ref */ left);
    return left.get();
  };

  function QuaternionD_op_Multiply$14 ($quaternionD, scale) {
    var quaternionD = new JSIL.BoxedVariable($quaternionD.MemberwiseClone());
    $S06().CallStatic($thisType, "Multiply", null, /* ref */ quaternionD, scale, /* ref */ quaternionD);
    return quaternionD.get();
  };

  function QuaternionD_op_Multiply$15 (scale, quaternionD) {
    return $S00().Construct((+quaternionD.get_x() * +scale), (+quaternionD.get_y() * +scale), (+quaternionD.get_z() * +scale), (+quaternionD.get_w() * +scale));
  };

  function QuaternionD_op_Subtraction (left, right) {
    var $temp00;
    (left.xyz = $T00().op_Subtraction(left.xyz.MemberwiseClone(), right.get_xyz()));
    ($temp00 = +left.get_w() - +right.get_w(), 
      left.set_w($temp00), 
      $temp00);
    return left;
  };

  function QuaternionD_set_w (value) {
    this._w = +value;
  };

  function QuaternionD_set_x (value) {
    this._xyz.x = +value;
  };

  function QuaternionD_set_xyz (value) {
    this._xyz = value.MemberwiseClone();
  };

  function QuaternionD_set_y (value) {
    this._xyz.y = +value;
  };

  function QuaternionD_set_z (value) {
    this._xyz.z = +value;
  };

  function QuaternionD_Slerp (q1, q2, blend) {
    var q3 = new $thisType();
    if (+q1.get_LengthSquared() < 1.11022302462516E-16) {
      var result = (
        (+q2.get_LengthSquared() <= 1.1920930376163597E-07)
           ? $thisType.Identity
           : q2)
      .MemberwiseClone();
    } else if (+q2.get_LengthSquared() < 1.11022302462516E-16) {
      result = q1.MemberwiseClone();
    } else {
      var num = (+q1.get_w() * +q2.get_w()) + +$T00().Dot(
        q1.get_xyz(), 
        q2.get_xyz()
      );
      if (!((num < 1) && (num > -1))) {
        result = q1.MemberwiseClone();
      } else {
        if (num < 0) {
          (q2.xyz = $T00().op_UnaryNegation(q2.xyz.MemberwiseClone()));
          q2.set_w(-q2.get_w());
          num = -num;
        }
        if (num < 0.99000000953674316) {
          var num2 = (Math.acos(num));
          var num3 = (Math.sin(num2));
          var num4 = +((1 / num3));
          var num5 = (Math.sin((num2 * (1 - +blend)))) * num4;
          var num6 = (Math.sin((num2 * +blend))) * num4;
        } else {
          num5 = 1 - +blend;
          num6 = +blend;
        }
        $thisType.prototype._ctor.call(q3, 
          $T00().op_Addition(
            $S04().CallStatic($T00(), "op_Multiply", null, num5, q1.get_xyz().MemberwiseClone()).MemberwiseClone(), 
            $S04().CallStatic($T00(), "op_Multiply", null, num6, q2.get_xyz().MemberwiseClone())
          ).MemberwiseClone(), 
          (num5 * +q1.get_w()) + (num6 * +q2.get_w())
        );
        result = (
          (+q3.get_LengthSquared() > 1.11022302462516E-16)
             ? $thisType.Normalize(q3.MemberwiseClone())
             : $thisType.Identity)
        .MemberwiseClone();
      }
    }
    return result;
  };

  function QuaternionD_Sub$16 (left, right) {
    return $S02().Construct($T00().op_Subtraction(
        left.get_xyz().MemberwiseClone(), 
        right.get_xyz()
      ).MemberwiseClone(), (+left.get_w() - +right.get_w()));
  };

  function QuaternionD_Sub$17 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct($T00().op_Subtraction(
          (left.get()).get_xyz().MemberwiseClone(), 
          (right.get()).get_xyz()
        ).MemberwiseClone(), (+(left.get()).get_w() - +(right.get()).get_w())));
  };

  function QuaternionD_ToAxisAngle$18 (/* ref */ axis, /* ref */ angle) {
    var double = this.ToAxisAngle();
    axis.set(double.get_xyz().MemberwiseClone());
    angle.set(double.w);
  };

  function QuaternionD_ToAxisAngle$19 () {
    var quaternionD = this;
    if (+quaternionD.get_w() > 1) {
      quaternionD.Normalize();
    }
    var double = new ($T04())();
    double.w = 2 * (Math.acos(quaternionD.get_w()));
    var result = double;
    var num = (Math.sqrt((1 - (+quaternionD.get_w() * +quaternionD.get_w()))));
    if (num > 1.11022302462516E-16) {
      (result.xyz = $T00().op_Division(quaternionD.get_xyz().MemberwiseClone(), num));
    } else {
      (result.xyz = $T00().UnitX.MemberwiseClone());
    }
    return result;
  };

  function QuaternionD_toString () {
    return $T05().Format(
      "V: {0}, w: {1}", 
      this.get_xyz(), 
      this.get_w()
    );
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.QuaternionD", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 4, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.double3"), $.Double]), 
      QuaternionD__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double
        ]), 
      QuaternionD__ctor$01
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      QuaternionD_Add$02
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      QuaternionD_Add$03
    );

    $.Method({Static:false, Public:true }, "Conjugate", 
      JSIL.MethodSignature.Void, 
      QuaternionD_Conjugate$04
    );

    $.Method({Static:true , Public:true }, "Conjugate", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      QuaternionD_Conjugate$05
    );

    $.Method({Static:true , Public:true }, "Conjugate", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      QuaternionD_Conjugate$06
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      QuaternionD_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type]), 
      QuaternionD_Equals$07
    );

    $.Method({Static:true , Public:true }, "FromAxisAngle", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.double3"), $.Double]), 
      QuaternionD_FromAxisAngle
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      JSIL.MethodSignature.Return($.Double), 
      QuaternionD_get_Length
    );

    $.Method({Static:false, Public:true }, "get_LengthSquared", 
      JSIL.MethodSignature.Return($.Double), 
      QuaternionD_get_LengthSquared
    );

    $.Method({Static:false, Public:true }, "get_w", 
      JSIL.MethodSignature.Return($.Double), 
      QuaternionD_get_w
    );

    $.Method({Static:false, Public:true }, "get_x", 
      JSIL.MethodSignature.Return($.Double), 
      QuaternionD_get_x
    );

    $.Method({Static:false, Public:true }, "get_xyz", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.double3")), 
      QuaternionD_get_xyz
    );

    $.Method({Static:false, Public:true }, "get_y", 
      JSIL.MethodSignature.Return($.Double), 
      QuaternionD_get_y
    );

    $.Method({Static:false, Public:true }, "get_z", 
      JSIL.MethodSignature.Return($.Double), 
      QuaternionD_get_z
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32), 
      QuaternionD_GetHashCode
    );

    $.Method({Static:true , Public:true }, "Invert", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      QuaternionD_Invert$08
    );

    $.Method({Static:true , Public:true }, "Invert", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      QuaternionD_Invert$09
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      QuaternionD_Mult$0A
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use Multiply instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      QuaternionD_Mult$0B
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use Multiply instead."]; });

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      QuaternionD_Multiply$0C
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      QuaternionD_Multiply$0D
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      QuaternionD_Multiply$0E
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      QuaternionD_Multiply$0F
    );

    $.Method({Static:false, Public:true }, "Normalize", 
      JSIL.MethodSignature.Void, 
      QuaternionD_Normalize$10
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      QuaternionD_Normalize$11
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      QuaternionD_Normalize$12
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      QuaternionD_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      QuaternionD_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      QuaternionD_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      QuaternionD_op_Multiply$13
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double]), 
      QuaternionD_op_Multiply$14
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Double, $.Type]), 
      QuaternionD_op_Multiply$15
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      QuaternionD_op_Subtraction
    );

    $.Method({Static:false, Public:true }, "set_w", 
      JSIL.MethodSignature.Action($.Double), 
      QuaternionD_set_w
    );

    $.Method({Static:false, Public:true }, "set_x", 
      JSIL.MethodSignature.Action($.Double), 
      QuaternionD_set_x
    );

    $.Method({Static:false, Public:true }, "set_xyz", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.double3")), 
      QuaternionD_set_xyz
    );

    $.Method({Static:false, Public:true }, "set_y", 
      JSIL.MethodSignature.Action($.Double), 
      QuaternionD_set_y
    );

    $.Method({Static:false, Public:true }, "set_z", 
      JSIL.MethodSignature.Action($.Double), 
      QuaternionD_set_z
    );

    $.Method({Static:true , Public:true }, "Slerp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Double
        ]), 
      QuaternionD_Slerp
    );

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      QuaternionD_Sub$16
    );

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      QuaternionD_Sub$17
    );

    $.Method({Static:false, Public:true }, "ToAxisAngle", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")]), $jsilcore.TypeRef("JSIL.Reference", [$.Double])]), 
      QuaternionD_ToAxisAngle$18
    );

    $.Method({Static:false, Public:true }, "ToAxisAngle", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.double4")), 
      QuaternionD_ToAxisAngle$19
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      QuaternionD_toString
    );

    $.Field({Static:false, Public:false}, "_xyz", $asm04.TypeRef("Fusee.Math.double3")); 
    $.Field({Static:false, Public:false}, "_w", $.Double); 
    $.Field({Static:true , Public:true }, "Identity", $.Type); 
    function QuaternionD__cctor () {
      $thisType.Identity = new $thisType();
      $thisType.Identity = $S00().Construct(0, 0, 0, 1);
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      QuaternionD__cctor
    );

    $.Property({Static:false, Public:true }, "xyz", $asm04.TypeRef("Fusee.Math.double3"));

    $.Property({Static:false, Public:true }, "x", $.Double);

    $.Property({Static:false, Public:true }, "y", $.Double);

    $.Property({Static:false, Public:true }, "z", $.Double);

    $.Property({Static:false, Public:true }, "w", $.Double);

    $.Property({Static:false, Public:true }, "Length", $.Double);

    $.Property({Static:false, Public:true }, "LengthSquared", $.Double);

    $.ImplementInterfaces(
      /* 0 */ $asm07.TypeRef("System.IEquatable`1", [$.Type])
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Math.MathHelper */ 

(function MathHelper$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm07.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm07.System.Int64)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm07.System.Double)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.System.Single)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.System.Math)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm04.Fusee.Math.float4)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm07.System.UInt32)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm07.System.ArgumentOutOfRangeException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("System.Single"), [$asm07.TypeRef("System.Single")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("System.ArgumentOutOfRangeException"), [$asm07.TypeRef("System.String"), $asm07.TypeRef("System.String")]))) ();
  };

  function MathHelper__ctor () {
  };

  function MathHelper_BinomialCoefficient (n, k) {
    return $T01().op_Division(
      $thisType.Factorial(n), 
      $T01().op_Multiplication(
        $thisType.Factorial(k), 
        $thisType.Factorial((((n | 0) - (k | 0)) | 0))
      )
    );
  };

  function MathHelper_Clamp$00 (val, min, max) {
    return (
      (+val < +min)
         ? min
         : (
          (+val > +max)
             ? max
             : val)
    )
    ;
  };

  function MathHelper_Clamp$01 (val, min, max) {
    return (
      (+val < +min)
         ? min
         : (
          (+val > +max)
             ? max
             : val)
    )
    ;
  };

  function MathHelper_Cos (val) {
    return Math.fround(Math.cos(val));
  };

  function MathHelper_DegreesToRadians (degrees) {
    return (+degrees * 0.0174532924);
  };

  function MathHelper_Equals$02 (a, b) {
    return ((Math.abs((+a - +b))) < 1.11022302462516E-16);
  };

  function MathHelper_Equals$03 (a, b) {
    return ((Math.abs((+a - +b))) < 1.192093E-07);
  };

  function MathHelper_Factorial (n) {
    var num = $T01().Create(1, 0, 0);

    while ((n | 0) > 1) {
      num = $T01().op_Multiplication(num, $T01().FromNumber(n));
      n = (((n | 0) - 1) | 0);
    }
    return num;
  };

  function MathHelper_Float4ToABGR (value) {
    var num = ((255 * +value.x) | 0);
    var num2 = ((255 * +value.y) | 0);
    var num3 = ((255 * +value.z) | 0);
    var num4 = ((255 * +value.w) | 0);
    return (((((((num4 << 24) + (num3 << 16)) >>> 0) + (num2 << 8)) >>> 0) + num) >>> 0);
  };

  function MathHelper_InverseSqrtFast$04 (x) {
    return Math.fround(+(1 / (Math.sqrt(x))));
  };

  function MathHelper_InverseSqrtFast$05 (x) {
    return $S00().CallStatic($thisType, "InverseSqrtFast", null, Math.fround(x));
  };

  function MathHelper_IsPowerOfTwo (val) {
    return (((val | 0) & (((val | 0) - 1) | 0)) === 0);
  };

  function MathHelper_NextPowerOfTwo$06 (n) {
    if (!$T01().op_GreaterThanOrEqual(n, $T01().Create(0, 0, 0))) {
      throw $S01().Construct("n", "Must be positive.");
    }
    return $T01().FromNumber(Math.pow(2, Math.ceil((Math.log(n.ToNumber(-1, false)) / Math.log(2)))));
  };

  function MathHelper_NextPowerOfTwo$07 (n) {
    if ((n | 0) < 0) {
      throw $S01().Construct("n", "Must be positive.");
    }
    return ((Math.pow(2, Math.ceil((Math.log(+n) / Math.log(2))))) | 0);
  };

  function MathHelper_NextPowerOfTwo$08 (n) {
    if (+n < 0) {
      throw $S01().Construct("n", "Must be positive.");
    }
    return Math.fround(Math.pow(2, Math.ceil((Math.log(n) / Math.log(2)))));
  };

  function MathHelper_NextPowerOfTwo$09 (n) {
    if (+n < 0) {
      throw $S01().Construct("n", "Must be positive.");
    }
    return Math.pow(2, Math.ceil((Math.log(n) / Math.log(2))));
  };

  function MathHelper_RadiansToDegrees (radians) {
    return (+radians * 57.2957764);
  };

  function MathHelper_Sin (val) {
    return Math.fround(Math.sin(val));
  };

  function MathHelper_Swap$0A (/* ref */ a, /* ref */ b) {
    var num = +a.get();
    a.set(b.get());
    b.set(num);
  };

  function MathHelper_Swap$0B (/* ref */ a, /* ref */ b) {
    var num = +a.get();
    a.set(b.get());
    b.set(num);
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.Object"), 
      Name: "Fusee.Math.MathHelper", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      JSIL.MethodSignature.Void, 
      MathHelper__ctor
    );

    $.Method({Static:true , Public:true }, "BinomialCoefficient", 
      new JSIL.MethodSignature($.Int64, [$.Int32, $.Int32]), 
      MathHelper_BinomialCoefficient
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature($.Double, [
          $.Double, $.Double, 
          $.Double
        ]), 
      MathHelper_Clamp$00
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature($.Single, [
          $.Single, $.Single, 
          $.Single
        ]), 
      MathHelper_Clamp$01
    );

    $.Method({Static:true , Public:true }, "Cos", 
      new JSIL.MethodSignature($.Single, [$.Single]), 
      MathHelper_Cos
    );

    $.Method({Static:true , Public:true }, "DegreesToRadians", 
      new JSIL.MethodSignature($.Single, [$.Single]), 
      MathHelper_DegreesToRadians
    );

    $.Method({Static:true , Public:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Double, $.Double]), 
      MathHelper_Equals$02
    );

    $.Method({Static:true , Public:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Single, $.Single]), 
      MathHelper_Equals$03
    );

    $.Method({Static:true , Public:true }, "Factorial", 
      new JSIL.MethodSignature($.Int64, [$.Int32]), 
      MathHelper_Factorial
    );

    $.Method({Static:true , Public:true }, "Float4ToABGR", 
      new JSIL.MethodSignature($.UInt32, [$asm04.TypeRef("Fusee.Math.float4")]), 
      MathHelper_Float4ToABGR
    );

    $.Method({Static:true , Public:true }, "InverseSqrtFast", 
      new JSIL.MethodSignature($.Single, [$.Single]), 
      MathHelper_InverseSqrtFast$04
    );

    $.Method({Static:true , Public:true }, "InverseSqrtFast", 
      new JSIL.MethodSignature($.Double, [$.Double]), 
      MathHelper_InverseSqrtFast$05
    );

    $.Method({Static:true , Public:true }, "IsPowerOfTwo", 
      new JSIL.MethodSignature($.Boolean, [$.Int32]), 
      MathHelper_IsPowerOfTwo
    );

    $.Method({Static:true , Public:true }, "NextPowerOfTwo", 
      new JSIL.MethodSignature($.Int64, [$.Int64]), 
      MathHelper_NextPowerOfTwo$06
    );

    $.Method({Static:true , Public:true }, "NextPowerOfTwo", 
      new JSIL.MethodSignature($.Int32, [$.Int32]), 
      MathHelper_NextPowerOfTwo$07
    );

    $.Method({Static:true , Public:true }, "NextPowerOfTwo", 
      new JSIL.MethodSignature($.Single, [$.Single]), 
      MathHelper_NextPowerOfTwo$08
    );

    $.Method({Static:true , Public:true }, "NextPowerOfTwo", 
      new JSIL.MethodSignature($.Double, [$.Double]), 
      MathHelper_NextPowerOfTwo$09
    );

    $.Method({Static:true , Public:true }, "RadiansToDegrees", 
      new JSIL.MethodSignature($.Single, [$.Single]), 
      MathHelper_RadiansToDegrees
    );

    $.Method({Static:true , Public:true }, "Sin", 
      new JSIL.MethodSignature($.Single, [$.Single]), 
      MathHelper_Sin
    );

    $.Method({Static:true , Public:true }, "Swap", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Double]), $jsilcore.TypeRef("JSIL.Reference", [$.Double])]), 
      MathHelper_Swap$0A
    );

    $.Method({Static:true , Public:true }, "Swap", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Single]), $jsilcore.TypeRef("JSIL.Reference", [$.Single])]), 
      MathHelper_Swap$0B
    );

    $.Constant({Static:true , Public:true }, "EpsilonFloat", 1.192093E-07); 
    $.Constant({Static:true , Public:true }, "EpsilonDouble", 1.11022302462516E-16); 
    $.Constant({Static:true , Public:true }, "Pi", 3.14159274); 
    $.Constant({Static:true , Public:true }, "PiOver2", 1.57079637); 
    $.Constant({Static:true , Public:true }, "PiOver3", 1.04719758); 
    $.Constant({Static:true , Public:true }, "PiOver4", 0.7853982); 
    $.Constant({Static:true , Public:true }, "PiOver6", 0.5235988); 
    $.Constant({Static:true , Public:true }, "TwoPi", 6.28318548); 
    $.Constant({Static:true , Public:true }, "ThreePiOver2", 4.712389); 
    $.Constant({Static:true , Public:true }, "E", 2.71828175); 
    $.Constant({Static:true , Public:true }, "Log10E", 0.4342945); 
    $.Constant({Static:true , Public:true }, "Log2E", 1.442695); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Math.Quaternion */ 

(function Quaternion$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Math.float3)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm07.System.Single)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm07.System.Math)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.System.Boolean)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm04.Fusee.Math.MathHelper)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm07.System.Double)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize(System.Array.Of($asm04.Fusee.Math.float3))) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm04.Fusee.Math.float4x4)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm04.Fusee.Math.float4)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm07.System.String)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.Quaternion"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float3"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.Quaternion"), [$asm04.TypeRef("Fusee.Math.float3"), $asm07.TypeRef("System.Single")]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("System.Int32"), [$asm07.TypeRef("System.Single")]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$asm04.TypeRef("Fusee.Math.float3"), $asm07.TypeRef("System.Single")]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$asm07.TypeRef("System.Single"), $asm04.TypeRef("Fusee.Math.float3")]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")])
      ]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")]), $asm07.TypeRef("System.Single"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")])
      ]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("System.Boolean"), [$asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double")]))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("System.Double"), [
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double")
      ]))) ();
  };

  function Quaternion__ctor$00 (v, w) {
    this._xyz = v.MemberwiseClone();
    this._w = +w;
  };

  function Quaternion__ctor$01 (xx, yy, zz, w) {
    $thisType.prototype._ctor.call(this, $S01().Construct(xx, yy, zz), w);
  };

  function Quaternion_Add$02 (left, right) {
    return $S02().Construct($T00().op_Addition(
        left.get_xyz().MemberwiseClone(), 
        right.get_xyz()
      ).MemberwiseClone(), (+left.get_w() + +right.get_w()));
  };

  function Quaternion_Add$03 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct($T00().op_Addition(
          (left.get()).get_xyz().MemberwiseClone(), 
          (right.get()).get_xyz()
        ).MemberwiseClone(), (+(left.get()).get_w() + +(right.get()).get_w())));
  };

  function Quaternion_Conjugate$04 () {
    (this.xyz = $T00().op_UnaryNegation(this.xyz.MemberwiseClone()));
  };

  function Quaternion_Conjugate$05 (q) {
    return $S02().Construct($T00().op_UnaryNegation(q.get_xyz().MemberwiseClone()).MemberwiseClone(), q.get_w());
  };

  function Quaternion_Conjugate$06 (/* ref */ q, /* ref */ result) {
    result.set($S02().Construct($T00().op_UnaryNegation((q.get()).get_xyz().MemberwiseClone()).MemberwiseClone(), (q.get()).get_w()));
  };

  function Quaternion_CopySign (a, b) {
    return ((Math.abs(a)) * +($S03().CallStatic($T02(), "Sign", null, b)));
  };

  function Quaternion_Object_Equals (other) {
    return ($thisType.$Is(other) && $thisType.op_Equality(this, $thisType.$Cast(other).MemberwiseClone()));
  };

  function Quaternion_Equals$07 (other) {
    return ($T00().op_Equality(
        this.get_xyz().MemberwiseClone(), 
        other.get_xyz().MemberwiseClone()
      ) && ((Math.abs((+this.get_w() - +other.get_w()))) < 1.192093E-07));
  };

  function Quaternion_EulerToQuaternion (e, inDegrees) {
    if (inDegrees) {
      var x = +$T05().DegreesToRadians(e.x);
      var y = +$T05().DegreesToRadians(e.y);
      var z = +$T05().DegreesToRadians(e.z);
      $T00().prototype._ctor.call(e, x, y, z);
    }
    var num = Math.fround(Math.sin((+e.x * 0.5)));
    var num2 = Math.fround(Math.cos((+e.x * 0.5)));
    var num3 = Math.fround(Math.sin((+e.y * 0.5)));
    var num4 = Math.fround(Math.cos((+e.y * 0.5)));
    var num5 = Math.fround(Math.sin((+e.z * 0.5)));
    var num6 = Math.fround(Math.cos((+e.z * 0.5)));
    var xx = ((num * num4) * num6) - ((num2 * num3) * num5);
    var yy = ((num2 * num3) * num6) + ((num * num4) * num5);
    var zz = ((num2 * num4) * num5) - ((num * num3) * num6);
    var w = ((num2 * num4) * num6) + ((num * num3) * num5);
    return $S00().Construct(xx, yy, zz, w);
  };

  function Quaternion_FromAxisAngle (axis, angle) {
    if (+axis.get_LengthSquared() > 1.192093E-07) {
      var result = $thisType.Identity.MemberwiseClone();
    } else {
      var identity = $thisType.Identity.MemberwiseClone();
      angle *= 0.5;
      axis.Normalize();
      (identity.xyz = $S04().CallStatic($T00(), "op_Multiply", null, axis.MemberwiseClone(), Math.fround(Math.sin(angle))));
      identity.set_w(Math.fround(Math.cos(angle)));
      result = $thisType.Normalize(identity.MemberwiseClone()).MemberwiseClone();
    }
    return result;
  };

  function Quaternion_get_Length () {
    return Math.fround(Math.sqrt(((+this.get_w() * +this.get_w()) + +(this.get_xyz()).get_LengthSquared())));
  };

  function Quaternion_get_LengthSquared () {
    return ((+this.get_w() * +this.get_w()) + +(this.get_xyz()).get_LengthSquared());
  };

  function Quaternion_get_w () {
    return this._w;
  };

  function Quaternion_get_x () {
    return this._xyz.x;
  };

  function Quaternion_get_xyz () {
    return this._xyz;
  };

  function Quaternion_get_y () {
    return this._xyz.y;
  };

  function Quaternion_get_z () {
    return this._xyz.z;
  };

  function Quaternion_GetHashCode () {
    return (((this.get_xyz().MemberwiseClone()).GetHashCode() | 0) ^ ((this.get_w()).GetHashCode() | 0));
  };

  function Quaternion_Invert$08 ($q) {
    var q = new JSIL.BoxedVariable($q.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.Invert(/* ref */ q, /* ref */ result);
    return result.get();
  };

  function Quaternion_Invert$09 (/* ref */ q, /* ref */ result) {
    var lengthSquared = +(q.get()).get_LengthSquared();
    if (lengthSquared > 1.192093E-07) {
      var num = +((1 / lengthSquared));
      result.set($S02().Construct($S04().CallStatic($T00(), "op_Multiply", null, (q.get()).get_xyz().MemberwiseClone(), -num).MemberwiseClone(), (+(q.get()).get_w() * num)));
    } else {
      result.set(q.get().MemberwiseClone());
    }
  };

  function Quaternion_LookRotation (lookAt, upDirection) {
    var array = $T00().OrthoNormalize(lookAt.MemberwiseClone(), upDirection.MemberwiseClone());
    upDirection = array[1].MemberwiseClone();
    lookAt = array[0].MemberwiseClone();
    var float = $T00().Cross(upDirection.MemberwiseClone(), lookAt.MemberwiseClone()).MemberwiseClone();
    var num = Math.fround(Math.sqrt((((1 + +float.x) + +upDirection.y) + +lookAt.z))) * 0.5;
    var num2 = +((1 / (4 * num)));
    var xx = (+upDirection.z - +lookAt.y) * num2;
    var yy = (+lookAt.x - +float.z) * num2;
    var zz = (+float.y - +upDirection.x) * num2;
    var result = $S00().Construct(xx, yy, zz, num);
    return result;
  };

  function Quaternion_Mult$0A (left, right) {
    return $S02().Construct($T00().op_Addition(
        $T00().op_Addition(
          $S05().CallStatic($T00(), "op_Multiply", null, 
            right.get_w(), 
            left.get_xyz().MemberwiseClone()
          ).MemberwiseClone(), 
          $S05().CallStatic($T00(), "op_Multiply", null, 
            left.get_w(), 
            right.get_xyz().MemberwiseClone()
          )
        ).MemberwiseClone(), 
        $T00().Cross(
          left.get_xyz().MemberwiseClone(), 
          right.get_xyz().MemberwiseClone()
        )
      ).MemberwiseClone(), ((+left.get_w() * +right.get_w()) - +$T00().Dot(
          left.get_xyz(), 
          right.get_xyz()
        )));
  };

  function Quaternion_Mult$0B (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct($T00().op_Addition(
          $T00().op_Addition(
            $S05().CallStatic($T00(), "op_Multiply", null, 
              (right.get()).get_w(), 
              (left.get()).get_xyz().MemberwiseClone()
            ).MemberwiseClone(), 
            $S05().CallStatic($T00(), "op_Multiply", null, 
              (left.get()).get_w(), 
              (right.get()).get_xyz().MemberwiseClone()
            )
          ).MemberwiseClone(), 
          $T00().Cross(
            (left.get()).get_xyz().MemberwiseClone(), 
            (right.get()).get_xyz().MemberwiseClone()
          )
        ).MemberwiseClone(), ((+(left.get()).get_w() * +(right.get()).get_w()) - +$T00().Dot(
            (left.get()).get_xyz(), 
            (right.get()).get_xyz()
          ))));
  };

  function Quaternion_Multiply$0C ($left, $right) {
    var right = new JSIL.BoxedVariable($right.MemberwiseClone());
    var left = new JSIL.BoxedVariable($left.MemberwiseClone());
    var result = new JSIL.BoxedVariable(new $thisType());
    $S06().CallStatic($thisType, "Multiply", null, /* ref */ left, /* ref */ right, /* ref */ result);
    return result.get();
  };

  function Quaternion_Multiply$0D (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S00().Construct(((((+(left.get()).get_w() * +(right.get()).get_x()) + (+(left.get()).get_x() * +(right.get()).get_w())) + (+(left.get()).get_y() * +(right.get()).get_z())) - (+(left.get()).get_z() * +(right.get()).get_y())), ((((+(left.get()).get_w() * +(right.get()).get_y()) + (+(left.get()).get_y() * +(right.get()).get_w())) + (+(left.get()).get_z() * +(right.get()).get_x())) - (+(left.get()).get_x() * +(right.get()).get_z())), ((((+(left.get()).get_w() * +(right.get()).get_z()) + (+(left.get()).get_z() * +(right.get()).get_w())) + (+(left.get()).get_x() * +(right.get()).get_y())) - (+(left.get()).get_y() * +(right.get()).get_x())), ((((+(left.get()).get_w() * +(right.get()).get_w()) - (+(left.get()).get_x() * +(right.get()).get_x())) - (+(left.get()).get_y() * +(right.get()).get_y())) - (+(left.get()).get_z() * +(right.get()).get_z()))));
  };

  function Quaternion_Multiply$0E (/* ref */ quaternion, scale, /* ref */ result) {
    result.set($S00().Construct((+(quaternion.get()).get_x() * +scale), (+(quaternion.get()).get_y() * +scale), (+(quaternion.get()).get_z() * +scale), (+(quaternion.get()).get_w() * +scale)));
  };

  function Quaternion_Multiply$0F (quaternion, scale) {
    return $S00().Construct((+quaternion.get_x() * +scale), (+quaternion.get_y() * +scale), (+quaternion.get_z() * +scale), (+quaternion.get_w() * +scale));
  };

  function Quaternion_Normalize$10 () {
    var $temp00;
    if (+this.get_Length() > 1.192093E-07) {
      var num = +((1 / +this.get_Length()));
      (this.xyz = $S04().CallStatic($T00(), "op_Multiply", null, this.xyz.MemberwiseClone(), num));
      ($temp00 = +this.get_w() * num, 
        this.set_w($temp00), 
        $temp00);
    }
  };

  function Quaternion_Normalize$11 ($q) {
    var q = new JSIL.BoxedVariable($q);
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.Normalize(/* ref */ q, /* ref */ result);
    return result.get();
  };

  function Quaternion_Normalize$12 (/* ref */ q, /* ref */ result) {
    if (+(q.get()).get_Length() <= 1.192093E-07) {
      var num = 0;
    } else {
      num = +((1 / +(q.get()).get_Length()));
    }
    result.set($S02().Construct($S04().CallStatic($T00(), "op_Multiply", null, (q.get()).get_xyz().MemberwiseClone(), num).MemberwiseClone(), (+(q.get()).get_w() * num)));
  };

  function Quaternion_op_Addition (left, right) {
    var $temp00;
    (left.xyz = $T00().op_Addition(left.xyz.MemberwiseClone(), right.get_xyz()));
    ($temp00 = +left.get_w() + +right.get_w(), 
      left.set_w($temp00), 
      $temp00);
    return left;
  };

  function Quaternion_op_Equality (left, right) {
    return left.Equals(right.MemberwiseClone());
  };

  function Quaternion_op_Inequality (left, right) {
    return !left.Equals(right.MemberwiseClone());
  };

  function Quaternion_op_Multiply$13 ($left, $right) {
    var right = new JSIL.BoxedVariable($right.MemberwiseClone());
    var left = new JSIL.BoxedVariable($left.MemberwiseClone());
    $S06().CallStatic($thisType, "Multiply", null, /* ref */ left, /* ref */ right, /* ref */ left);
    return left.get();
  };

  function Quaternion_op_Multiply$14 ($quaternion, scale) {
    var quaternion = new JSIL.BoxedVariable($quaternion.MemberwiseClone());
    $S07().CallStatic($thisType, "Multiply", null, /* ref */ quaternion, scale, /* ref */ quaternion);
    return quaternion.get();
  };

  function Quaternion_op_Multiply$15 (scale, quaternion) {
    return $S00().Construct((+quaternion.get_x() * +scale), (+quaternion.get_y() * +scale), (+quaternion.get_z() * +scale), (+quaternion.get_w() * +scale));
  };

  function Quaternion_op_Subtraction (left, right) {
    var $temp00;
    (left.xyz = $T00().op_Subtraction(left.xyz.MemberwiseClone(), right.get_xyz()));
    ($temp00 = +left.get_w() - +right.get_w(), 
      left.set_w($temp00), 
      $temp00);
    return left;
  };

  function Quaternion_QuaternionToEuler (q, inDegrees) {
    q.Normalize();
    var num = 2 * ((+q.get_y() * +q.get_w()) - (+q.get_x() * +q.get_z()));
    if ($S08().CallStatic($T05(), "Equals", null, num, 1)) {
      var num2 = -2 * Math.fround(Math.atan2(q.get_x(), q.get_w()));
      var num3 = 0;
      var num4 = 1.57079637;
    } else if ($S08().CallStatic($T05(), "Equals", null, num, -1)) {
      num2 = 2 * Math.fround(Math.atan2(q.get_x(), q.get_w()));
      num3 = 0;
      num4 = -1.57079637;
    } else {
      var num5 = +q.get_x() * +q.get_x();
      var num6 = +q.get_y() * +q.get_y();
      var num7 = +q.get_z() * +q.get_z();
      var num8 = +q.get_w() * +q.get_w();
      num3 = Math.fround(Math.atan2((2 * ((+q.get_y() * +q.get_z()) + (+q.get_w() * +q.get_x()))), (((num8 - num5) - num6) + num7)));
      num4 = Math.fround(Math.asin($S09().CallStatic($T05(), "Clamp", null, num, -1, 1)));
      num2 = Math.fround(Math.atan2((2 * ((+q.get_x() * +q.get_y()) + (+q.get_w() * +q.get_z()))), (((num8 + num5) - num6) - num7)));
    }
    if (inDegrees) {
      num3 = +$T05().RadiansToDegrees(num3);
      num4 = +$T05().RadiansToDegrees(num4);
      num2 = +$T05().RadiansToDegrees(num2);
    }
    return $S01().Construct(num3, num4, num2);
  };

  function Quaternion_QuaternionToMatrix (q) {
    q.Normalize();
    var result = new ($T08())();
    result.set_M11(1 - (2 * ((+q.get_y() * +q.get_y()) + (+q.get_z() * +q.get_z()))));
    result.set_M12(2 * ((+q.get_x() * +q.get_y()) + (+q.get_z() * +q.get_w())));
    result.set_M13(2 * ((+q.get_x() * +q.get_z()) - (+q.get_y() * +q.get_w())));
    result.set_M14(0);
    result.set_M21(2 * ((+q.get_x() * +q.get_y()) - (+q.get_z() * +q.get_w())));
    result.set_M22(1 - (2 * ((+q.get_x() * +q.get_x()) + (+q.get_z() * +q.get_z()))));
    result.set_M23(2 * ((+q.get_z() * +q.get_y()) + (+q.get_x() * +q.get_w())));
    result.set_M24(0);
    result.set_M31(2 * ((+q.get_x() * +q.get_z()) + (+q.get_y() * +q.get_w())));
    result.set_M32(2 * ((+q.get_y() * +q.get_z()) - (+q.get_x() * +q.get_w())));
    result.set_M33(1 - (2 * ((+q.get_x() * +q.get_x()) + (+q.get_y() * +q.get_y()))));
    result.set_M34(0);
    result.set_M41(0);
    result.set_M42(0);
    result.set_M43(0);
    result.set_M44(1);
    return result;
  };

  function Quaternion_set_w (value) {
    this._w = +value;
  };

  function Quaternion_set_x (value) {
    this._xyz.x = +value;
  };

  function Quaternion_set_xyz (value) {
    this._xyz = value.MemberwiseClone();
  };

  function Quaternion_set_y (value) {
    this._xyz.y = +value;
  };

  function Quaternion_set_z (value) {
    this._xyz.z = +value;
  };

  function Quaternion_Slerp (q1, q2, blend) {
    var q3 = new $thisType();
    if (+q1.get_LengthSquared() < 1.192093E-07) {
      var result = (
        (+q2.get_LengthSquared() <= 1.192093E-07)
           ? $thisType.Identity
           : q2)
      .MemberwiseClone();
    } else if (+q2.get_LengthSquared() < 1.192093E-07) {
      result = q1.MemberwiseClone();
    } else {
      var num = (+q1.get_w() * +q2.get_w()) + +$T00().Dot(
        q1.get_xyz(), 
        q2.get_xyz()
      );
      if (!((num < 1) && (num > -1))) {
        result = q1.MemberwiseClone();
      } else {
        if (num < 0) {
          (q2.xyz = $T00().op_UnaryNegation(q2.xyz.MemberwiseClone()));
          q2.set_w(-q2.get_w());
          num = -num;
        }
        if (num < 0.99) {
          var num2 = Math.fround(Math.acos(num));
          var num3 = Math.fround(Math.sin(num2));
          var num4 = +((1 / num3));
          var num5 = Math.fround(Math.sin((num2 * (1 - +blend)))) * num4;
          var num6 = Math.fround(Math.sin((num2 * +blend))) * num4;
        } else {
          num5 = 1 - +blend;
          num6 = +blend;
        }
        $thisType.prototype._ctor.call(q3, 
          $T00().op_Addition(
            $S05().CallStatic($T00(), "op_Multiply", null, num5, q1.get_xyz().MemberwiseClone()).MemberwiseClone(), 
            $S05().CallStatic($T00(), "op_Multiply", null, num6, q2.get_xyz().MemberwiseClone())
          ).MemberwiseClone(), 
          (num5 * +q1.get_w()) + (num6 * +q2.get_w())
        );
        result = (
          (+q3.get_LengthSquared() > 1.192093E-07)
             ? $thisType.Normalize(q3.MemberwiseClone())
             : $thisType.Identity)
        .MemberwiseClone();
      }
    }
    return result;
  };

  function Quaternion_Sub$16 (left, right) {
    return $S02().Construct($T00().op_Subtraction(
        left.get_xyz().MemberwiseClone(), 
        right.get_xyz()
      ).MemberwiseClone(), (+left.get_w() - +right.get_w()));
  };

  function Quaternion_Sub$17 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct($T00().op_Subtraction(
          (left.get()).get_xyz().MemberwiseClone(), 
          (right.get()).get_xyz()
        ).MemberwiseClone(), (+(left.get()).get_w() - +(right.get()).get_w())));
  };

  function Quaternion_ToAxisAngle$18 (/* ref */ axis, /* ref */ angle) {
    var float = this.ToAxisAngle();
    axis.set(float.get_xyz().MemberwiseClone());
    angle.set(float.w);
  };

  function Quaternion_ToAxisAngle$19 () {
    var quaternion = this;
    if (+quaternion.get_w() > 1) {
      quaternion.Normalize();
    }
    var float = new ($T09())();
    float.w = 2 * Math.fround(Math.acos(quaternion.get_w()));
    var result = float;
    var num = Math.fround(Math.sqrt((1 - (+quaternion.get_w() * +quaternion.get_w()))));
    if (num > 1.192093E-07) {
      (result.xyz = $T00().op_Division(quaternion.get_xyz().MemberwiseClone(), num).MemberwiseClone());
    } else {
      (result.xyz = $T00().UnitX.MemberwiseClone());
    }
    return result;
  };

  function Quaternion_toString () {
    return $T0A().Format(
      "V: {0}, w: {1}", 
      this.get_xyz(), 
      this.get_w()
    );
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.Quaternion", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 4, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.float3"), $.Single]), 
      Quaternion__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single
        ]), 
      Quaternion__ctor$01
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      Quaternion_Add$02
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      Quaternion_Add$03
    );

    $.Method({Static:false, Public:true }, "Conjugate", 
      JSIL.MethodSignature.Void, 
      Quaternion_Conjugate$04
    );

    $.Method({Static:true , Public:true }, "Conjugate", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      Quaternion_Conjugate$05
    );

    $.Method({Static:true , Public:true }, "Conjugate", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      Quaternion_Conjugate$06
    );

    $.Method({Static:true , Public:true }, "CopySign", 
      new JSIL.MethodSignature($.Single, [$.Single, $.Single]), 
      Quaternion_CopySign
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object]), 
      Quaternion_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type]), 
      Quaternion_Equals$07
    );

    $.Method({Static:true , Public:true }, "EulerToQuaternion", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.float3"), $.Boolean]), 
      Quaternion_EulerToQuaternion
    );

    $.Method({Static:true , Public:true }, "FromAxisAngle", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.float3"), $.Single]), 
      Quaternion_FromAxisAngle
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      JSIL.MethodSignature.Return($.Single), 
      Quaternion_get_Length
    );

    $.Method({Static:false, Public:true }, "get_LengthSquared", 
      JSIL.MethodSignature.Return($.Single), 
      Quaternion_get_LengthSquared
    );

    $.Method({Static:false, Public:true }, "get_w", 
      JSIL.MethodSignature.Return($.Single), 
      Quaternion_get_w
    );

    $.Method({Static:false, Public:true }, "get_x", 
      JSIL.MethodSignature.Return($.Single), 
      Quaternion_get_x
    );

    $.Method({Static:false, Public:true }, "get_xyz", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.float3")), 
      Quaternion_get_xyz
    );

    $.Method({Static:false, Public:true }, "get_y", 
      JSIL.MethodSignature.Return($.Single), 
      Quaternion_get_y
    );

    $.Method({Static:false, Public:true }, "get_z", 
      JSIL.MethodSignature.Return($.Single), 
      Quaternion_get_z
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      JSIL.MethodSignature.Return($.Int32), 
      Quaternion_GetHashCode
    );

    $.Method({Static:true , Public:true }, "Invert", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      Quaternion_Invert$08
    );

    $.Method({Static:true , Public:true }, "Invert", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      Quaternion_Invert$09
    );

    $.Method({Static:true , Public:true }, "LookRotation", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.float3"), $asm04.TypeRef("Fusee.Math.float3")]), 
      Quaternion_LookRotation
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      Quaternion_Mult$0A
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use Multiply instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      Quaternion_Mult$0B
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use Multiply instead."]; });

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      Quaternion_Multiply$0C
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      Quaternion_Multiply$0D
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      Quaternion_Multiply$0E
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      Quaternion_Multiply$0F
    );

    $.Method({Static:false, Public:true }, "Normalize", 
      JSIL.MethodSignature.Void, 
      Quaternion_Normalize$10
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature($.Type, [$.Type]), 
      Quaternion_Normalize$11
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])]), 
      Quaternion_Normalize$12
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      Quaternion_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      Quaternion_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type]), 
      Quaternion_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      Quaternion_op_Multiply$13
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single]), 
      Quaternion_op_Multiply$14
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Single, $.Type]), 
      Quaternion_op_Multiply$15
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      Quaternion_op_Subtraction
    );

    $.Method({Static:true , Public:true }, "QuaternionToEuler", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$.Type, $.Boolean]), 
      Quaternion_QuaternionToEuler
    );

    $.Method({Static:true , Public:true }, "QuaternionToMatrix", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float4x4"), [$.Type]), 
      Quaternion_QuaternionToMatrix
    );

    $.Method({Static:false, Public:true }, "set_w", 
      JSIL.MethodSignature.Action($.Single), 
      Quaternion_set_w
    );

    $.Method({Static:false, Public:true }, "set_x", 
      JSIL.MethodSignature.Action($.Single), 
      Quaternion_set_x
    );

    $.Method({Static:false, Public:true }, "set_xyz", 
      JSIL.MethodSignature.Action($asm04.TypeRef("Fusee.Math.float3")), 
      Quaternion_set_xyz
    );

    $.Method({Static:false, Public:true }, "set_y", 
      JSIL.MethodSignature.Action($.Single), 
      Quaternion_set_y
    );

    $.Method({Static:false, Public:true }, "set_z", 
      JSIL.MethodSignature.Action($.Single), 
      Quaternion_set_z
    );

    $.Method({Static:true , Public:true }, "Slerp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Single
        ]), 
      Quaternion_Slerp
    );

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type]), 
      Quaternion_Sub$16
    );

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ]), 
      Quaternion_Sub$17
    );

    $.Method({Static:false, Public:true }, "ToAxisAngle", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")]), $jsilcore.TypeRef("JSIL.Reference", [$.Single])]), 
      Quaternion_ToAxisAngle$18
    );

    $.Method({Static:false, Public:true }, "ToAxisAngle", 
      JSIL.MethodSignature.Return($asm04.TypeRef("Fusee.Math.float4")), 
      Quaternion_ToAxisAngle$19
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      JSIL.MethodSignature.Return($.String), 
      Quaternion_toString
    );

    $.Field({Static:false, Public:false}, "_xyz", $asm04.TypeRef("Fusee.Math.float3")); 
    $.Field({Static:false, Public:false}, "_w", $.Single); 
    $.Field({Static:true , Public:true }, "Identity", $.Type); 
    function Quaternion__cctor () {
      $thisType.Identity = new $thisType();
      $thisType.Identity = $S00().Construct(0, 0, 0, 1);
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      JSIL.MethodSignature.Void, 
      Quaternion__cctor
    );

    $.Property({Static:false, Public:true }, "xyz", $asm04.TypeRef("Fusee.Math.float3"));

    $.Property({Static:false, Public:true }, "x", $.Single);

    $.Property({Static:false, Public:true }, "y", $.Single);

    $.Property({Static:false, Public:true }, "z", $.Single);

    $.Property({Static:false, Public:true }, "w", $.Single);

    $.Property({Static:false, Public:true }, "Length", $.Single);

    $.Property({Static:false, Public:true }, "LengthSquared", $.Single);

    $.ImplementInterfaces(
      /* 0 */ $asm07.TypeRef("System.IEquatable`1", [$.Type])
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

