/* Generated by JSIL v0.7.8 build 970. See http://jsil.org/ for more information. */ 
var $asm04 = JSIL.DeclareAssembly("Fusee.Math.Core, Version=0.5.0.0, Culture=neutral, PublicKeyToken=null");

JSIL.DeclareNamespace("Fusee");
JSIL.DeclareNamespace("Fusee.Math");
/* struct Fusee.Math.AABBf */ 

(function AABBf$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Math.float3)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Math.float4x4)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize(System.Array.Of($asm04.Fusee.Math.float3))) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.System.Int32)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$asm04.TypeRef("Fusee.Math.float3"), $asm07.TypeRef("System.Single")], []))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float3"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$asm04.TypeRef("Fusee.Math.float4x4"), $asm04.TypeRef("Fusee.Math.float3")], []))) ();
  };

  function AABBf__ctor (min_, max_) {
    this.min = min_;
    this.max = max_;
  };

  function AABBf_get_Center () {
    return $S00().CallStatic($T00(), "op_Multiply", null, $T00().op_Addition(this.max.MemberwiseClone(), this.min.MemberwiseClone()).MemberwiseClone(), 0.5);
  };

  function AABBf_get_Size () {
    return $T00().op_Subtraction(this.max.MemberwiseClone(), this.min.MemberwiseClone());
  };

  function AABBf_op_Multiply (m, box) {
    var ret = new $thisType();
    var cube = JSIL.Array.New($T00(), [$S01().Construct(box.min.x, box.min.y, box.min.z), $S01().Construct(box.min.x, box.min.y, box.max.z), $S01().Construct(box.min.x, box.max.y, box.min.z), $S01().Construct(box.min.x, box.max.y, box.max.z), $S01().Construct(box.max.x, box.min.y, box.min.z), $S01().Construct(box.max.x, box.min.y, box.max.z), $S01().Construct(box.max.x, box.max.y, box.min.z), $S01().Construct(box.max.x, box.max.y, box.max.z)]);

    for (var i = 0; i < 8; i = ((i + 1) | 0)) {
      cube[i] = $S02().CallStatic($T01(), "op_Multiply", null, m, cube[i]);
    }
    ret.min = cube[0].MemberwiseClone();
    ret.max = cube[0].MemberwiseClone();

    for (i = 1; i < 8; i = ((i + 1) | 0)) {
      if (cube[i].x < ret.min.x) {
        ret.min.x = +cube[i].x;
      }
      if (cube[i].y < ret.min.y) {
        ret.min.y = +cube[i].y;
      }
      if (cube[i].z < ret.min.z) {
        ret.min.z = +cube[i].z;
      }
      if (cube[i].x > ret.max.x) {
        ret.max.x = +cube[i].x;
      }
      if (cube[i].y > ret.max.y) {
        ret.max.y = +cube[i].y;
      }
      if (cube[i].z > ret.max.z) {
        ret.max.z = +cube[i].z;
      }
    }
    return ret;
  };

  function AABBf_Union (a, b) {
    var ret = new $thisType();
    ret.min.x = +((a.min.x < b.min.x) ? a.min.x : b.min.x);
    ret.min.y = +((a.min.y < b.min.y) ? a.min.y : b.min.y);
    ret.min.z = +((a.min.z < b.min.z) ? a.min.z : b.min.z);
    ret.max.x = +((a.max.x > b.max.x) ? a.max.x : b.max.x);
    ret.max.y = +((a.max.y > b.max.y) ? a.max.y : b.max.y);
    ret.max.z = +((a.max.z > b.max.z) ? a.max.z : b.max.z);
    return ret;
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.AABBf", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.float3"), $asm04.TypeRef("Fusee.Math.float3")], []), 
      AABBf__ctor
    );

    $.Method({Static:false, Public:true }, "get_Center", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [], []), 
      AABBf_get_Center
    );

    $.Method({Static:false, Public:true }, "get_Size", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [], []), 
      AABBf_get_Size
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.float4x4"), $.Type], []), 
      AABBf_op_Multiply
    );

    $.Method({Static:true , Public:true }, "Union", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      AABBf_Union
    );

    $.Field({Static:false, Public:true }, "min", $asm04.TypeRef("Fusee.Math.float3"))
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [1]; }); 
    $.Field({Static:false, Public:true }, "max", $asm04.TypeRef("Fusee.Math.float3"))
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [2]; }); 
    $.Property({Static:false, Public:true }, "Center", $asm04.TypeRef("Fusee.Math.float3"));

    $.Property({Static:false, Public:true }, "Size", $asm04.TypeRef("Fusee.Math.float3"));

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm08.TypeRef("ProtoBuf.ProtoContractAttribute"));

})();

/* struct Fusee.Math.double2 */ 

(function double2$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm07.System.Double)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Math.double3)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Math.double4)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.System.Void)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm04.Fusee.Math.MathHelper)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm07.System.Converter$b2.Of($asm07.System.String, $asm04.Fusee.Math.double2))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm07.System.String)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm04.Fusee.Math.QuaternionD)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double2"), [$asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double2"), [$asm07.TypeRef("System.Double"), $asm04.TypeRef("Fusee.Math.double2")], []))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double2")]), $asm07.TypeRef("System.Double"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double2")])
      ], []))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double2")]), $asm07.TypeRef("System.Double"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double2")])
      ], []))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double2")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double2")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double2")])
      ], []))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("System.Double"), [$asm07.TypeRef("System.Double")], []))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double2")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double2")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double2")])
      ], []))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.QuaternionD"), [
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double")
      ]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")])
      ], []))) ();
  };

  function double2__ctor$00 (x, y) {
    this.x = +x;
    this.y = +y;
  };

  function double2__ctor$01 (v) {
    this.x = +v.x;
    this.y = +v.y;
  };

  function double2__ctor$02 (v) {
    this.x = +v.x;
    this.y = +v.y;
  };

  function double2__ctor$03 (v) {
    this.x = +v.x;
    this.y = +v.y;
  };

  function double2_Add$04 (right) {
    this.x += +right.x;
    this.y += +right.y;
  };

  function double2_Add$05 (/* ref */ right) {
    this.x += +right.get().x;
    this.y += +right.get().y;
  };

  function double2_Add$06 ($a, $b) {
    var b = new JSIL.BoxedVariable($b);
    var a = new JSIL.BoxedVariable($a);
    $thisType.Add(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  };

  function double2_Add$07 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((a.get().x + b.get().x), (a.get().y + b.get().y)));
  };

  function double2_BaryCentric$08 (a, b, c, u, v) {
    return $thisType.op_Addition(
      $thisType.op_Addition(a.MemberwiseClone(), $S01().CallStatic($thisType, "op_Multiply", null, u, $thisType.op_Subtraction(b, a.MemberwiseClone()))).MemberwiseClone(), 
      $S01().CallStatic($thisType, "op_Multiply", null, v, $thisType.op_Subtraction(c, a.MemberwiseClone()))
    );
  };

  function double2_BaryCentric$09 (/* ref */ a, /* ref */ b, /* ref */ c, u, v, /* ref */ result) {
    result.set(a.get().MemberwiseClone());
    var temp = new JSIL.BoxedVariable(b.get().MemberwiseClone());
    $thisType.Subtract(/* ref */ temp, /* ref */ a, /* ref */ temp);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ temp, u, /* ref */ temp);
    $thisType.Add(/* ref */ result, /* ref */ temp, /* ref */ result);
    temp.set(c.get().MemberwiseClone());
    $thisType.Subtract(/* ref */ temp, /* ref */ a, /* ref */ temp);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ temp, v, /* ref */ temp);
    $thisType.Add(/* ref */ result, /* ref */ temp, /* ref */ result);
  };

  function double2_Clamp$0A (vec, min, max) {
    vec.x = +((vec.x < min.x) ? min.x : ((vec.x > max.x) ? max.x : vec.x));
    vec.y = +((vec.y < min.y) ? min.y : ((vec.y > max.y) ? max.y : vec.y));
    return vec;
  };

  function double2_Clamp$0B (/* ref */ vec, /* ref */ min, /* ref */ max, /* ref */ result) {
    result.get().x = +((vec.get().x < min.get().x) ? min.get().x : ((vec.get().x > max.get().x) ? max.get().x : vec.get().x));
    result.get().y = +((vec.get().y < min.get().y) ? min.get().y : ((vec.get().y > max.get().y) ? max.get().y : vec.get().y));
  };

  function double2_ComponentMax$0C (a, b) {
    a.x = +((a.x > b.x) ? a.x : b.x);
    a.y = +((a.y > b.y) ? a.y : b.y);
    return a;
  };

  function double2_ComponentMax$0D (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +((a.get().x > b.get().x) ? a.get().x : b.get().x);
    result.get().y = +((a.get().y > b.get().y) ? a.get().y : b.get().y);
  };

  function double2_ComponentMin$0E (a, b) {
    a.x = +((a.x < b.x) ? a.x : b.x);
    a.y = +((a.y < b.y) ? a.y : b.y);
    return a;
  };

  function double2_ComponentMin$0F (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +((a.get().x < b.get().x) ? a.get().x : b.get().x);
    result.get().y = +((a.get().y < b.get().y) ? a.get().y : b.get().y);
  };

  function double2_Div$10 (f) {
    var mult = +(1 / f);
    this.x *= +mult;
    this.y *= +mult;
  };

  function double2_Div$11 (a, f) {
    var mult = +(1 / f);
    a.x *= +mult;
    a.y *= +mult;
    return a;
  };

  function double2_Div$12 (/* ref */ a, f, /* ref */ result) {
    var mult = +(1 / f);
    result.get().x = +(a.get().x * mult);
    result.get().y = +(a.get().y * mult);
  };

  function double2_Divide$13 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector);
    $S03().CallStatic($thisType, "Divide", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  };

  function double2_Divide$14 (/* ref */ vector, scale, /* ref */ result) {
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vector, (1 / scale), /* ref */ result);
  };

  function double2_Divide$15 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale);
    var vector = new JSIL.BoxedVariable($vector);
    $S04().CallStatic($thisType, "Divide", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  };

  function double2_Divide$16 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct((vector.get().x / scale.get().x), (vector.get().y / scale.get().y)));
  };

  function double2_Dot$17 (left, right) {
    return +((left.x * right.x) + (left.y * right.y));
  };

  function double2_Dot$18 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set(((left.get().x * right.get().x) + (left.get().y * right.get().y)));
  };

  function double2_Object_Equals (obj) {
    return ($thisType.$Is(obj) && this.Equals($thisType.$Cast(obj)));
  };

  function double2_Equals$19 (other) {
    return ((this.x === other.x) && (this.y === other.y));
  };

  function double2_get_Length () {
    return +Math.sqrt(((this.x * this.x) + (this.y * this.y)));
  };

  function double2_get_LengthFast () {
    return +(1 / $S05().CallStatic($T05(), "InverseSqrtFast", null, ((this.x * this.x) + (this.y * this.y))));
  };

  function double2_get_LengthSquared () {
    return +((this.x * this.x) + (this.y * this.y));
  };

  function double2_get_Parse () {
    return $thisType.double2$Parse$value;
  };

  function double2_get_PerpendicularLeft () {
    return $S00().Construct(-this.y, this.x);
  };

  function double2_get_PerpendicularRight () {
    return $S00().Construct(this.y, -this.x);
  };

  function double2_GetHashCode () {
    return (this.x.GetHashCode() ^ this.y.GetHashCode());
  };

  function double2_Lerp$1A (a, b, blend) {
    a.x = +((blend * (b.x - a.x)) + a.x);
    a.y = +((blend * (b.y - a.y)) + a.y);
    return a;
  };

  function double2_Lerp$1B (/* ref */ a, /* ref */ b, blend, /* ref */ result) {
    result.get().x = +((blend * (b.get().x - a.get().x)) + a.get().x);
    result.get().y = +((blend * (b.get().y - a.get().y)) + a.get().y);
  };

  function double2_Max (left, right) {
    return ((left.get_LengthSquared() >= right.get_LengthSquared()) ? left : right);
  };

  function double2_Min (left, right) {
    return ((left.get_LengthSquared() < right.get_LengthSquared()) ? left : right);
  };

  function double2_Mult$1C (f) {
    this.x *= +f;
    this.y *= +f;
  };

  function double2_Mult$1D (a, f) {
    a.x *= +f;
    a.y *= +f;
    return a;
  };

  function double2_Mult$1E (/* ref */ a, f, /* ref */ result) {
    result.get().x = +(a.get().x * f);
    result.get().y = +(a.get().y * f);
  };

  function double2_Multiply$1F ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  };

  function double2_Multiply$20 (/* ref */ vector, scale, /* ref */ result) {
    result.set($S00().Construct((vector.get().x * scale), (vector.get().y * scale)));
  };

  function double2_Multiply$21 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale);
    var vector = new JSIL.BoxedVariable($vector);
    $S06().CallStatic($thisType, "Multiply", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  };

  function double2_Multiply$22 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct((vector.get().x * scale.get().x), (vector.get().y * scale.get().y)));
  };

  function double2_Normalize$23 () {
    var scale = +(1 / this.get_Length());
    this.x *= +scale;
    this.y *= +scale;
  };

  function double2_Normalize$24 (vec) {
    var scale = +(1 / vec.get_Length());
    vec.x *= +scale;
    vec.y *= +scale;
    return vec;
  };

  function double2_Normalize$25 (/* ref */ vec, /* ref */ result) {
    var scale = +(1 / vec.get().get_Length());
    result.get().x = +(vec.get().x * scale);
    result.get().y = +(vec.get().y * scale);
  };

  function double2_NormalizeFast$26 () {
    var scale = +$S05().CallStatic($T05(), "InverseSqrtFast", null, ((this.x * this.x) + (this.y * this.y)));
    this.x *= +scale;
    this.y *= +scale;
  };

  function double2_NormalizeFast$27 (vec) {
    var scale = +$S05().CallStatic($T05(), "InverseSqrtFast", null, ((vec.x * vec.x) + (vec.y * vec.y)));
    vec.x *= +scale;
    vec.y *= +scale;
    return vec;
  };

  function double2_NormalizeFast$28 (/* ref */ vec, /* ref */ result) {
    var scale = +$S05().CallStatic($T05(), "InverseSqrtFast", null, ((vec.get().x * vec.get().x) + (vec.get().y * vec.get().y)));
    result.get().x = +(vec.get().x * scale);
    result.get().y = +(vec.get().y * scale);
  };

  function double2_op_Addition (left, right) {
    left.x += +right.x;
    left.y += +right.y;
    return left;
  };

  function double2_op_Division (vec, scale) {
    var mult = +(1 / scale);
    vec.x *= +mult;
    vec.y *= +mult;
    return vec;
  };

  function double2_op_Equality (left, right) {
    return left.Equals(right);
  };

  function double2_op_Inequality (left, right) {
    return !left.Equals(right);
  };

  function double2_op_Multiply$29 (vec, scale) {
    vec.x *= +scale;
    vec.y *= +scale;
    return vec;
  };

  function double2_op_Multiply$2A (scale, vec) {
    vec.x *= +scale;
    vec.y *= +scale;
    return vec;
  };

  function double2_op_Subtraction (left, right) {
    left.x -= +right.x;
    left.y -= +right.y;
    return left;
  };

  function double2_op_UnaryNegation (vec) {
    vec.x = +-vec.x;
    vec.y = +-vec.y;
    return vec;
  };

  function double2_Scale$2B (sx, sy) {
    this.x *= +sx;
    this.y *= +sy;
  };

  function double2_Scale$2C (scale) {
    this.x *= +scale.x;
    this.y *= +scale.y;
  };

  function double2_Scale$2D (/* ref */ scale) {
    this.x *= +scale.get().x;
    this.y *= +scale.get().y;
  };

  function double2_set_Parse (value) {
    $thisType.double2$Parse$value = value;
  };

  function double2_Sub$2E (right) {
    this.x -= +right.x;
    this.y -= +right.y;
  };

  function double2_Sub$2F (/* ref */ right) {
    this.x -= +right.get().x;
    this.y -= +right.get().y;
  };

  function double2_Sub$30 (a, b) {
    a.x -= +b.x;
    a.y -= +b.y;
    return a;
  };

  function double2_Sub$31 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(a.get().x - b.get().x);
    result.get().y = +(a.get().y - b.get().y);
  };

  function double2_Subtract$32 ($a, $b) {
    var b = new JSIL.BoxedVariable($b);
    var a = new JSIL.BoxedVariable($a);
    $thisType.Subtract(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  };

  function double2_Subtract$33 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((a.get().x - b.get().x), (a.get().y - b.get().y)));
  };

  function double2_ToArray () {
    return JSIL.Array.New($T00(), [this.x, this.y]);
  };

  function double2_toString () {
    return $T07().Format("({0}, {1})", this.x, this.y);
  };

  function double2_Transform$34 ($vec, $quat) {
    var quat = new JSIL.BoxedVariable($quat);
    var vec = new JSIL.BoxedVariable($vec);
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.Transform(/* ref */ vec, /* ref */ quat, /* ref */ result);
    return result.get();
  };

  function double2_Transform$35 (/* ref */ vec, /* ref */ quat, /* ref */ result) {
    var i = new JSIL.BoxedVariable(new ($T08())());
    var t = new JSIL.BoxedVariable(new ($T08())());
    var v = new JSIL.BoxedVariable($S07().Construct(vec.get().x, vec.get().y, 0, 0));
    $T08().Invert(/* ref */ quat, /* ref */ i);
    $S08().CallStatic($T08(), "Multiply", null, /* ref */ quat, /* ref */ v, /* ref */ t);
    $S08().CallStatic($T08(), "Multiply", null, /* ref */ t, /* ref */ i, /* ref */ v);
    result.set($S00().Construct(v.get().get_x(), v.get().get_y()));
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.double2", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.Double, $.Double], []), 
      double2__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.Type], []), 
      double2__ctor$01
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"));

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.double3")], []), 
      double2__ctor$02
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"));

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.double4")], []), 
      double2__ctor$03
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"));

    $.Method({Static:false, Public:true }, "Add", 
      new JSIL.MethodSignature(null, [$.Type], []), 
      double2_Add$04
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:false, Public:true }, "Add", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      double2_Add$05
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double2_Add$06
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double2_Add$07
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type, $.Double, 
          $.Double
        ], []), 
      double2_BaryCentric$08
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double2_BaryCentric$09
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type
        ], []), 
      double2_Clamp$0A
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double2_Clamp$0B
    );

    $.Method({Static:true , Public:true }, "ComponentMax", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double2_ComponentMax$0C
    );

    $.Method({Static:true , Public:true }, "ComponentMax", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double2_ComponentMax$0D
    );

    $.Method({Static:true , Public:true }, "ComponentMin", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double2_ComponentMin$0E
    );

    $.Method({Static:true , Public:true }, "ComponentMin", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double2_ComponentMin$0F
    );

    $.Method({Static:false, Public:true }, "Div", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double2_Div$10
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double], []), 
      double2_Div$11
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double2_Div$12
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double], []), 
      double2_Divide$13
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double2_Divide$14
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double2_Divide$15
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double2_Divide$16
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature($.Double, [$.Type, $.Type], []), 
      double2_Dot$17
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Double])
        ], []), 
      double2_Dot$18
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object], []), 
      double2_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type], []), 
      double2_Equals$19
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      new JSIL.MethodSignature($.Double, [], []), 
      double2_get_Length
    );

    $.Method({Static:false, Public:true }, "get_LengthFast", 
      new JSIL.MethodSignature($.Double, [], []), 
      double2_get_LengthFast
    );

    $.Method({Static:false, Public:true }, "get_LengthSquared", 
      new JSIL.MethodSignature($.Double, [], []), 
      double2_get_LengthSquared
    );

    $.Method({Static:true , Public:true }, "get_Parse", 
      new JSIL.MethodSignature($asm07.TypeRef("System.Converter`2", [$.String, $.Type]), [], []), 
      double2_get_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_PerpendicularLeft", 
      new JSIL.MethodSignature($.Type, [], []), 
      double2_get_PerpendicularLeft
    );

    $.Method({Static:false, Public:true }, "get_PerpendicularRight", 
      new JSIL.MethodSignature($.Type, [], []), 
      double2_get_PerpendicularRight
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      new JSIL.MethodSignature($.Int32, [], []), 
      double2_GetHashCode
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Double
        ], []), 
      double2_Lerp$1A
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double2_Lerp$1B
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double2_Max
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double2_Min
    );

    $.Method({Static:false, Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double2_Mult$1C
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double], []), 
      double2_Mult$1D
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double2_Mult$1E
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double], []), 
      double2_Multiply$1F
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double2_Multiply$20
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double2_Multiply$21
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double2_Multiply$22
    );

    $.Method({Static:false, Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [], []), 
      double2_Normalize$23
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      double2_Normalize$24
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      double2_Normalize$25
    );

    $.Method({Static:false, Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature(null, [], []), 
      double2_NormalizeFast$26
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      double2_NormalizeFast$27
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      double2_NormalizeFast$28
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double2_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Division", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double], []), 
      double2_op_Division
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type], []), 
      double2_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type], []), 
      double2_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double], []), 
      double2_op_Multiply$29
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Double, $.Type], []), 
      double2_op_Multiply$2A
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double2_op_Subtraction
    );

    $.Method({Static:true , Public:true }, "op_UnaryNegation", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      double2_op_UnaryNegation
    );

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [$.Double, $.Double], []), 
      double2_Scale$2B
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [$.Type], []), 
      double2_Scale$2C
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      double2_Scale$2D
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "set_Parse", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("System.Converter`2", [$.String, $.Type])], []), 
      double2_set_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [$.Type], []), 
      double2_Sub$2E
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:false, Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      double2_Sub$2F
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double2_Sub$30
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double2_Sub$31
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double2_Subtract$32
    );

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double2_Subtract$33
    );

    $.Method({Static:false, Public:true }, "ToArray", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Double]), [], []), 
      double2_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      new JSIL.MethodSignature($.String, [], []), 
      double2_toString
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.QuaternionD")], []), 
      double2_Transform$34
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double2_Transform$35
    );

    $.Field({Static:false, Public:true }, "x", $.Double); 
    $.Field({Static:false, Public:true }, "y", $.Double); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitX", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitY", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "Zero", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "One", $.Type); 
    $.Field({Static:true , Public:false}, "double2$Parse$value", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]))
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    function double2__cctor () {
      $thisType.UnitX = new $thisType();
      $thisType.UnitY = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.One = new $thisType();
      $thisType.UnitX = $S00().Construct(1, 0);
      $thisType.UnitY = $S00().Construct(0, 1);
      $thisType.Zero = $S00().Construct(0, 0);
      $thisType.One = $S00().Construct(1, 1);
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      new JSIL.MethodSignature(null, [], []), 
      double2__cctor
    );

    $.Property({Static:false, Public:true }, "Length", $.Double);

    $.Property({Static:false, Public:true }, "LengthFast", $.Double);

    $.Property({Static:false, Public:true }, "LengthSquared", $.Double);

    $.Property({Static:false, Public:true }, "PerpendicularRight", $.Type);

    $.Property({Static:false, Public:true }, "PerpendicularLeft", $.Type);

    $.Property({Static:true , Public:true }, "Parse", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]));

    $.ImplementInterfaces(
      /* 0 */ $asm07.TypeRef("System.IEquatable`1", [$.Type])
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Math.double3 */ 

(function double3$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm07.System.Double)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Math.double2)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Math.double4)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.System.Void)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.System.Object)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm04.Fusee.Math.MathHelper)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm07.System.Converter$b2.Of($asm07.System.String, $asm04.Fusee.Math.double3))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm07.System.String)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm04.Fusee.Math.double4x4)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm04.Fusee.Math.QuaternionD)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double3"), [
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double3"), [$asm07.TypeRef("System.Double"), $asm04.TypeRef("Fusee.Math.double3")], []))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")]), $asm07.TypeRef("System.Double"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")])
      ], []))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")]), $asm07.TypeRef("System.Double"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")])
      ], []))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")])
      ], []))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("System.Double"), [$asm07.TypeRef("System.Double")], []))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double2"), [$asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double")]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")])
      ], []))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4x4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")])
      ], []))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double4"), [
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double")
      ]))) ();
  };
  var $S0A = function () {
    return ($S0A = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4x4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")])
      ], []))) ();
  };
  var $S0B = function () {
    return ($S0B = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")])
      ], []))) ();
  };
  var $S0C = function () {
    return ($S0C = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double3"), [$asm04.TypeRef("Fusee.Math.double4")]))) ();
  };
  var $S0D = function () {
    return ($S0D = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double4"), [$asm04.TypeRef("Fusee.Math.double3")]))) ();
  };

  function double3__ctor$00 (x, y, z) {
    this.x = +x;
    this.y = +y;
    this.z = +z;
  };

  function double3__ctor$01 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +0;
  };

  function double3__ctor$02 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
  };

  function double3__ctor$03 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
  };

  function double3_Add$04 (right) {
    this.x += +right.x;
    this.y += +right.y;
    this.z += +right.z;
  };

  function double3_Add$05 (/* ref */ right) {
    this.x += +right.get().x;
    this.y += +right.get().y;
    this.z += +right.get().z;
  };

  function double3_Add$06 ($a, $b) {
    var b = new JSIL.BoxedVariable($b);
    var a = new JSIL.BoxedVariable($a);
    $thisType.Add(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  };

  function double3_Add$07 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((a.get().x + b.get().x), (a.get().y + b.get().y), (a.get().z + b.get().z)));
  };

  function double3_BaryCentric$08 (a, b, c, u, v) {
    return $thisType.op_Addition(
      $thisType.op_Addition(a.MemberwiseClone(), $S01().CallStatic($thisType, "op_Multiply", null, u, $thisType.op_Subtraction(b, a.MemberwiseClone()))).MemberwiseClone(), 
      $S01().CallStatic($thisType, "op_Multiply", null, v, $thisType.op_Subtraction(c, a.MemberwiseClone()))
    );
  };

  function double3_BaryCentric$09 (/* ref */ a, /* ref */ b, /* ref */ c, u, v, /* ref */ result) {
    result.set(a.get().MemberwiseClone());
    var temp = new JSIL.BoxedVariable(b.get().MemberwiseClone());
    $thisType.Subtract(/* ref */ temp, /* ref */ a, /* ref */ temp);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ temp, u, /* ref */ temp);
    $thisType.Add(/* ref */ result, /* ref */ temp, /* ref */ result);
    temp.set(c.get().MemberwiseClone());
    $thisType.Subtract(/* ref */ temp, /* ref */ a, /* ref */ temp);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ temp, v, /* ref */ temp);
    $thisType.Add(/* ref */ result, /* ref */ temp, /* ref */ result);
  };

  function double3_CalculateAngle$0A (first, second) {
    return +Math.acos(($thisType.Dot(first, second) / (first.get_Length() * second.get_Length())));
  };

  function double3_CalculateAngle$0B (/* ref */ first, /* ref */ second, /* ref */ result) {
    var temp = new JSIL.BoxedVariable(0);
    $thisType.Dot(/* ref */ first, /* ref */ second, /* ref */ temp);
    result.set((Math.acos((temp.get() / (first.get().get_Length() * second.get().get_Length())))));
  };

  function double3_Clamp$0C (vec, min, max) {
    vec.x = +((vec.x < min.x) ? min.x : ((vec.x > max.x) ? max.x : vec.x));
    vec.y = +((vec.y < min.y) ? min.y : ((vec.y > max.y) ? max.y : vec.y));
    vec.z = +((vec.z < min.z) ? min.z : ((vec.z > max.z) ? max.z : vec.z));
    return vec;
  };

  function double3_Clamp$0D (/* ref */ vec, /* ref */ min, /* ref */ max, /* ref */ result) {
    result.get().x = +((vec.get().x < min.get().x) ? min.get().x : ((vec.get().x > max.get().x) ? max.get().x : vec.get().x));
    result.get().y = +((vec.get().y < min.get().y) ? min.get().y : ((vec.get().y > max.get().y) ? max.get().y : vec.get().y));
    result.get().z = +((vec.get().z < min.get().z) ? min.get().z : ((vec.get().z > max.get().z) ? max.get().z : vec.get().z));
  };

  function double3_ComponentMax$0E (a, b) {
    a.x = +((a.x > b.x) ? a.x : b.x);
    a.y = +((a.y > b.y) ? a.y : b.y);
    a.z = +((a.z > b.z) ? a.z : b.z);
    return a;
  };

  function double3_ComponentMax$0F (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +((a.get().x > b.get().x) ? a.get().x : b.get().x);
    result.get().y = +((a.get().y > b.get().y) ? a.get().y : b.get().y);
    result.get().z = +((a.get().z > b.get().z) ? a.get().z : b.get().z);
  };

  function double3_ComponentMin$10 (a, b) {
    a.x = +((a.x < b.x) ? a.x : b.x);
    a.y = +((a.y < b.y) ? a.y : b.y);
    a.z = +((a.z < b.z) ? a.z : b.z);
    return a;
  };

  function double3_ComponentMin$11 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +((a.get().x < b.get().x) ? a.get().x : b.get().x);
    result.get().y = +((a.get().y < b.get().y) ? a.get().y : b.get().y);
    result.get().z = +((a.get().z < b.get().z) ? a.get().z : b.get().z);
  };

  function double3_Cross$12 ($left, $right) {
    var right = new JSIL.BoxedVariable($right);
    var left = new JSIL.BoxedVariable($left);
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.Cross(/* ref */ left, /* ref */ right, /* ref */ result);
    return result.get();
  };

  function double3_Cross$13 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S00().Construct(((left.get().y * right.get().z) - (left.get().z * right.get().y)), ((left.get().z * right.get().x) - (left.get().x * right.get().z)), ((left.get().x * right.get().y) - (left.get().y * right.get().x))));
  };

  function double3_Div$14 (f) {
    var mult = +(1 / f);
    this.x *= +mult;
    this.y *= +mult;
    this.z *= +mult;
  };

  function double3_Div$15 (a, f) {
    var mult = +(1 / f);
    a.x *= +mult;
    a.y *= +mult;
    a.z *= +mult;
    return a;
  };

  function double3_Div$16 (/* ref */ a, f, /* ref */ result) {
    var mult = +(1 / f);
    result.get().x = +(a.get().x * mult);
    result.get().y = +(a.get().y * mult);
    result.get().z = +(a.get().z * mult);
  };

  function double3_Divide$17 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector);
    $S03().CallStatic($thisType, "Divide", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  };

  function double3_Divide$18 (/* ref */ vector, scale, /* ref */ result) {
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vector, (1 / scale), /* ref */ result);
  };

  function double3_Divide$19 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale);
    var vector = new JSIL.BoxedVariable($vector);
    $S04().CallStatic($thisType, "Divide", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  };

  function double3_Divide$1A (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct((vector.get().x / scale.get().x), (vector.get().y / scale.get().y), (vector.get().z / scale.get().z)));
  };

  function double3_Dot$1B (left, right) {
    return +(((left.x * right.x) + (left.y * right.y)) + (left.z * right.z));
  };

  function double3_Dot$1C (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set((((left.get().x * right.get().x) + (left.get().y * right.get().y)) + (left.get().z * right.get().z)));
  };

  function double3_Object_Equals (obj) {
    return ($thisType.$Is(obj) && this.Equals($thisType.$Cast(obj)));
  };

  function double3_Equals$1D (other) {
    return (!((this.x !== other.x) || 
        (this.y !== other.y)) && (this.z === other.z));
  };

  function double3_get_b () {
    return +this.z;
  };

  function double3_get_g () {
    return +this.y;
  };

  function double3_get_Length () {
    return +Math.sqrt((((this.x * this.x) + (this.y * this.y)) + (this.z * this.z)));
  };

  function double3_get_LengthFast () {
    return +(1 / $S05().CallStatic($T05(), "InverseSqrtFast", null, (((this.x * this.x) + (this.y * this.y)) + (this.z * this.z))));
  };

  function double3_get_LengthSquared () {
    return +(((this.x * this.x) + (this.y * this.y)) + (this.z * this.z));
  };

  function double3_get_Parse () {
    return $thisType.double3$Parse$value;
  };

  function double3_get_r () {
    return +this.x;
  };

  function double3_get_xy () {
    return $S06().Construct(this.x, this.y);
  };

  function double3_GetHashCode () {
    return ((this.x.GetHashCode() ^ this.y.GetHashCode()) ^ this.z.GetHashCode());
  };

  function double3_Lerp$1E (a, b, blend) {
    a.x = +((blend * (b.x - a.x)) + a.x);
    a.y = +((blend * (b.y - a.y)) + a.y);
    a.z = +((blend * (b.z - a.z)) + a.z);
    return a;
  };

  function double3_Lerp$1F (/* ref */ a, /* ref */ b, blend, /* ref */ result) {
    result.get().x = +((blend * (b.get().x - a.get().x)) + a.get().x);
    result.get().y = +((blend * (b.get().y - a.get().y)) + a.get().y);
    result.get().z = +((blend * (b.get().z - a.get().z)) + a.get().z);
  };

  function double3_Max (left, right) {
    return ((left.get_LengthSquared() >= right.get_LengthSquared()) ? left : right);
  };

  function double3_Min (left, right) {
    return ((left.get_LengthSquared() < right.get_LengthSquared()) ? left : right);
  };

  function double3_Mult$20 (f) {
    this.x *= +f;
    this.y *= +f;
    this.z *= +f;
  };

  function double3_Mult$21 (a, f) {
    a.x *= +f;
    a.y *= +f;
    a.z *= +f;
    return a;
  };

  function double3_Mult$22 (/* ref */ a, f, /* ref */ result) {
    result.get().x = +(a.get().x * f);
    result.get().y = +(a.get().y * f);
    result.get().z = +(a.get().z * f);
  };

  function double3_Multiply$23 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  };

  function double3_Multiply$24 (/* ref */ vector, scale, /* ref */ result) {
    result.set($S00().Construct((vector.get().x * scale), (vector.get().y * scale), (vector.get().z * scale)));
  };

  function double3_Multiply$25 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale);
    var vector = new JSIL.BoxedVariable($vector);
    $S07().CallStatic($thisType, "Multiply", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  };

  function double3_Multiply$26 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct((vector.get().x * scale.get().x), (vector.get().y * scale.get().y), (vector.get().z * scale.get().z)));
  };

  function double3_Normalize$27 () {
    var scale = +(1 / this.get_Length());
    this.x *= +scale;
    this.y *= +scale;
    this.z *= +scale;
  };

  function double3_Normalize$28 (vec) {
    var scale = +(1 / vec.get_Length());
    vec.x *= +scale;
    vec.y *= +scale;
    vec.z *= +scale;
    return vec;
  };

  function double3_Normalize$29 (/* ref */ vec, /* ref */ result) {
    var scale = +(1 / vec.get().get_Length());
    result.get().x = +(vec.get().x * scale);
    result.get().y = +(vec.get().y * scale);
    result.get().z = +(vec.get().z * scale);
  };

  function double3_NormalizeFast$2A () {
    var scale = +$S05().CallStatic($T05(), "InverseSqrtFast", null, (((this.x * this.x) + (this.y * this.y)) + (this.z * this.z)));
    this.x *= +scale;
    this.y *= +scale;
    this.z *= +scale;
  };

  function double3_NormalizeFast$2B (vec) {
    var scale = +$S05().CallStatic($T05(), "InverseSqrtFast", null, (((vec.x * vec.x) + (vec.y * vec.y)) + (vec.z * vec.z)));
    vec.x *= +scale;
    vec.y *= +scale;
    vec.z *= +scale;
    return vec;
  };

  function double3_NormalizeFast$2C (/* ref */ vec, /* ref */ result) {
    var scale = +$S05().CallStatic($T05(), "InverseSqrtFast", null, (((vec.get().x * vec.get().x) + (vec.get().y * vec.get().y)) + (vec.get().z * vec.get().z)));
    result.get().x = +(vec.get().x * scale);
    result.get().y = +(vec.get().y * scale);
    result.get().z = +(vec.get().z * scale);
  };

  function double3_op_Addition (left, right) {
    left.x += +right.x;
    left.y += +right.y;
    left.z += +right.z;
    return left;
  };

  function double3_op_Division (vec, scale) {
    var mult = +(1 / scale);
    vec.x *= +mult;
    vec.y *= +mult;
    vec.z *= +mult;
    return vec;
  };

  function double3_op_Equality (left, right) {
    return left.Equals(right);
  };

  function double3_op_Inequality (left, right) {
    return !left.Equals(right);
  };

  function double3_op_Multiply$2D (vec, scale) {
    vec.x *= +scale;
    vec.y *= +scale;
    vec.z *= +scale;
    return vec;
  };

  function double3_op_Multiply$2E (scale, vec) {
    vec.x *= +scale;
    vec.y *= +scale;
    vec.z *= +scale;
    return vec;
  };

  function double3_op_Subtraction (left, right) {
    left.x -= +right.x;
    left.y -= +right.y;
    left.z -= +right.z;
    return left;
  };

  function double3_op_UnaryNegation (vec) {
    vec.x = +-vec.x;
    vec.y = +-vec.y;
    vec.z = +-vec.z;
    return vec;
  };

  function double3_Scale$2F (sx, sy, sz) {
    this.x *= +sx;
    this.y *= +sy;
    this.z *= +sz;
  };

  function double3_Scale$30 (scale) {
    this.x *= +scale.x;
    this.y *= +scale.y;
    this.z *= +scale.z;
  };

  function double3_Scale$31 (/* ref */ scale) {
    this.x *= +scale.get().x;
    this.y *= +scale.get().y;
    this.z *= +scale.get().z;
  };

  function double3_set_b (value) {
    this.z = +value;
  };

  function double3_set_g (value) {
    this.y = +value;
  };

  function double3_set_Parse (value) {
    $thisType.double3$Parse$value = value;
  };

  function double3_set_r (value) {
    this.x = +value;
  };

  function double3_set_xy (value) {
    this.x = +value.x;
    this.y = +value.y;
  };

  function double3_Sub$32 (right) {
    this.x -= +right.x;
    this.y -= +right.y;
    this.z -= +right.z;
  };

  function double3_Sub$33 (/* ref */ right) {
    this.x -= +right.get().x;
    this.y -= +right.get().y;
    this.z -= +right.get().z;
  };

  function double3_Sub$34 (a, b) {
    a.x -= +b.x;
    a.y -= +b.y;
    a.z -= +b.z;
    return a;
  };

  function double3_Sub$35 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(a.get().x - b.get().x);
    result.get().y = +(a.get().y - b.get().y);
    result.get().z = +(a.get().z - b.get().z);
  };

  function double3_Subtract$36 ($a, $b) {
    var b = new JSIL.BoxedVariable($b);
    var a = new JSIL.BoxedVariable($a);
    $thisType.Subtract(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  };

  function double3_Subtract$37 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((a.get().x - b.get().x), (a.get().y - b.get().y), (a.get().z - b.get().z)));
  };

  function double3_ToArray () {
    return JSIL.Array.New($T00(), [this.x, this.y, this.z]);
  };

  function double3_toString () {
    return $T07().Format("({0}, {1}, {2})", this.x, this.y, this.z);
  };

  function double3_Transform$38 ($vec, $mat) {
    var mat = new JSIL.BoxedVariable($mat);
    var vec = new JSIL.BoxedVariable($vec);
    var result = new JSIL.BoxedVariable(new $thisType());
    $S08().CallStatic($thisType, "Transform", null, /* ref */ vec, /* ref */ mat, /* ref */ result);
    return result.get();
  };

  function double3_Transform$39 (/* ref */ vec, /* ref */ mat, /* ref */ result) {
    var v4 = new JSIL.BoxedVariable($S09().Construct(vec.get().x, vec.get().y, vec.get().z, 1));
    $S0A().CallStatic($T02(), "Transform", null, /* ref */ v4, /* ref */ mat, /* ref */ v4);
    result.set(v4.get().get_xyz().MemberwiseClone());
  };

  function double3_Transform$3A ($vec, $quat) {
    var quat = new JSIL.BoxedVariable($quat);
    var vec = new JSIL.BoxedVariable($vec);
    var result = new JSIL.BoxedVariable(new $thisType());
    $S0B().CallStatic($thisType, "Transform", null, /* ref */ vec, /* ref */ quat, /* ref */ result);
    return result.get();
  };

  function double3_Transform$3B (/* ref */ vec, /* ref */ quat, /* ref */ result) {
    var temp = new JSIL.BoxedVariable(new $thisType());
    var temp2 = new JSIL.BoxedVariable(new $thisType());
    var xyz = new JSIL.BoxedVariable(quat.get().get_xyz().MemberwiseClone());
    $thisType.Cross(/* ref */ xyz, /* ref */ vec, /* ref */ temp);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vec, quat.get().get_w(), /* ref */ temp2);
    $thisType.Add(/* ref */ temp, /* ref */ temp2, /* ref */ temp);
    $thisType.Cross(/* ref */ xyz, /* ref */ temp, /* ref */ temp);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ temp, 2, /* ref */ temp);
    $thisType.Add(/* ref */ vec, /* ref */ temp, /* ref */ result);
  };

  function double3_TransformNormal$3C (norm, mat) {
    mat.Invert();
    return $thisType.TransformNormalInverse(norm, mat.MemberwiseClone());
  };

  function double3_TransformNormal$3D (/* ref */ norm, /* ref */ mat, /* ref */ result) {
    var Inverse = new JSIL.BoxedVariable($T08().Invert(mat.get().MemberwiseClone()).MemberwiseClone());
    $thisType.TransformNormalInverse(/* ref */ norm, /* ref */ Inverse, /* ref */ result);
  };

  function double3_TransformNormalInverse$3E (norm, invMat) {
    var i = new $thisType();
    i.x = +$thisType.Dot(norm, $S0C().Construct(invMat.Row0.MemberwiseClone()));
    i.y = +$thisType.Dot(norm, $S0C().Construct(invMat.Row1.MemberwiseClone()));
    i.z = +$thisType.Dot(norm, $S0C().Construct(invMat.Row2.MemberwiseClone()));
    return i;
  };

  function double3_TransformNormalInverse$3F (/* ref */ norm, /* ref */ invMat, /* ref */ result) {
    result.get().x = +(((norm.get().x * invMat.get().Row0.x) + (norm.get().y * invMat.get().Row0.y)) + (norm.get().z * invMat.get().Row0.z));
    result.get().y = +(((norm.get().x * invMat.get().Row1.x) + (norm.get().y * invMat.get().Row1.y)) + (norm.get().z * invMat.get().Row1.z));
    result.get().z = +(((norm.get().x * invMat.get().Row2.x) + (norm.get().y * invMat.get().Row2.y)) + (norm.get().z * invMat.get().Row2.z));
  };

  function double3_TransformPerspective$40 ($vec, $mat) {
    var mat = new JSIL.BoxedVariable($mat);
    var vec = new JSIL.BoxedVariable($vec);
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.TransformPerspective(/* ref */ vec, /* ref */ mat, /* ref */ result);
    return result.get();
  };

  function double3_TransformPerspective$41 (/* ref */ vec, /* ref */ mat, /* ref */ result) {
    var v = new JSIL.BoxedVariable($S0D().Construct(vec.get().MemberwiseClone()));
    $S0A().CallStatic($T02(), "Transform", null, /* ref */ v, /* ref */ mat, /* ref */ v);
    result.get().x = +(v.get().x / v.get().w);
    result.get().y = +(v.get().y / v.get().w);
    result.get().z = +(v.get().z / v.get().w);
  };

  function double3_TransformPosition$42 (pos, mat) {
    var p = new $thisType();
    p.x = +($thisType.Dot(pos, $S0C().Construct(mat.get_Column0().MemberwiseClone())) + mat.Row3.x);
    p.y = +($thisType.Dot(pos, $S0C().Construct(mat.get_Column1().MemberwiseClone())) + mat.Row3.y);
    p.z = +($thisType.Dot(pos, $S0C().Construct(mat.get_Column2().MemberwiseClone())) + mat.Row3.z);
    return p;
  };

  function double3_TransformPosition$43 (/* ref */ pos, /* ref */ mat, /* ref */ result) {
    result.get().x = +((((pos.get().x * mat.get().Row0.x) + (pos.get().y * mat.get().Row1.x)) + (pos.get().z * mat.get().Row2.x)) + mat.get().Row3.x);
    result.get().y = +((((pos.get().x * mat.get().Row0.y) + (pos.get().y * mat.get().Row1.y)) + (pos.get().z * mat.get().Row2.y)) + mat.get().Row3.y);
    result.get().z = +((((pos.get().x * mat.get().Row0.z) + (pos.get().y * mat.get().Row1.z)) + (pos.get().z * mat.get().Row2.z)) + mat.get().Row3.z);
  };

  function double3_TransformVector$44 (vec, mat) {
    var v = new $thisType();
    v.x = +$thisType.Dot(vec, $S0C().Construct(mat.get_Column0().MemberwiseClone()));
    v.y = +$thisType.Dot(vec, $S0C().Construct(mat.get_Column1().MemberwiseClone()));
    v.z = +$thisType.Dot(vec, $S0C().Construct(mat.get_Column2().MemberwiseClone()));
    return v;
  };

  function double3_TransformVector$45 (/* ref */ vec, /* ref */ mat, /* ref */ result) {
    result.get().x = +(((vec.get().x * mat.get().Row0.x) + (vec.get().y * mat.get().Row1.x)) + (vec.get().z * mat.get().Row2.x));
    result.get().y = +(((vec.get().x * mat.get().Row0.y) + (vec.get().y * mat.get().Row1.y)) + (vec.get().z * mat.get().Row2.y));
    result.get().z = +(((vec.get().x * mat.get().Row0.z) + (vec.get().y * mat.get().Row1.z)) + (vec.get().z * mat.get().Row2.z));
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.double3", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 3, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double
        ], []), 
      double3__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.double2")], []), 
      double3__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.Type], []), 
      double3__ctor$02
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.double4")], []), 
      double3__ctor$03
    );

    $.Method({Static:false, Public:true }, "Add", 
      new JSIL.MethodSignature(null, [$.Type], []), 
      double3_Add$04
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:false, Public:true }, "Add", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      double3_Add$05
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double3_Add$06
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double3_Add$07
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type, $.Double, 
          $.Double
        ], []), 
      double3_BaryCentric$08
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double3_BaryCentric$09
    );

    $.Method({Static:true , Public:true }, "CalculateAngle", 
      new JSIL.MethodSignature($.Double, [$.Type, $.Type], []), 
      double3_CalculateAngle$0A
    );

    $.Method({Static:true , Public:true }, "CalculateAngle", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Double])
        ], []), 
      double3_CalculateAngle$0B
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type
        ], []), 
      double3_Clamp$0C
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double3_Clamp$0D
    );

    $.Method({Static:true , Public:true }, "ComponentMax", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double3_ComponentMax$0E
    );

    $.Method({Static:true , Public:true }, "ComponentMax", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double3_ComponentMax$0F
    );

    $.Method({Static:true , Public:true }, "ComponentMin", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double3_ComponentMin$10
    );

    $.Method({Static:true , Public:true }, "ComponentMin", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double3_ComponentMin$11
    );

    $.Method({Static:true , Public:true }, "Cross", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double3_Cross$12
    );

    $.Method({Static:true , Public:true }, "Cross", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double3_Cross$13
    );

    $.Method({Static:false, Public:true }, "Div", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double3_Div$14
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double], []), 
      double3_Div$15
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double3_Div$16
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double], []), 
      double3_Divide$17
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double3_Divide$18
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double3_Divide$19
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double3_Divide$1A
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature($.Double, [$.Type, $.Type], []), 
      double3_Dot$1B
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Double])
        ], []), 
      double3_Dot$1C
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object], []), 
      double3_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type], []), 
      double3_Equals$1D
    );

    $.Method({Static:false, Public:true }, "get_b", 
      new JSIL.MethodSignature($.Double, [], []), 
      double3_get_b
    );

    $.Method({Static:false, Public:true }, "get_g", 
      new JSIL.MethodSignature($.Double, [], []), 
      double3_get_g
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      new JSIL.MethodSignature($.Double, [], []), 
      double3_get_Length
    );

    $.Method({Static:false, Public:true }, "get_LengthFast", 
      new JSIL.MethodSignature($.Double, [], []), 
      double3_get_LengthFast
    );

    $.Method({Static:false, Public:true }, "get_LengthSquared", 
      new JSIL.MethodSignature($.Double, [], []), 
      double3_get_LengthSquared
    );

    $.Method({Static:true , Public:true }, "get_Parse", 
      new JSIL.MethodSignature($asm07.TypeRef("System.Converter`2", [$.String, $.Type]), [], []), 
      double3_get_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_r", 
      new JSIL.MethodSignature($.Double, [], []), 
      double3_get_r
    );

    $.Method({Static:false, Public:true }, "get_xy", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double2"), [], []), 
      double3_get_xy
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      new JSIL.MethodSignature($.Int32, [], []), 
      double3_GetHashCode
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Double
        ], []), 
      double3_Lerp$1E
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double3_Lerp$1F
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double3_Max
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double3_Min
    );

    $.Method({Static:false, Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double3_Mult$20
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double], []), 
      double3_Mult$21
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double3_Mult$22
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double], []), 
      double3_Multiply$23
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double3_Multiply$24
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double3_Multiply$25
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double3_Multiply$26
    );

    $.Method({Static:false, Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [], []), 
      double3_Normalize$27
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      double3_Normalize$28
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      double3_Normalize$29
    );

    $.Method({Static:false, Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature(null, [], []), 
      double3_NormalizeFast$2A
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      double3_NormalizeFast$2B
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      double3_NormalizeFast$2C
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double3_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Division", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double], []), 
      double3_op_Division
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type], []), 
      double3_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type], []), 
      double3_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double], []), 
      double3_op_Multiply$2D
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Double, $.Type], []), 
      double3_op_Multiply$2E
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double3_op_Subtraction
    );

    $.Method({Static:true , Public:true }, "op_UnaryNegation", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      double3_op_UnaryNegation
    );

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double
        ], []), 
      double3_Scale$2F
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [$.Type], []), 
      double3_Scale$30
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      double3_Scale$31
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "set_b", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double3_set_b
    );

    $.Method({Static:false, Public:true }, "set_g", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double3_set_g
    );

    $.Method({Static:true , Public:true }, "set_Parse", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("System.Converter`2", [$.String, $.Type])], []), 
      double3_set_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "set_r", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double3_set_r
    );

    $.Method({Static:false, Public:true }, "set_xy", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.double2")], []), 
      double3_set_xy
    );

    $.Method({Static:false, Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [$.Type], []), 
      double3_Sub$32
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:false, Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      double3_Sub$33
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double3_Sub$34
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double3_Sub$35
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double3_Subtract$36
    );

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double3_Subtract$37
    );

    $.Method({Static:false, Public:true }, "ToArray", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Double]), [], []), 
      double3_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      new JSIL.MethodSignature($.String, [], []), 
      double3_toString
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.double4x4")], []), 
      double3_Transform$38
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double3_Transform$39
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.QuaternionD")], []), 
      double3_Transform$3A
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double3_Transform$3B
    );

    $.Method({Static:true , Public:true }, "TransformNormal", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.double4x4")], []), 
      double3_TransformNormal$3C
    );

    $.Method({Static:true , Public:true }, "TransformNormal", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double3_TransformNormal$3D
    );

    $.Method({Static:true , Public:true }, "TransformNormalInverse", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.double4x4")], []), 
      double3_TransformNormalInverse$3E
    );

    $.Method({Static:true , Public:true }, "TransformNormalInverse", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double3_TransformNormalInverse$3F
    );

    $.Method({Static:true , Public:true }, "TransformPerspective", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.double4x4")], []), 
      double3_TransformPerspective$40
    );

    $.Method({Static:true , Public:true }, "TransformPerspective", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double3_TransformPerspective$41
    );

    $.Method({Static:true , Public:true }, "TransformPosition", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.double4x4")], []), 
      double3_TransformPosition$42
    );

    $.Method({Static:true , Public:true }, "TransformPosition", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double3_TransformPosition$43
    );

    $.Method({Static:true , Public:true }, "TransformVector", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.double4x4")], []), 
      double3_TransformVector$44
    );

    $.Method({Static:true , Public:true }, "TransformVector", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double3_TransformVector$45
    );

    $.Field({Static:false, Public:true }, "x", $.Double); 
    $.Field({Static:false, Public:true }, "y", $.Double); 
    $.Field({Static:false, Public:true }, "z", $.Double); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitX", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitY", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitZ", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "Zero", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "One", $.Type); 
    $.Field({Static:true , Public:false}, "double3$Parse$value", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]))
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    function double3__cctor () {
      $thisType.UnitX = new $thisType();
      $thisType.UnitY = new $thisType();
      $thisType.UnitZ = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.One = new $thisType();
      $thisType.UnitX = $S00().Construct(1, 0, 0);
      $thisType.UnitY = $S00().Construct(0, 1, 0);
      $thisType.UnitZ = $S00().Construct(0, 0, 1);
      $thisType.Zero = $S00().Construct(0, 0, 0);
      $thisType.One = $S00().Construct(1, 1, 1);
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      new JSIL.MethodSignature(null, [], []), 
      double3__cctor
    );

    $.Property({Static:false, Public:true }, "Length", $.Double);

    $.Property({Static:false, Public:true }, "LengthFast", $.Double);

    $.Property({Static:false, Public:true }, "LengthSquared", $.Double);

    $.Property({Static:false, Public:true }, "xy", $asm04.TypeRef("Fusee.Math.double2"));

    $.Property({Static:false, Public:true }, "r", $.Double);

    $.Property({Static:false, Public:true }, "g", $.Double);

    $.Property({Static:false, Public:true }, "b", $.Double);

    $.Property({Static:true , Public:true }, "Parse", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]));

    $.ImplementInterfaces(
      /* 0 */ $asm07.TypeRef("System.IEquatable`1", [$.Type])
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Math.double4 */ 

(function double4$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm07.System.Double)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Math.double2)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Math.double3)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.System.Void)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm04.Fusee.Math.MathHelper)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm07.System.Converter$b2.Of($asm07.System.String, $asm04.Fusee.Math.double4))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm07.System.String)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm04.Fusee.Math.double4x4)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm04.Fusee.Math.QuaternionD)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double4"), [
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double4"), [$asm07.TypeRef("System.Double"), $asm04.TypeRef("Fusee.Math.double4")], []))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")]), $asm07.TypeRef("System.Double"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")])
      ], []))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")]), $asm07.TypeRef("System.Double"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")])
      ], []))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")])
      ], []))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("System.Double"), [$asm07.TypeRef("System.Double")], []))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double2"), [$asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double")]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double3"), [
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double")
      ]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")])
      ], []))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4x4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")])
      ], []))) ();
  };
  var $S0A = function () {
    return ($S0A = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4")])
      ], []))) ();
  };
  var $S0B = function () {
    return ($S0B = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.QuaternionD"), [
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double")
      ]))) ();
  };
  var $S0C = function () {
    return ($S0C = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")])
      ], []))) ();
  };

  function double4__ctor$00 (x, y, z, w) {
    this.x = +x;
    this.y = +y;
    this.z = +z;
    this.w = +w;
  };

  function double4__ctor$01 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +0;
    this.w = +0;
  };

  function double4__ctor$02 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
    this.w = +0;
  };

  function double4__ctor$03 (v, ww) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
    this.w = +ww;
  };

  function double4__ctor$04 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
    this.w = +v.w;
  };

  function double4_Add$05 (right) {
    this.x += +right.x;
    this.y += +right.y;
    this.z += +right.z;
    this.w += +right.w;
  };

  function double4_Add$06 (/* ref */ right) {
    this.x += +right.get().x;
    this.y += +right.get().y;
    this.z += +right.get().z;
    this.w += +right.get().w;
  };

  function double4_Add$07 ($a, $b) {
    var b = new JSIL.BoxedVariable($b);
    var a = new JSIL.BoxedVariable($a);
    $thisType.Add(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  };

  function double4_Add$08 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((a.get().x + b.get().x), (a.get().y + b.get().y), (a.get().z + b.get().z), (a.get().w + b.get().w)));
  };

  function double4_BaryCentric$09 (a, b, c, u, v) {
    return $thisType.op_Addition(
      $thisType.op_Addition(a.MemberwiseClone(), $S01().CallStatic($thisType, "op_Multiply", null, u, $thisType.op_Subtraction(b, a.MemberwiseClone()))).MemberwiseClone(), 
      $S01().CallStatic($thisType, "op_Multiply", null, v, $thisType.op_Subtraction(c, a.MemberwiseClone()))
    );
  };

  function double4_BaryCentric$0A (/* ref */ a, /* ref */ b, /* ref */ c, u, v, /* ref */ result) {
    result.set(a.get().MemberwiseClone());
    var temp = new JSIL.BoxedVariable(b.get().MemberwiseClone());
    $thisType.Subtract(/* ref */ temp, /* ref */ a, /* ref */ temp);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ temp, u, /* ref */ temp);
    $thisType.Add(/* ref */ result, /* ref */ temp, /* ref */ result);
    temp.set(c.get().MemberwiseClone());
    $thisType.Subtract(/* ref */ temp, /* ref */ a, /* ref */ temp);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ temp, v, /* ref */ temp);
    $thisType.Add(/* ref */ result, /* ref */ temp, /* ref */ result);
  };

  function double4_Clamp$0B (vec, min, max) {
    vec.x = +((vec.x < min.x) ? min.x : ((vec.x > max.x) ? max.x : vec.x));
    vec.y = +((vec.y < min.y) ? min.y : ((vec.y > max.y) ? max.y : vec.y));
    vec.z = +((vec.x < min.z) ? min.z : ((vec.z > max.z) ? max.z : vec.z));
    vec.w = +((vec.y < min.w) ? min.w : ((vec.w > max.w) ? max.w : vec.w));
    return vec;
  };

  function double4_Clamp$0C (/* ref */ vec, /* ref */ min, /* ref */ max, /* ref */ result) {
    result.get().x = +((vec.get().x < min.get().x) ? min.get().x : ((vec.get().x > max.get().x) ? max.get().x : vec.get().x));
    result.get().y = +((vec.get().y < min.get().y) ? min.get().y : ((vec.get().y > max.get().y) ? max.get().y : vec.get().y));
    result.get().z = +((vec.get().x < min.get().z) ? min.get().z : ((vec.get().z > max.get().z) ? max.get().z : vec.get().z));
    result.get().w = +((vec.get().y < min.get().w) ? min.get().w : ((vec.get().w > max.get().w) ? max.get().w : vec.get().w));
  };

  function double4_Div$0D (f) {
    var mult = +(1 / f);
    this.x *= +mult;
    this.y *= +mult;
    this.z *= +mult;
    this.w *= +mult;
  };

  function double4_Div$0E (a, f) {
    var mult = +(1 / f);
    a.x *= +mult;
    a.y *= +mult;
    a.z *= +mult;
    a.w *= +mult;
    return a;
  };

  function double4_Div$0F (/* ref */ a, f, /* ref */ result) {
    var mult = +(1 / f);
    result.get().x = +(a.get().x * mult);
    result.get().y = +(a.get().y * mult);
    result.get().z = +(a.get().z * mult);
    result.get().w = +(a.get().w * mult);
  };

  function double4_Divide$10 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector);
    $S03().CallStatic($thisType, "Divide", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  };

  function double4_Divide$11 (/* ref */ vector, scale, /* ref */ result) {
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vector, (1 / scale), /* ref */ result);
  };

  function double4_Divide$12 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale);
    var vector = new JSIL.BoxedVariable($vector);
    $S04().CallStatic($thisType, "Divide", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  };

  function double4_Divide$13 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct((vector.get().x / scale.get().x), (vector.get().y / scale.get().y), (vector.get().z / scale.get().z), (vector.get().w / scale.get().w)));
  };

  function double4_Dot$14 (left, right) {
    return +((((left.x * right.x) + (left.y * right.y)) + (left.z * right.z)) + (left.w * right.w));
  };

  function double4_Dot$15 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set(((((left.get().x * right.get().x) + (left.get().y * right.get().y)) + (left.get().z * right.get().z)) + (left.get().w * right.get().w)));
  };

  function double4_Object_Equals (obj) {
    return ($thisType.$Is(obj) && this.Equals($thisType.$Cast(obj)));
  };

  function double4_Equals$16 (other) {
    return (!((this.x !== other.x) || 
        (this.y !== other.y) || 
        (this.z !== other.z)) && (this.w === other.w));
  };

  function double4_get_a () {
    return +this.w;
  };

  function double4_get_b () {
    return +this.z;
  };

  function double4_get_g () {
    return +this.y;
  };

  function double4_get_Length () {
    return +Math.sqrt(((((this.x * this.x) + (this.y * this.y)) + (this.z * this.z)) + (this.w * this.w)));
  };

  function double4_get_LengthFast () {
    return +(1 / $S05().CallStatic($T05(), "InverseSqrtFast", null, ((((this.x * this.x) + (this.y * this.y)) + (this.z * this.z)) + (this.w * this.w))));
  };

  function double4_get_LengthSquared () {
    return +((((this.x * this.x) + (this.y * this.y)) + (this.z * this.z)) + (this.w * this.w));
  };

  function double4_get_Parse () {
    return $thisType.double4$Parse$value;
  };

  function double4_get_r () {
    return +this.x;
  };

  function double4_get_rgb () {
    return this.get_xyz();
  };

  function double4_get_xy () {
    return $S06().Construct(this.x, this.y);
  };

  function double4_get_xyz () {
    return $S07().Construct(this.x, this.y, this.z);
  };

  function double4_GetHashCode () {
    return (((this.x.GetHashCode() ^ this.y.GetHashCode()) ^ this.z.GetHashCode()) ^ this.w.GetHashCode());
  };

  function double4_Lerp$17 (a, b, blend) {
    a.x = +((blend * (b.x - a.x)) + a.x);
    a.y = +((blend * (b.y - a.y)) + a.y);
    a.z = +((blend * (b.z - a.z)) + a.z);
    a.w = +((blend * (b.w - a.w)) + a.w);
    return a;
  };

  function double4_Lerp$18 (/* ref */ a, /* ref */ b, blend, /* ref */ result) {
    result.get().x = +((blend * (b.get().x - a.get().x)) + a.get().x);
    result.get().y = +((blend * (b.get().y - a.get().y)) + a.get().y);
    result.get().z = +((blend * (b.get().z - a.get().z)) + a.get().z);
    result.get().w = +((blend * (b.get().w - a.get().w)) + a.get().w);
  };

  function double4_Max$19 (a, b) {
    a.x = +((a.x > b.x) ? a.x : b.x);
    a.y = +((a.y > b.y) ? a.y : b.y);
    a.z = +((a.z > b.z) ? a.z : b.z);
    a.w = +((a.w > b.w) ? a.w : b.w);
    return a;
  };

  function double4_Max$1A (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +((a.get().x > b.get().x) ? a.get().x : b.get().x);
    result.get().y = +((a.get().y > b.get().y) ? a.get().y : b.get().y);
    result.get().z = +((a.get().z > b.get().z) ? a.get().z : b.get().z);
    result.get().w = +((a.get().w > b.get().w) ? a.get().w : b.get().w);
  };

  function double4_Min$1B (a, b) {
    a.x = +((a.x < b.x) ? a.x : b.x);
    a.y = +((a.y < b.y) ? a.y : b.y);
    a.z = +((a.z < b.z) ? a.z : b.z);
    a.w = +((a.w < b.w) ? a.w : b.w);
    return a;
  };

  function double4_Min$1C (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +((a.get().x < b.get().x) ? a.get().x : b.get().x);
    result.get().y = +((a.get().y < b.get().y) ? a.get().y : b.get().y);
    result.get().z = +((a.get().z < b.get().z) ? a.get().z : b.get().z);
    result.get().w = +((a.get().w < b.get().w) ? a.get().w : b.get().w);
  };

  function double4_Mult$1D (f) {
    this.x *= +f;
    this.y *= +f;
    this.z *= +f;
    this.w *= +f;
  };

  function double4_Mult$1E (a, f) {
    a.x *= +f;
    a.y *= +f;
    a.z *= +f;
    a.w *= +f;
    return a;
  };

  function double4_Mult$1F (/* ref */ a, f, /* ref */ result) {
    result.get().x = +(a.get().x * f);
    result.get().y = +(a.get().y * f);
    result.get().z = +(a.get().z * f);
    result.get().w = +(a.get().w * f);
  };

  function double4_Multiply$20 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  };

  function double4_Multiply$21 (/* ref */ vector, scale, /* ref */ result) {
    result.set($S00().Construct((vector.get().x * scale), (vector.get().y * scale), (vector.get().z * scale), (vector.get().w * scale)));
  };

  function double4_Multiply$22 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale);
    var vector = new JSIL.BoxedVariable($vector);
    $S08().CallStatic($thisType, "Multiply", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  };

  function double4_Multiply$23 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct((vector.get().x * scale.get().x), (vector.get().y * scale.get().y), (vector.get().z * scale.get().z), (vector.get().w * scale.get().w)));
  };

  function double4_Normalize$24 () {
    var scale = +(1 / this.get_Length());
    this.x *= +scale;
    this.y *= +scale;
    this.z *= +scale;
    this.w *= +scale;
  };

  function double4_Normalize$25 (vec) {
    var scale = +(1 / vec.get_Length());
    vec.x *= +scale;
    vec.y *= +scale;
    vec.z *= +scale;
    vec.w *= +scale;
    return vec;
  };

  function double4_Normalize$26 (/* ref */ vec, /* ref */ result) {
    var scale = +(1 / vec.get().get_Length());
    result.get().x = +(vec.get().x * scale);
    result.get().y = +(vec.get().y * scale);
    result.get().z = +(vec.get().z * scale);
    result.get().w = +(vec.get().w * scale);
  };

  function double4_NormalizeFast$27 () {
    var scale = +$S05().CallStatic($T05(), "InverseSqrtFast", null, ((((this.x * this.x) + (this.y * this.y)) + (this.z * this.z)) + (this.w * this.w)));
    this.x *= +scale;
    this.y *= +scale;
    this.z *= +scale;
    this.w *= +scale;
  };

  function double4_NormalizeFast$28 (vec) {
    var scale = +$S05().CallStatic($T05(), "InverseSqrtFast", null, ((((vec.x * vec.x) + (vec.y * vec.y)) + (vec.z * vec.z)) + (vec.w * vec.w)));
    vec.x *= +scale;
    vec.y *= +scale;
    vec.z *= +scale;
    vec.w *= +scale;
    return vec;
  };

  function double4_NormalizeFast$29 (/* ref */ vec, /* ref */ result) {
    var scale = +$S05().CallStatic($T05(), "InverseSqrtFast", null, ((((vec.get().x * vec.get().x) + (vec.get().y * vec.get().y)) + (vec.get().z * vec.get().z)) + (vec.get().w * vec.get().w)));
    result.get().x = +(vec.get().x * scale);
    result.get().y = +(vec.get().y * scale);
    result.get().z = +(vec.get().z * scale);
    result.get().w = +(vec.get().w * scale);
  };

  function double4_op_Addition (left, right) {
    left.x += +right.x;
    left.y += +right.y;
    left.z += +right.z;
    left.w += +right.w;
    return left;
  };

  function double4_op_Division (vec, scale) {
    var mult = +(1 / scale);
    vec.x *= +mult;
    vec.y *= +mult;
    vec.z *= +mult;
    vec.w *= +mult;
    return vec;
  };

  function double4_op_Equality (left, right) {
    return left.Equals(right);
  };

  function double4_op_Inequality (left, right) {
    return !left.Equals(right);
  };

  function double4_op_Multiply$2A (vec, scale) {
    vec.x *= +scale;
    vec.y *= +scale;
    vec.z *= +scale;
    vec.w *= +scale;
    return vec;
  };

  function double4_op_Multiply$2B (scale, vec) {
    vec.x *= +scale;
    vec.y *= +scale;
    vec.z *= +scale;
    vec.w *= +scale;
    return vec;
  };

  function double4_op_Subtraction (left, right) {
    left.x -= +right.x;
    left.y -= +right.y;
    left.z -= +right.z;
    left.w -= +right.w;
    return left;
  };

  function double4_op_UnaryNegation (vec) {
    vec.x = +-vec.x;
    vec.y = +-vec.y;
    vec.z = +-vec.z;
    vec.w = +-vec.w;
    return vec;
  };

  function double4_Scale$2C (sx, sy, sz, sw) {
    this.x *= +sx;
    this.y *= +sy;
    this.z *= +sz;
    this.w *= +sw;
  };

  function double4_Scale$2D (scale) {
    this.x *= +scale.x;
    this.y *= +scale.y;
    this.z *= +scale.z;
    this.w *= +scale.w;
  };

  function double4_Scale$2E (/* ref */ scale) {
    this.x *= +scale.get().x;
    this.y *= +scale.get().y;
    this.z *= +scale.get().z;
    this.w *= +scale.get().w;
  };

  function double4_set_a (value) {
    this.w = +value;
  };

  function double4_set_b (value) {
    this.z = +value;
  };

  function double4_set_g (value) {
    this.y = +value;
  };

  function double4_set_Parse (value) {
    $thisType.double4$Parse$value = value;
  };

  function double4_set_r (value) {
    this.x = +value;
  };

  function double4_set_rgb (value) {
    (this.xyz = value);
  };

  function double4_set_xy (value) {
    this.x = +value.x;
    this.y = +value.y;
  };

  function double4_set_xyz (value) {
    this.x = +value.x;
    this.y = +value.y;
    this.z = +value.z;
  };

  function double4_Sub$2F (right) {
    this.x -= +right.x;
    this.y -= +right.y;
    this.z -= +right.z;
    this.w -= +right.w;
  };

  function double4_Sub$30 (/* ref */ right) {
    this.x -= +right.get().x;
    this.y -= +right.get().y;
    this.z -= +right.get().z;
    this.w -= +right.get().w;
  };

  function double4_Sub$31 (a, b) {
    a.x -= +b.x;
    a.y -= +b.y;
    a.z -= +b.z;
    a.w -= +b.w;
    return a;
  };

  function double4_Sub$32 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(a.get().x - b.get().x);
    result.get().y = +(a.get().y - b.get().y);
    result.get().z = +(a.get().z - b.get().z);
    result.get().w = +(a.get().w - b.get().w);
  };

  function double4_Subtract$33 ($a, $b) {
    var b = new JSIL.BoxedVariable($b);
    var a = new JSIL.BoxedVariable($a);
    $thisType.Subtract(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  };

  function double4_Subtract$34 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((a.get().x - b.get().x), (a.get().y - b.get().y), (a.get().z - b.get().z), (a.get().w - b.get().w)));
  };

  function double4_ToArray () {
    return JSIL.Array.New($T00(), [this.x, this.y, this.z, this.w]);
  };

  function double4_toString () {
    return $T07().Format("({0}, {1}, {2}, {3})", JSIL.Array.New($T03(), [this.x, this.y, this.z, this.w]));
  };

  function double4_Transform$35 ($vec, $mat) {
    var mat = new JSIL.BoxedVariable($mat);
    var vec = new JSIL.BoxedVariable($vec);
    var result = new JSIL.BoxedVariable(new $thisType());
    $S09().CallStatic($thisType, "Transform", null, /* ref */ vec, /* ref */ mat, /* ref */ result);
    return result.get();
  };

  function double4_Transform$36 (/* ref */ vec, /* ref */ mat, /* ref */ result) {
    result.set($S00().Construct(((((vec.get().x * mat.get().Row0.x) + (vec.get().y * mat.get().Row1.x)) + (vec.get().z * mat.get().Row2.x)) + (vec.get().w * mat.get().Row3.x)), ((((vec.get().x * mat.get().Row0.y) + (vec.get().y * mat.get().Row1.y)) + (vec.get().z * mat.get().Row2.y)) + (vec.get().w * mat.get().Row3.y)), ((((vec.get().x * mat.get().Row0.z) + (vec.get().y * mat.get().Row1.z)) + (vec.get().z * mat.get().Row2.z)) + (vec.get().w * mat.get().Row3.z)), ((((vec.get().x * mat.get().Row0.w) + (vec.get().y * mat.get().Row1.w)) + (vec.get().z * mat.get().Row2.w)) + (vec.get().w * mat.get().Row3.w))));
  };

  function double4_Transform$37 ($vec, $quat) {
    var quat = new JSIL.BoxedVariable($quat);
    var vec = new JSIL.BoxedVariable($vec);
    var result = new JSIL.BoxedVariable(new $thisType());
    $S0A().CallStatic($thisType, "Transform", null, /* ref */ vec, /* ref */ quat, /* ref */ result);
    return result.get();
  };

  function double4_Transform$38 (/* ref */ vec, /* ref */ quat, /* ref */ result) {
    var i = new JSIL.BoxedVariable(new ($T09())());
    var t = new JSIL.BoxedVariable(new ($T09())());
    var v = new JSIL.BoxedVariable($S0B().Construct(vec.get().x, vec.get().y, vec.get().z, vec.get().w));
    $T09().Invert(/* ref */ quat, /* ref */ i);
    $S0C().CallStatic($T09(), "Multiply", null, /* ref */ quat, /* ref */ v, /* ref */ t);
    $S0C().CallStatic($T09(), "Multiply", null, /* ref */ t, /* ref */ i, /* ref */ v);
    result.set($S00().Construct(v.get().get_x(), v.get().get_y(), v.get().get_z(), v.get().get_w()));
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.double4", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 4, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double
        ], []), 
      double4__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.double2")], []), 
      double4__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.double3")], []), 
      double4__ctor$02
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.double3"), $.Double], []), 
      double4__ctor$03
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.Type], []), 
      double4__ctor$04
    );

    $.Method({Static:false, Public:true }, "Add", 
      new JSIL.MethodSignature(null, [$.Type], []), 
      double4_Add$05
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:false, Public:true }, "Add", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      double4_Add$06
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double4_Add$07
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4_Add$08
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type, $.Double, 
          $.Double
        ], []), 
      double4_BaryCentric$09
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4_BaryCentric$0A
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type
        ], []), 
      double4_Clamp$0B
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4_Clamp$0C
    );

    $.Method({Static:false, Public:true }, "Div", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double4_Div$0D
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double], []), 
      double4_Div$0E
    );

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4_Div$0F
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double], []), 
      double4_Divide$10
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4_Divide$11
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double4_Divide$12
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4_Divide$13
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature($.Double, [$.Type, $.Type], []), 
      double4_Dot$14
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Double])
        ], []), 
      double4_Dot$15
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object], []), 
      double4_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type], []), 
      double4_Equals$16
    );

    $.Method({Static:false, Public:true }, "get_a", 
      new JSIL.MethodSignature($.Double, [], []), 
      double4_get_a
    );

    $.Method({Static:false, Public:true }, "get_b", 
      new JSIL.MethodSignature($.Double, [], []), 
      double4_get_b
    );

    $.Method({Static:false, Public:true }, "get_g", 
      new JSIL.MethodSignature($.Double, [], []), 
      double4_get_g
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      new JSIL.MethodSignature($.Double, [], []), 
      double4_get_Length
    );

    $.Method({Static:false, Public:true }, "get_LengthFast", 
      new JSIL.MethodSignature($.Double, [], []), 
      double4_get_LengthFast
    );

    $.Method({Static:false, Public:true }, "get_LengthSquared", 
      new JSIL.MethodSignature($.Double, [], []), 
      double4_get_LengthSquared
    );

    $.Method({Static:true , Public:true }, "get_Parse", 
      new JSIL.MethodSignature($asm07.TypeRef("System.Converter`2", [$.String, $.Type]), [], []), 
      double4_get_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_r", 
      new JSIL.MethodSignature($.Double, [], []), 
      double4_get_r
    );

    $.Method({Static:false, Public:true }, "get_rgb", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double3"), [], []), 
      double4_get_rgb
    );

    $.Method({Static:false, Public:true }, "get_xy", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double2"), [], []), 
      double4_get_xy
    );

    $.Method({Static:false, Public:true }, "get_xyz", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double3"), [], []), 
      double4_get_xyz
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      new JSIL.MethodSignature($.Int32, [], []), 
      double4_GetHashCode
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Double
        ], []), 
      double4_Lerp$17
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4_Lerp$18
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double4_Max$19
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4_Max$1A
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double4_Min$1B
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4_Min$1C
    );

    $.Method({Static:false, Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double4_Mult$1D
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double], []), 
      double4_Mult$1E
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4_Mult$1F
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double], []), 
      double4_Multiply$20
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4_Multiply$21
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double4_Multiply$22
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4_Multiply$23
    );

    $.Method({Static:false, Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [], []), 
      double4_Normalize$24
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      double4_Normalize$25
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      double4_Normalize$26
    );

    $.Method({Static:false, Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature(null, [], []), 
      double4_NormalizeFast$27
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      double4_NormalizeFast$28
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      double4_NormalizeFast$29
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double4_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Division", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double], []), 
      double4_op_Division
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type], []), 
      double4_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type], []), 
      double4_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double], []), 
      double4_op_Multiply$2A
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Double, $.Type], []), 
      double4_op_Multiply$2B
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double4_op_Subtraction
    );

    $.Method({Static:true , Public:true }, "op_UnaryNegation", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      double4_op_UnaryNegation
    );

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double
        ], []), 
      double4_Scale$2C
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [$.Type], []), 
      double4_Scale$2D
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      double4_Scale$2E
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "set_a", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double4_set_a
    );

    $.Method({Static:false, Public:true }, "set_b", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double4_set_b
    );

    $.Method({Static:false, Public:true }, "set_g", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double4_set_g
    );

    $.Method({Static:true , Public:true }, "set_Parse", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("System.Converter`2", [$.String, $.Type])], []), 
      double4_set_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "set_r", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double4_set_r
    );

    $.Method({Static:false, Public:true }, "set_rgb", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.double3")], []), 
      double4_set_rgb
    );

    $.Method({Static:false, Public:true }, "set_xy", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.double2")], []), 
      double4_set_xy
    );

    $.Method({Static:false, Public:true }, "set_xyz", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.double3")], []), 
      double4_set_xyz
    );

    $.Method({Static:false, Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [$.Type], []), 
      double4_Sub$2F
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:false, Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      double4_Sub$30
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double4_Sub$31
    );

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4_Sub$32
    );

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double4_Subtract$33
    );

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4_Subtract$34
    );

    $.Method({Static:false, Public:true }, "ToArray", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Double]), [], []), 
      double4_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      new JSIL.MethodSignature($.String, [], []), 
      double4_toString
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.double4x4")], []), 
      double4_Transform$35
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4_Transform$36
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.QuaternionD")], []), 
      double4_Transform$37
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4_Transform$38
    );

    $.Field({Static:false, Public:true }, "x", $.Double); 
    $.Field({Static:false, Public:true }, "y", $.Double); 
    $.Field({Static:false, Public:true }, "z", $.Double); 
    $.Field({Static:false, Public:true }, "w", $.Double); 
    $.Field({Static:true , Public:true }, "UnitX", $.Type); 
    $.Field({Static:true , Public:true }, "UnitY", $.Type); 
    $.Field({Static:true , Public:true }, "UnitZ", $.Type); 
    $.Field({Static:true , Public:true }, "UnitW", $.Type); 
    $.Field({Static:true , Public:true }, "Zero", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "One", $.Type); 
    $.Field({Static:true , Public:false}, "double4$Parse$value", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]))
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    function double4__cctor () {
      $thisType.UnitX = new $thisType();
      $thisType.UnitY = new $thisType();
      $thisType.UnitZ = new $thisType();
      $thisType.UnitW = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.One = new $thisType();
      $thisType.UnitX = $S00().Construct(1, 0, 0, 0);
      $thisType.UnitY = $S00().Construct(0, 1, 0, 0);
      $thisType.UnitZ = $S00().Construct(0, 0, 1, 0);
      $thisType.UnitW = $S00().Construct(0, 0, 0, 1);
      $thisType.Zero = $S00().Construct(0, 0, 0, 0);
      $thisType.One = $S00().Construct(1, 1, 1, 1);
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      new JSIL.MethodSignature(null, [], []), 
      double4__cctor
    );

    $.Property({Static:false, Public:true }, "Length", $.Double);

    $.Property({Static:false, Public:true }, "LengthFast", $.Double);

    $.Property({Static:false, Public:true }, "LengthSquared", $.Double);

    $.Property({Static:false, Public:true }, "xy", $asm04.TypeRef("Fusee.Math.double2"));

    $.Property({Static:false, Public:true }, "xyz", $asm04.TypeRef("Fusee.Math.double3"));

    $.Property({Static:false, Public:true }, "r", $.Double);

    $.Property({Static:false, Public:true }, "g", $.Double);

    $.Property({Static:false, Public:true }, "b", $.Double);

    $.Property({Static:false, Public:true }, "rgb", $asm04.TypeRef("Fusee.Math.double3"));

    $.Property({Static:false, Public:true }, "a", $.Double);

    $.Property({Static:true , Public:true }, "Parse", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]));

    $.ImplementInterfaces(
      /* 0 */ $asm07.TypeRef("System.IEquatable`1", [$.Type])
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Math.double4x4 */ 

(function double4x4$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Math.double4)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm07.System.Double)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Math.double3)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.System.Void)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.System.ArgumentOutOfRangeException)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm07.System.Object)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm07.System.Converter$b2.Of($asm07.System.String, $asm04.Fusee.Math.double4x4))) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm07.System.String)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double4x4"), [
        $asm04.TypeRef("Fusee.Math.double4"), $asm04.TypeRef("Fusee.Math.double4"), 
        $asm04.TypeRef("Fusee.Math.double4"), $asm04.TypeRef("Fusee.Math.double4")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double4"), [
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double")
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double4x4"), [
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double")
      ]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("System.ArgumentOutOfRangeException"), [$asm07.TypeRef("System.String")]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double3"), [
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double")
      ]))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double4"), [$asm04.TypeRef("Fusee.Math.double4"), $asm07.TypeRef("System.Double")], []))) ();
  };

  function double4x4__ctor$00 (row0, row1, row2, row3) {
    this.Row0 = row0;
    this.Row1 = row1;
    this.Row2 = row2;
    this.Row3 = row3;
  };

  function double4x4__ctor$01 (m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    this.Row0 = $S01().Construct(m00, m01, m02, m03);
    this.Row1 = $S01().Construct(m10, m11, m12, m13);
    this.Row2 = $S01().Construct(m20, m21, m22, m23);
    this.Row3 = $S01().Construct(m30, m31, m32, m33);
  };

  function double4x4_Add (left, right) {
    return $S02().Construct((left.get_M11() + right.get_M11()), (left.get_M12() + right.get_M12()), (left.get_M13() + right.get_M13()), (left.get_M14() + right.get_M14()), (left.get_M21() + right.get_M21()), (left.get_M22() + right.get_M22()), (left.get_M23() + right.get_M23()), (left.get_M24() + right.get_M24()), (left.get_M31() + right.get_M31()), (left.get_M32() + right.get_M32()), (left.get_M33() + right.get_M33()), (left.get_M34() + right.get_M34()), (left.get_M41() + right.get_M41()), (left.get_M42() + right.get_M42()), (left.get_M43() + right.get_M43()), (left.get_M44() + right.get_M44()));
  };

  function double4x4_CreateFromAxisAngle$02 (axis, angle, /* ref */ result) {
    var cos = +(Math.cos(-angle));
    var sin = +(Math.sin(-angle));
    var t = +(1 - cos);
    axis.Normalize();
    result.set($S02().Construct((((t * axis.x) * axis.x) + cos), (((t * axis.x) * axis.y) + (sin * axis.z)), (((t * axis.x) * axis.z) - (sin * axis.y)), 0, (((t * axis.x) * axis.y) - (sin * axis.z)), (((t * axis.y) * axis.y) + cos), (((t * axis.y) * axis.z) + (sin * axis.x)), 0, (((t * axis.x) * axis.z) + (sin * axis.y)), (((t * axis.y) * axis.z) - (sin * axis.x)), (((t * axis.z) * axis.z) + cos), 0, 0, 0, 0, 1));
  };

  function double4x4_CreateFromAxisAngle$03 (axis, angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateFromAxisAngle(axis, angle, /* ref */ result);
    return result.get();
  };

  function double4x4_CreateOrthographic$04 (width, height, zNear, zFar, /* ref */ result) {
    $thisType.CreateOrthographicOffCenter(
      (-width / 2), 
      (width / 2), 
      (-height / 2), 
      (height / 2), 
      zNear, 
      zFar, 
      /* ref */ result
    );
  };

  function double4x4_CreateOrthographic$05 (width, height, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateOrthographicOffCenter(
      (-width / 2), 
      (width / 2), 
      (-height / 2), 
      (height / 2), 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  };

  function double4x4_CreateOrthographicOffCenter$06 (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    result.set(new $thisType());
    var invRL = +(1 / (right - left));
    var invTB = +(1 / (top - bottom));
    var invFN = +(1 / (zFar - zNear));
    result.get().set_M11((2 * invRL));
    result.get().set_M22((2 * invTB));
    result.get().set_M33((2 * invFN));
    result.get().set_M14((-(right + left) * invRL));
    result.get().set_M24((-(top + bottom) * invTB));
    result.get().set_M34((-(zFar + zNear) * invFN));
    result.get().set_M44(1);
  };

  function double4x4_CreateOrthographicOffCenter$07 (left, right, bottom, top, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateOrthographicOffCenter(
      left, 
      right, 
      bottom, 
      top, 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  };

  function double4x4_CreateOrthographicOffCenterRH (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    result.set(new $thisType());
    var invRL = +(1 / (right - left));
    var invTB = +(1 / (top - bottom));
    var invFN = +(1 / (zFar - zNear));
    result.get().set_M11((2 * invRL));
    result.get().set_M22((2 * invTB));
    result.get().set_M33((-2 * invFN));
    result.get().set_M14((-(right + left) * invRL));
    result.get().set_M24((-(top + bottom) * invTB));
    result.get().set_M34((-(zFar + zNear) * invFN));
    result.get().set_M44(1);
  };

  function double4x4_CreatePerspectiveFieldOfView$08 (fovy, aspect, zNear, zFar, /* ref */ result) {
    if (!((fovy > 0) && (fovy <= 3.1415926535897931))) {
      throw $S03().Construct("fovy");
    }
    if (aspect <= 0) {
      throw $S03().Construct("aspect");
    }
    if (zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    if (zFar <= 0) {
      throw $S03().Construct("zFar");
    }
    if (zNear >= zFar) {
      throw $S03().Construct("zNear");
    }
    var yMax = +(zNear * (Math.tan((0.5 * fovy))));
    var yMin = +-yMax;
    $thisType.CreatePerspectiveOffCenter(
      (yMin * aspect), 
      (yMax * aspect), 
      yMin, 
      yMax, 
      zNear, 
      zFar, 
      /* ref */ result
    );
  };

  function double4x4_CreatePerspectiveFieldOfView$09 (fovy, aspect, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreatePerspectiveFieldOfView(
      fovy, 
      aspect, 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  };

  function double4x4_CreatePerspectiveFieldOfView_ROW$0A (fovy, aspect, zNear, zFar, /* ref */ result) {
    if (!((fovy > 0) && (fovy <= 3.1415926535897931))) {
      throw $S03().Construct("fovy");
    }
    if (aspect <= 0) {
      throw $S03().Construct("aspect");
    }
    if (zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    if (zFar <= 0) {
      throw $S03().Construct("zFar");
    }
    if (zNear >= zFar) {
      throw $S03().Construct("zNear");
    }
    var yMax = +(zNear * (Math.tan((0.5 * fovy))));
    var yMin = +-yMax;
    $thisType.CreatePerspectiveOffCenter_ROW(
      (yMin * aspect), 
      (yMax * aspect), 
      yMin, 
      yMax, 
      zNear, 
      zFar, 
      /* ref */ result
    );
  };

  function double4x4_CreatePerspectiveFieldOfView_ROW$0B (fovy, aspect, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreatePerspectiveFieldOfView_ROW(
      fovy, 
      aspect, 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  };

  function double4x4_CreatePerspectiveOffCenter$0C (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    if (zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    if (zFar <= 0) {
      throw $S03().Construct("zFar");
    }
    if (zNear >= zFar) {
      throw $S03().Construct("zNear");
    }
    result.set($S02().Construct(((2 * zNear) / (right - left)), 0, ((left + right) / (left - right)), 0, 0, ((2 * zNear) / (top - bottom)), ((top + bottom) / (bottom - top)), 0, 0, 0, ((zFar + zNear) / (zFar - zNear)), (-((2 * zFar) * zNear) / (zFar - zNear)), 0, 0, 1, 0));
  };

  function double4x4_CreatePerspectiveOffCenter$0D (left, right, bottom, top, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreatePerspectiveOffCenter(
      left, 
      right, 
      bottom, 
      top, 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  };

  function double4x4_CreatePerspectiveOffCenter_ROW (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    if (zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    if (zFar <= 0) {
      throw $S03().Construct("zFar");
    }
    if (zNear >= zFar) {
      throw $S03().Construct("zNear");
    }
    result.set($S02().Construct(((2 * zNear) / (right - left)), 0, 0, 0, 0, ((2 * zNear) / (top - bottom)), 0, 0, ((left + right) / (left - right)), ((top + bottom) / (bottom - top)), ((zFar + zNear) / (zFar - zNear)), 1, 0, 0, (-((2 * zFar) * zNear) / (zFar - zNear)), 0));
  };

  function double4x4_CreatePerspectiveOffCenterRH (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    if (zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    if (zFar <= 0) {
      throw $S03().Construct("zFar");
    }
    if (zNear >= zFar) {
      throw $S03().Construct("zNear");
    }
    result.set($S02().Construct(((2 * zNear) / (right - left)), 0, ((right + left) / (right - left)), 0, 0, ((2 * zNear) / (top - bottom)), ((top + bottom) / (top - bottom)), 0, 0, 0, (-(zFar + zNear) / (zFar - zNear)), (-((2 * zFar) * zNear) / (zFar - zNear)), 0, 0, -1, 0));
  };

  function double4x4_CreateRotationX$0E (angle, /* ref */ result) {
    var cos = +(Math.cos(angle));
    var sin = +(Math.sin(angle));
    result.get().Row0 = $T00().UnitX.MemberwiseClone();
    result.get().Row1 = $S01().Construct(0, cos, -sin, 0);
    result.get().Row2 = $S01().Construct(0, sin, cos, 0);
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  };

  function double4x4_CreateRotationX$0F (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationX(angle, /* ref */ result);
    return result.get();
  };

  function double4x4_CreateRotationX_ROW$10 (angle, /* ref */ result) {
    var cos = +(Math.cos(angle));
    var sin = +(Math.sin(angle));
    result.get().Row0 = $T00().UnitX.MemberwiseClone();
    result.get().Row1 = $S01().Construct(0, cos, sin, 0);
    result.get().Row2 = $S01().Construct(0, -sin, cos, 0);
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  };

  function double4x4_CreateRotationX_ROW$11 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationX_ROW(angle, /* ref */ result);
    return result.get();
  };

  function double4x4_CreateRotationY$12 (angle, /* ref */ result) {
    var cos = +(Math.cos(angle));
    var sin = +(Math.sin(angle));
    result.get().Row0 = $S01().Construct(cos, 0, sin, 0);
    result.get().Row1 = $T00().UnitY.MemberwiseClone();
    result.get().Row2 = $S01().Construct(-sin, 0, cos, 0);
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  };

  function double4x4_CreateRotationY$13 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationY(angle, /* ref */ result);
    return result.get();
  };

  function double4x4_CreateRotationY_ROW$14 (angle, /* ref */ result) {
    var cos = +(Math.cos(angle));
    var sin = +(Math.sin(angle));
    result.get().Row0 = $S01().Construct(cos, 0, -sin, 0);
    result.get().Row1 = $T00().UnitY.MemberwiseClone();
    result.get().Row2 = $S01().Construct(sin, 0, cos, 0);
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  };

  function double4x4_CreateRotationY_ROW$15 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationY_ROW(angle, /* ref */ result);
    return result.get();
  };

  function double4x4_CreateRotationZ$16 (angle, /* ref */ result) {
    var cos = +(Math.cos(angle));
    var sin = +(Math.sin(angle));
    result.get().Row0 = $S01().Construct(cos, -sin, 0, 0);
    result.get().Row1 = $S01().Construct(sin, cos, 0, 0);
    result.get().Row2 = $T00().UnitZ.MemberwiseClone();
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  };

  function double4x4_CreateRotationZ$17 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationZ(angle, /* ref */ result);
    return result.get();
  };

  function double4x4_CreateTranslation$18 (x, y, z, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    result.get().set_M14(x);
    result.get().set_M24(y);
    result.get().set_M34(z);
  };

  function double4x4_CreateTranslation$19 (/* ref */ vector, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    result.get().set_M14(vector.get().x);
    result.get().set_M24(vector.get().y);
    result.get().set_M34(vector.get().z);
  };

  function double4x4_CreateTranslation$1A (x, y, z) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateTranslation(x, y, z, /* ref */ result);
    return result.get();
  };

  function double4x4_CreateTranslation$1B (vector) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateTranslation(vector.x, vector.y, vector.z, /* ref */ result);
    return result.get();
  };

  function double4x4_CreateTranslation_ROW$1C (x, y, z, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    result.get().Row3 = $S01().Construct(x, y, z, 1);
  };

  function double4x4_CreateTranslation_ROW$1D (x, y, z) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateTranslation_ROW(x, y, z, /* ref */ result);
    return result.get();
  };

  function double4x4_Object_Equals (obj) {
    return ($thisType.$Is(obj) && this.Equals($thisType.$Cast(obj)));
  };

  function double4x4_Equals$1E (other) {
    return (!(!$T00().op_Equality(this.Row0.MemberwiseClone(), other.Row0) || 
        !$T00().op_Equality(this.Row1.MemberwiseClone(), other.Row1) || 
        !$T00().op_Equality(this.Row2.MemberwiseClone(), other.Row2)) && $T00().op_Equality(this.Row3.MemberwiseClone(), other.Row3));
  };

  function double4x4_get_Column0 () {
    return $S01().Construct(this.Row0.x, this.Row1.x, this.Row2.x, this.Row3.x);
  };

  function double4x4_get_Column1 () {
    return $S01().Construct(this.Row0.y, this.Row1.y, this.Row2.y, this.Row3.y);
  };

  function double4x4_get_Column2 () {
    return $S01().Construct(this.Row0.z, this.Row1.z, this.Row2.z, this.Row3.z);
  };

  function double4x4_get_Column3 () {
    return $S01().Construct(this.Row0.w, this.Row1.w, this.Row2.w, this.Row3.w);
  };

  function double4x4_get_Determinant () {
    return +((((((((((((((((((((((((((this.Row0.x * this.Row1.y) * this.Row2.z) * this.Row3.w) - (((this.Row0.x * this.Row1.y) * this.Row2.w) * this.Row3.z)) + (((this.Row0.x * this.Row1.z) * this.Row2.w) * this.Row3.y)) - (((this.Row0.x * this.Row1.z) * this.Row2.y) * this.Row3.w)) + (((this.Row0.x * this.Row1.w) * this.Row2.y) * this.Row3.z)) - (((this.Row0.x * this.Row1.w) * this.Row2.z) * this.Row3.y)) - (((this.Row0.y * this.Row1.z) * this.Row2.w) * this.Row3.x)) + (((this.Row0.y * this.Row1.z) * this.Row2.x) * this.Row3.w)) - (((this.Row0.y * this.Row1.w) * this.Row2.x) * this.Row3.z)) + (((this.Row0.y * this.Row1.w) * this.Row2.z) * this.Row3.x)) - (((this.Row0.y * this.Row1.x) * this.Row2.z) * this.Row3.w)) + (((this.Row0.y * this.Row1.x) * this.Row2.w) * this.Row3.z)) + (((this.Row0.z * this.Row1.w) * this.Row2.x) * this.Row3.y)) - (((this.Row0.z * this.Row1.w) * this.Row2.y) * this.Row3.x)) + (((this.Row0.z * this.Row1.x) * this.Row2.y) * this.Row3.w)) - (((this.Row0.z * this.Row1.x) * this.Row2.w) * this.Row3.y)) + (((this.Row0.z * this.Row1.y) * this.Row2.w) * this.Row3.x)) - (((this.Row0.z * this.Row1.y) * this.Row2.x) * this.Row3.w)) - (((this.Row0.w * this.Row1.x) * this.Row2.y) * this.Row3.z)) + (((this.Row0.w * this.Row1.x) * this.Row2.z) * this.Row3.y)) - (((this.Row0.w * this.Row1.y) * this.Row2.z) * this.Row3.x)) + (((this.Row0.w * this.Row1.y) * this.Row2.x) * this.Row3.z)) - (((this.Row0.w * this.Row1.z) * this.Row2.x) * this.Row3.y)) + (((this.Row0.w * this.Row1.z) * this.Row2.y) * this.Row3.x));
  };

  function double4x4_get_IsAffine () {
    return $T00().op_Equality(this.Row3.MemberwiseClone(), $T00().UnitW);
  };

  function double4x4_get_M11 () {
    return +this.Row0.x;
  };

  function double4x4_get_M12 () {
    return +this.Row0.y;
  };

  function double4x4_get_M13 () {
    return +this.Row0.z;
  };

  function double4x4_get_M14 () {
    return +this.Row0.w;
  };

  function double4x4_get_M21 () {
    return +this.Row1.x;
  };

  function double4x4_get_M22 () {
    return +this.Row1.y;
  };

  function double4x4_get_M23 () {
    return +this.Row1.z;
  };

  function double4x4_get_M24 () {
    return +this.Row1.w;
  };

  function double4x4_get_M31 () {
    return +this.Row2.x;
  };

  function double4x4_get_M32 () {
    return +this.Row2.y;
  };

  function double4x4_get_M33 () {
    return +this.Row2.z;
  };

  function double4x4_get_M34 () {
    return +this.Row2.w;
  };

  function double4x4_get_M41 () {
    return +this.Row3.x;
  };

  function double4x4_get_M42 () {
    return +this.Row3.y;
  };

  function double4x4_get_M43 () {
    return +this.Row3.z;
  };

  function double4x4_get_M44 () {
    return +this.Row3.w;
  };

  function double4x4_get_Offset () {
    return $S04().Construct(this.Row0.w, this.Row1.w, this.Row2.w);
  };

  function double4x4_get_Parse () {
    return $thisType.double4x4$Parse$value;
  };

  function double4x4_GetHashCode () {
    return (((this.Row0.GetHashCode() ^ this.Row1.GetHashCode()) ^ this.Row2.GetHashCode()) ^ this.Row3.GetHashCode());
  };

  function double4x4_Invert$1F () {
    JSIL.CopyMembers($thisType.Invert(this.MemberwiseClone()).MemberwiseClone(), this);
  };

  function double4x4_Invert$20 (mat) {
    if (!(!$thisType.op_Equality(mat.MemberwiseClone(), $thisType.Identity) && !$thisType.op_Equality(mat.MemberwiseClone(), $thisType.Zero))) {
      var result = mat.MemberwiseClone();
    } else if (mat.get_IsAffine()) {
      result = $thisType.InvertAffine(mat.MemberwiseClone());
    } else {
      mat.Transpose();
      var tmp0 = +(mat.get_M33() * mat.get_M44());
      var tmp = +(mat.get_M34() * mat.get_M43());
      var tmp2 = +(mat.get_M32() * mat.get_M44());
      var tmp3 = +(mat.get_M34() * mat.get_M42());
      var tmp4 = +(mat.get_M32() * mat.get_M43());
      var tmp5 = +(mat.get_M33() * mat.get_M42());
      var tmp6 = +(mat.get_M31() * mat.get_M44());
      var tmp7 = +(mat.get_M34() * mat.get_M41());
      var tmp8 = +(mat.get_M31() * mat.get_M43());
      var tmp9 = +(mat.get_M33() * mat.get_M41());
      var tmp10 = +(mat.get_M31() * mat.get_M42());
      var tmp11 = +(mat.get_M32() * mat.get_M41());
      var m11 = +(((tmp0 * mat.get_M22()) + (tmp3 * mat.get_M23())) + (tmp4 * mat.get_M24()));
      m11 -= +(((tmp * mat.get_M22()) + (tmp2 * mat.get_M23())) + (tmp5 * mat.get_M24()));
      var m12 = +(((tmp * mat.get_M21()) + (tmp6 * mat.get_M23())) + (tmp9 * mat.get_M24()));
      m12 -= +(((tmp0 * mat.get_M21()) + (tmp7 * mat.get_M23())) + (tmp8 * mat.get_M24()));
      var m13 = +(((tmp2 * mat.get_M21()) + (tmp7 * mat.get_M22())) + (tmp10 * mat.get_M24()));
      m13 -= +(((tmp3 * mat.get_M21()) + (tmp6 * mat.get_M22())) + (tmp11 * mat.get_M24()));
      var m14 = +(((tmp5 * mat.get_M21()) + (tmp8 * mat.get_M22())) + (tmp11 * mat.get_M23()));
      m14 -= +(((tmp4 * mat.get_M21()) + (tmp9 * mat.get_M22())) + (tmp10 * mat.get_M23()));
      var m15 = +(((tmp * mat.get_M12()) + (tmp2 * mat.get_M13())) + (tmp5 * mat.get_M14()));
      m15 -= +(((tmp0 * mat.get_M12()) + (tmp3 * mat.get_M13())) + (tmp4 * mat.get_M14()));
      var m16 = +(((tmp0 * mat.get_M11()) + (tmp7 * mat.get_M13())) + (tmp8 * mat.get_M14()));
      m16 -= +(((tmp * mat.get_M11()) + (tmp6 * mat.get_M13())) + (tmp9 * mat.get_M14()));
      var m17 = +(((tmp3 * mat.get_M11()) + (tmp6 * mat.get_M12())) + (tmp11 * mat.get_M14()));
      m17 -= +(((tmp2 * mat.get_M11()) + (tmp7 * mat.get_M12())) + (tmp10 * mat.get_M14()));
      var m18 = +(((tmp4 * mat.get_M11()) + (tmp9 * mat.get_M12())) + (tmp10 * mat.get_M13()));
      m18 -= +(((tmp5 * mat.get_M11()) + (tmp8 * mat.get_M12())) + (tmp11 * mat.get_M13()));
      tmp0 = +(mat.get_M13() * mat.get_M24());
      tmp = +(mat.get_M14() * mat.get_M23());
      tmp2 = +(mat.get_M12() * mat.get_M24());
      tmp3 = +(mat.get_M14() * mat.get_M22());
      tmp4 = +(mat.get_M12() * mat.get_M23());
      tmp5 = +(mat.get_M13() * mat.get_M22());
      tmp6 = +(mat.get_M11() * mat.get_M24());
      tmp7 = +(mat.get_M14() * mat.get_M21());
      tmp8 = +(mat.get_M11() * mat.get_M23());
      tmp9 = +(mat.get_M13() * mat.get_M21());
      tmp10 = +(mat.get_M11() * mat.get_M22());
      tmp11 = +(mat.get_M12() * mat.get_M21());
      var m19 = +(((tmp0 * mat.get_M42()) + (tmp3 * mat.get_M43())) + (tmp4 * mat.get_M44()));
      m19 -= +(((tmp * mat.get_M42()) + (tmp2 * mat.get_M43())) + (tmp5 * mat.get_M44()));
      var m20 = +(((tmp * mat.get_M41()) + (tmp6 * mat.get_M43())) + (tmp9 * mat.get_M44()));
      m20 -= +(((tmp0 * mat.get_M41()) + (tmp7 * mat.get_M43())) + (tmp8 * mat.get_M44()));
      var m21 = +(((tmp2 * mat.get_M41()) + (tmp7 * mat.get_M42())) + (tmp10 * mat.get_M44()));
      m21 -= +(((tmp3 * mat.get_M41()) + (tmp6 * mat.get_M42())) + (tmp11 * mat.get_M44()));
      var m22 = +(((tmp5 * mat.get_M41()) + (tmp8 * mat.get_M42())) + (tmp11 * mat.get_M43()));
      m22 -= +(((tmp4 * mat.get_M41()) + (tmp9 * mat.get_M42())) + (tmp10 * mat.get_M43()));
      var m23 = +(((tmp2 * mat.get_M33()) + (tmp5 * mat.get_M34())) + (tmp * mat.get_M32()));
      m23 -= +(((tmp4 * mat.get_M34()) + (tmp0 * mat.get_M32())) + (tmp3 * mat.get_M33()));
      var m24 = +(((tmp8 * mat.get_M34()) + (tmp0 * mat.get_M31())) + (tmp7 * mat.get_M33()));
      m24 -= +(((tmp6 * mat.get_M33()) + (tmp9 * mat.get_M34())) + (tmp * mat.get_M31()));
      var m25 = +(((tmp6 * mat.get_M32()) + (tmp11 * mat.get_M34())) + (tmp3 * mat.get_M31()));
      m25 -= +(((tmp10 * mat.get_M34()) + (tmp2 * mat.get_M31())) + (tmp7 * mat.get_M32()));
      var m26 = +(((tmp10 * mat.get_M33()) + (tmp4 * mat.get_M31())) + (tmp9 * mat.get_M32()));
      m26 -= +(((tmp8 * mat.get_M32()) + (tmp11 * mat.get_M33())) + (tmp5 * mat.get_M31()));
      var det = +((((mat.get_M11() * m11) + (mat.get_M12() * m12)) + (mat.get_M13() * m13)) + (mat.get_M14() * m14));
      if (!((det <= 1.1920930376163597E-07) && (det >= -1.1920930376163597E-07))) {
        det = +(1 / det);
        $thisType.prototype._ctor.call(mat, 
          (det * m11), 
          (det * m12), 
          (det * m13), 
          (det * m14), 
          (det * m15), 
          (det * m16), 
          (det * m17), 
          (det * m18), 
          (det * m19), 
          (det * m20), 
          (det * m21), 
          (det * m22), 
          (det * m23), 
          (det * m24), 
          (det * m25), 
          (det * m26)
        );
      } else {
        mat.Transpose();
      }
      result = mat.MemberwiseClone();
    }
    return result;
  };

  function double4x4_InvertAffine (mat) {
    var val = +-(((mat.get_M11() * mat.get_M14()) + (mat.get_M21() * mat.get_M24())) + (mat.get_M31() * mat.get_M34()));
    var val2 = +-(((mat.get_M12() * mat.get_M14()) + (mat.get_M22() * mat.get_M24())) + (mat.get_M32() * mat.get_M34()));
    var val3 = +-(((mat.get_M13() * mat.get_M14()) + (mat.get_M23() * mat.get_M24())) + (mat.get_M33() * mat.get_M34()));
    return $S00().Construct($S01().Construct(mat.get_M11(), mat.get_M21(), mat.get_M31(), val), $S01().Construct(mat.get_M12(), mat.get_M22(), mat.get_M32(), val2), $S01().Construct(mat.get_M13(), mat.get_M23(), mat.get_M33(), val3), $S01().Construct(0, 0, 0, 1));
  };

  function double4x4_LookAt$21 (eye, target, up) {
    var z = $T02().Normalize($T02().op_Subtraction(target, eye.MemberwiseClone()));
    var x = $T02().Normalize($T02().Cross(up, z.MemberwiseClone()).MemberwiseClone());
    var y = $T02().Cross(z.MemberwiseClone(), x.MemberwiseClone());
    return $S02().Construct(x.x, x.y, x.z, -$T02().Dot(x, eye), y.x, y.y, y.z, -$T02().Dot(y, eye), z.x, z.y, z.z, -$T02().Dot(z, eye), 0, 0, 0, 1);
  };

  function double4x4_LookAt$22 (eyeX, eyeY, eyeZ, targetX, targetY, targetZ, upX, upY, upZ) {
    return $thisType.LookAt($S04().Construct(eyeX, eyeY, eyeZ), $S04().Construct(targetX, targetY, targetZ), $S04().Construct(upX, upY, upZ));
  };

  function double4x4_LookAt_ROW$23 (eye, target, up) {
    var z = $T02().Normalize($T02().op_Subtraction(target, eye.MemberwiseClone()));
    var x = $T02().Normalize($T02().Cross(up, z.MemberwiseClone()).MemberwiseClone());
    var y = $T02().Cross(z.MemberwiseClone(), x.MemberwiseClone());
    return $S00().Construct($S01().Construct(x.x, y.x, z.x, 0), $S01().Construct(x.y, y.y, z.y, 0), $S01().Construct(x.z, y.z, z.z, 0), $S01().Construct(-$T02().Dot(x, eye), -$T02().Dot(y, eye), -$T02().Dot(z, eye), 1));
  };

  function double4x4_LookAt_ROW$24 (eyeX, eyeY, eyeZ, targetX, targetY, targetZ, upX, upY, upZ) {
    return $thisType.LookAt_ROW($S04().Construct(eyeX, eyeY, eyeZ), $S04().Construct(targetX, targetY, targetZ), $S04().Construct(upX, upY, upZ));
  };

  function double4x4_LookAtRH (eye, target, up) {
    var z = $T02().Normalize($T02().op_Subtraction(eye.MemberwiseClone(), target).MemberwiseClone());
    var x = $T02().Normalize($T02().Cross(up, z.MemberwiseClone()).MemberwiseClone());
    var y = $T02().Cross(z.MemberwiseClone(), x.MemberwiseClone());
    return $S02().Construct(x.x, x.y, x.z, -$T02().Dot(x, eye), y.x, y.y, y.z, -$T02().Dot(y, eye), z.x, z.y, z.z, -$T02().Dot(z, eye), 0, 0, 0, 1);
  };

  function double4x4_Mult$25 ($left, $right) {
    var right = new JSIL.BoxedVariable($right);
    var left = new JSIL.BoxedVariable($left);
    var result = new JSIL.BoxedVariable(new $thisType());
    if ($thisType.op_Equality(left.get().MemberwiseClone(), $thisType.Identity)) {
      var result2 = right.get().MemberwiseClone();
    } else if ($thisType.op_Equality(right.get().MemberwiseClone(), $thisType.Identity)) {
      result2 = left.get().MemberwiseClone();
    } else if (!(!$thisType.op_Equality(left.get().MemberwiseClone(), $thisType.Zero) && !$thisType.op_Equality(right.get().MemberwiseClone(), $thisType.Zero))) {
      result2 = $thisType.Zero.MemberwiseClone();
    } else {
      if (!(!left.get().get_IsAffine() || !right.get().get_IsAffine())) {
        $thisType.MultAffine(/* ref */ left, /* ref */ right, /* ref */ result);
      } else {
        $thisType.Mult(/* ref */ left, /* ref */ right, /* ref */ result);
      }
      result2 = result.get().MemberwiseClone();
    }
    return result2;
  };

  function double4x4_Mult$26 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct(((((left.get().get_M11() * right.get().get_M11()) + (left.get().get_M12() * right.get().get_M21())) + (left.get().get_M13() * right.get().get_M31())) + (left.get().get_M14() * right.get().get_M41())), ((((left.get().get_M11() * right.get().get_M12()) + (left.get().get_M12() * right.get().get_M22())) + (left.get().get_M13() * right.get().get_M32())) + (left.get().get_M14() * right.get().get_M42())), ((((left.get().get_M11() * right.get().get_M13()) + (left.get().get_M12() * right.get().get_M23())) + (left.get().get_M13() * right.get().get_M33())) + (left.get().get_M14() * right.get().get_M43())), ((((left.get().get_M11() * right.get().get_M14()) + (left.get().get_M12() * right.get().get_M24())) + (left.get().get_M13() * right.get().get_M34())) + (left.get().get_M14() * right.get().get_M44())), ((((left.get().get_M21() * right.get().get_M11()) + (left.get().get_M22() * right.get().get_M21())) + (left.get().get_M23() * right.get().get_M31())) + (left.get().get_M24() * right.get().get_M41())), ((((left.get().get_M21() * right.get().get_M12()) + (left.get().get_M22() * right.get().get_M22())) + (left.get().get_M23() * right.get().get_M32())) + (left.get().get_M24() * right.get().get_M42())), ((((left.get().get_M21() * right.get().get_M13()) + (left.get().get_M22() * right.get().get_M23())) + (left.get().get_M23() * right.get().get_M33())) + (left.get().get_M24() * right.get().get_M43())), ((((left.get().get_M21() * right.get().get_M14()) + (left.get().get_M22() * right.get().get_M24())) + (left.get().get_M23() * right.get().get_M34())) + (left.get().get_M24() * right.get().get_M44())), ((((left.get().get_M31() * right.get().get_M11()) + (left.get().get_M32() * right.get().get_M21())) + (left.get().get_M33() * right.get().get_M31())) + (left.get().get_M34() * right.get().get_M41())), ((((left.get().get_M31() * right.get().get_M12()) + (left.get().get_M32() * right.get().get_M22())) + (left.get().get_M33() * right.get().get_M32())) + (left.get().get_M34() * right.get().get_M42())), ((((left.get().get_M31() * right.get().get_M13()) + (left.get().get_M32() * right.get().get_M23())) + (left.get().get_M33() * right.get().get_M33())) + (left.get().get_M34() * right.get().get_M43())), ((((left.get().get_M31() * right.get().get_M14()) + (left.get().get_M32() * right.get().get_M24())) + (left.get().get_M33() * right.get().get_M34())) + (left.get().get_M34() * right.get().get_M44())), ((((left.get().get_M41() * right.get().get_M11()) + (left.get().get_M42() * right.get().get_M21())) + (left.get().get_M43() * right.get().get_M31())) + (left.get().get_M44() * right.get().get_M41())), ((((left.get().get_M41() * right.get().get_M12()) + (left.get().get_M42() * right.get().get_M22())) + (left.get().get_M43() * right.get().get_M32())) + (left.get().get_M44() * right.get().get_M42())), ((((left.get().get_M41() * right.get().get_M13()) + (left.get().get_M42() * right.get().get_M23())) + (left.get().get_M43() * right.get().get_M33())) + (left.get().get_M44() * right.get().get_M43())), ((((left.get().get_M41() * right.get().get_M14()) + (left.get().get_M42() * right.get().get_M24())) + (left.get().get_M43() * right.get().get_M34())) + (left.get().get_M44() * right.get().get_M44()))));
  };

  function double4x4_MultAffine (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct((((left.get().get_M11() * right.get().get_M11()) + (left.get().get_M12() * right.get().get_M21())) + (left.get().get_M13() * right.get().get_M31())), (((left.get().get_M11() * right.get().get_M12()) + (left.get().get_M12() * right.get().get_M22())) + (left.get().get_M13() * right.get().get_M32())), (((left.get().get_M11() * right.get().get_M13()) + (left.get().get_M12() * right.get().get_M23())) + (left.get().get_M13() * right.get().get_M33())), ((((left.get().get_M11() * right.get().get_M14()) + (left.get().get_M12() * right.get().get_M24())) + (left.get().get_M13() * right.get().get_M34())) + left.get().get_M14()), (((left.get().get_M21() * right.get().get_M11()) + (left.get().get_M22() * right.get().get_M21())) + (left.get().get_M23() * right.get().get_M31())), (((left.get().get_M21() * right.get().get_M12()) + (left.get().get_M22() * right.get().get_M22())) + (left.get().get_M23() * right.get().get_M32())), (((left.get().get_M21() * right.get().get_M13()) + (left.get().get_M22() * right.get().get_M23())) + (left.get().get_M23() * right.get().get_M33())), ((((left.get().get_M21() * right.get().get_M14()) + (left.get().get_M22() * right.get().get_M24())) + (left.get().get_M23() * right.get().get_M34())) + left.get().get_M24()), (((left.get().get_M31() * right.get().get_M11()) + (left.get().get_M32() * right.get().get_M21())) + (left.get().get_M33() * right.get().get_M31())), (((left.get().get_M31() * right.get().get_M12()) + (left.get().get_M32() * right.get().get_M22())) + (left.get().get_M33() * right.get().get_M32())), (((left.get().get_M31() * right.get().get_M13()) + (left.get().get_M32() * right.get().get_M23())) + (left.get().get_M33() * right.get().get_M33())), ((((left.get().get_M31() * right.get().get_M14()) + (left.get().get_M32() * right.get().get_M24())) + (left.get().get_M33() * right.get().get_M34())) + left.get().get_M34()), 0, 0, 0, 1));
  };

  function double4x4_op_Addition (left, right) {
    return $thisType.Add(left, right);
  };

  function double4x4_op_Equality (left, right) {
    return left.Equals(right);
  };

  function double4x4_op_Inequality (left, right) {
    return !left.Equals(right);
  };

  function double4x4_op_Multiply$27 (left, right) {
    return $thisType.Mult(left, right);
  };

  function double4x4_op_Multiply$28 (matrix, vector) {
    return $thisType.Transform(matrix, vector);
  };

  function double4x4_op_Multiply$29 (vector, matrix) {
    return $thisType.TransformPremult(vector, matrix);
  };

  function double4x4_op_Multiply$2A (matrix, vector) {
    return $thisType.TransformPD(matrix, vector);
  };

  function double4x4_op_Multiply$2B (vector, matrix) {
    return $thisType.TransformPremultPD(vector, matrix);
  };

  function double4x4_op_Subtraction (left, right) {
    return $thisType.Substract(left, right);
  };

  function double4x4_Scale$2C (scale) {
    return $thisType.Scale(scale, scale, scale);
  };

  function double4x4_Scale$2D (scale) {
    return $thisType.Scale(scale.x, scale.y, scale.z);
  };

  function double4x4_Scale$2E (x, y, z) {
    var result = new $thisType();
    result.Row0 = $S05().CallStatic($T00(), "op_Multiply", null, $T00().UnitX.MemberwiseClone(), x).MemberwiseClone();
    result.Row1 = $S05().CallStatic($T00(), "op_Multiply", null, $T00().UnitY.MemberwiseClone(), y).MemberwiseClone();
    result.Row2 = $S05().CallStatic($T00(), "op_Multiply", null, $T00().UnitZ.MemberwiseClone(), z).MemberwiseClone();
    result.Row3 = $T00().UnitW.MemberwiseClone();
    return result;
  };

  function double4x4_set_M11 (value) {
    this.Row0.x = +value;
  };

  function double4x4_set_M12 (value) {
    this.Row0.y = +value;
  };

  function double4x4_set_M13 (value) {
    this.Row0.z = +value;
  };

  function double4x4_set_M14 (value) {
    this.Row0.w = +value;
  };

  function double4x4_set_M21 (value) {
    this.Row1.x = +value;
  };

  function double4x4_set_M22 (value) {
    this.Row1.y = +value;
  };

  function double4x4_set_M23 (value) {
    this.Row1.z = +value;
  };

  function double4x4_set_M24 (value) {
    this.Row1.w = +value;
  };

  function double4x4_set_M31 (value) {
    this.Row2.x = +value;
  };

  function double4x4_set_M32 (value) {
    this.Row2.y = +value;
  };

  function double4x4_set_M33 (value) {
    this.Row2.z = +value;
  };

  function double4x4_set_M34 (value) {
    this.Row2.w = +value;
  };

  function double4x4_set_M41 (value) {
    this.Row3.x = +value;
  };

  function double4x4_set_M42 (value) {
    this.Row3.y = +value;
  };

  function double4x4_set_M43 (value) {
    this.Row3.z = +value;
  };

  function double4x4_set_M44 (value) {
    this.Row3.w = +value;
  };

  function double4x4_set_Parse (value) {
    $thisType.double4x4$Parse$value = value;
  };

  function double4x4_Substract (left, right) {
    return $S02().Construct((left.get_M11() - right.get_M11()), (left.get_M12() - right.get_M12()), (left.get_M13() - right.get_M13()), (left.get_M14() - right.get_M14()), (left.get_M21() - right.get_M21()), (left.get_M22() - right.get_M22()), (left.get_M23() - right.get_M23()), (left.get_M24() - right.get_M24()), (left.get_M31() - right.get_M31()), (left.get_M32() - right.get_M32()), (left.get_M33() - right.get_M33()), (left.get_M34() - right.get_M34()), (left.get_M41() - right.get_M41()), (left.get_M42() - right.get_M42()), (left.get_M43() - right.get_M43()), (left.get_M44() - right.get_M44()));
  };

  function double4x4_ToArray () {
    return JSIL.Array.New($T01(), [this.get_M11(), this.get_M12(), this.get_M13(), this.get_M14(), this.get_M21(), this.get_M22(), this.get_M23(), this.get_M24(), this.get_M31(), this.get_M32(), this.get_M33(), this.get_M34(), this.get_M41(), this.get_M42(), this.get_M43(), this.get_M44()]);
  };

  function double4x4_toString () {
    return $T07().Format("{0}\n{1}\n{2}\n{3}", JSIL.Array.New($T05(), [this.Row0, this.Row1, this.Row2, this.Row3]));
  };

  function double4x4_Transform (matrix, vector) {
    return $S01().Construct(((((matrix.get_M11() * vector.x) + (matrix.get_M12() * vector.y)) + (matrix.get_M13() * vector.z)) + (matrix.get_M14() * vector.w)), ((((matrix.get_M21() * vector.x) + (matrix.get_M22() * vector.y)) + (matrix.get_M23() * vector.z)) + (matrix.get_M24() * vector.w)), ((((matrix.get_M31() * vector.x) + (matrix.get_M32() * vector.y)) + (matrix.get_M33() * vector.z)) + (matrix.get_M34() * vector.w)), ((((matrix.get_M41() * vector.x) + (matrix.get_M42() * vector.y)) + (matrix.get_M43() * vector.z)) + (matrix.get_M44() * vector.w)));
  };

  function double4x4_TransformPD (matrix, vector) {
    var w = +((((matrix.get_M41() * vector.x) + (matrix.get_M42() * vector.y)) + (matrix.get_M43() * vector.z)) + matrix.get_M44());
    return $S04().Construct((((((matrix.get_M11() * vector.x) + (matrix.get_M12() * vector.y)) + (matrix.get_M13() * vector.z)) + matrix.get_M14()) / w), (((((matrix.get_M21() * vector.x) + (matrix.get_M22() * vector.y)) + (matrix.get_M23() * vector.z)) + matrix.get_M24()) / w), (((((matrix.get_M31() * vector.x) + (matrix.get_M32() * vector.y)) + (matrix.get_M33() * vector.z)) + matrix.get_M34()) / w));
  };

  function double4x4_TransformPremult (vector, matrix) {
    return $S01().Construct(((((matrix.get_M11() * vector.x) + (matrix.get_M21() * vector.y)) + (matrix.get_M31() * vector.z)) + (matrix.get_M41() * vector.w)), ((((matrix.get_M12() * vector.x) + (matrix.get_M22() * vector.y)) + (matrix.get_M32() * vector.z)) + (matrix.get_M42() * vector.w)), ((((matrix.get_M13() * vector.x) + (matrix.get_M23() * vector.y)) + (matrix.get_M33() * vector.z)) + (matrix.get_M43() * vector.w)), ((((matrix.get_M14() * vector.x) + (matrix.get_M24() * vector.y)) + (matrix.get_M34() * vector.z)) + (matrix.get_M44() * vector.w)));
  };

  function double4x4_TransformPremultPD (vector, matrix) {
    var w = +((((matrix.get_M14() * vector.x) + (matrix.get_M24() * vector.y)) + (matrix.get_M34() * vector.z)) + matrix.get_M44());
    return $S04().Construct((((((matrix.get_M11() * vector.x) + (matrix.get_M21() * vector.y)) + (matrix.get_M31() * vector.z)) + matrix.get_M41()) / w), (((((matrix.get_M12() * vector.x) + (matrix.get_M22() * vector.y)) + (matrix.get_M32() * vector.z)) + matrix.get_M42()) / w), (((((matrix.get_M13() * vector.x) + (matrix.get_M23() * vector.y)) + (matrix.get_M33() * vector.z)) + matrix.get_M43()) / w));
  };

  function double4x4_Transpose$2F () {
    JSIL.CopyMembers($thisType.Transpose(this.MemberwiseClone()), this);
  };

  function double4x4_Transpose$30 (mat) {
    return $S00().Construct(mat.get_Column0().MemberwiseClone(), mat.get_Column1().MemberwiseClone(), mat.get_Column2().MemberwiseClone(), mat.get_Column3().MemberwiseClone());
  };

  function double4x4_Transpose$31 (/* ref */ mat, /* ref */ result) {
    result.get().Row0 = mat.get().get_Column0().MemberwiseClone();
    result.get().Row1 = mat.get().get_Column1().MemberwiseClone();
    result.get().Row2 = mat.get().get_Column2().MemberwiseClone();
    result.get().Row3 = mat.get().get_Column3().MemberwiseClone();
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.double4x4", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 16, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm04.TypeRef("Fusee.Math.double4"), $asm04.TypeRef("Fusee.Math.double4"), 
          $asm04.TypeRef("Fusee.Math.double4"), $asm04.TypeRef("Fusee.Math.double4")
        ], []), 
      double4x4__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double
        ], []), 
      double4x4__ctor$01
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double4x4_Add
    );

    $.Method({Static:true , Public:true }, "CreateFromAxisAngle", 
      new JSIL.MethodSignature(null, [
          $asm04.TypeRef("Fusee.Math.double3"), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4x4_CreateFromAxisAngle$02
    );

    $.Method({Static:true , Public:true }, "CreateFromAxisAngle", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.double3"), $.Double], []), 
      double4x4_CreateFromAxisAngle$03
    );

    $.Method({Static:true , Public:true }, "CreateOrthographic", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4x4_CreateOrthographic$04
    );

    $.Method({Static:true , Public:true }, "CreateOrthographic", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double, $.Double
        ], []), 
      double4x4_CreateOrthographic$05
    );

    $.Method({Static:true , Public:true }, "CreateOrthographicOffCenter", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4x4_CreateOrthographicOffCenter$06
    );

    $.Method({Static:true , Public:true }, "CreateOrthographicOffCenter", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double
        ], []), 
      double4x4_CreateOrthographicOffCenter$07
    );

    $.Method({Static:true , Public:true }, "CreateOrthographicOffCenterRH", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4x4_CreateOrthographicOffCenterRH
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveFieldOfView", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4x4_CreatePerspectiveFieldOfView$08
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveFieldOfView", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double, $.Double
        ], []), 
      double4x4_CreatePerspectiveFieldOfView$09
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveFieldOfView_ROW", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4x4_CreatePerspectiveFieldOfView_ROW$0A
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreatePerspectiveFieldOfView_ROW", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double, $.Double
        ], []), 
      double4x4_CreatePerspectiveFieldOfView_ROW$0B
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreatePerspectiveOffCenter", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4x4_CreatePerspectiveOffCenter$0C
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveOffCenter", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double
        ], []), 
      double4x4_CreatePerspectiveOffCenter$0D
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveOffCenter_ROW", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4x4_CreatePerspectiveOffCenter_ROW
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreatePerspectiveOffCenterRH", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4x4_CreatePerspectiveOffCenterRH
    );

    $.Method({Static:true , Public:true }, "CreateRotationX", 
      new JSIL.MethodSignature(null, [$.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      double4x4_CreateRotationX$0E
    );

    $.Method({Static:true , Public:true }, "CreateRotationX", 
      new JSIL.MethodSignature($.Type, [$.Double], []), 
      double4x4_CreateRotationX$0F
    );

    $.Method({Static:true , Public:true }, "CreateRotationX_ROW", 
      new JSIL.MethodSignature(null, [$.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      double4x4_CreateRotationX_ROW$10
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateRotationX_ROW", 
      new JSIL.MethodSignature($.Type, [$.Double], []), 
      double4x4_CreateRotationX_ROW$11
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateRotationY", 
      new JSIL.MethodSignature(null, [$.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      double4x4_CreateRotationY$12
    );

    $.Method({Static:true , Public:true }, "CreateRotationY", 
      new JSIL.MethodSignature($.Type, [$.Double], []), 
      double4x4_CreateRotationY$13
    );

    $.Method({Static:true , Public:true }, "CreateRotationY_ROW", 
      new JSIL.MethodSignature(null, [$.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      double4x4_CreateRotationY_ROW$14
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateRotationY_ROW", 
      new JSIL.MethodSignature($.Type, [$.Double], []), 
      double4x4_CreateRotationY_ROW$15
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateRotationZ", 
      new JSIL.MethodSignature(null, [$.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      double4x4_CreateRotationZ$16
    );

    $.Method({Static:true , Public:true }, "CreateRotationZ", 
      new JSIL.MethodSignature($.Type, [$.Double], []), 
      double4x4_CreateRotationZ$17
    );

    $.Method({Static:true , Public:true }, "CreateTranslation", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4x4_CreateTranslation$18
    );

    $.Method({Static:true , Public:true }, "CreateTranslation", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      double4x4_CreateTranslation$19
    );

    $.Method({Static:true , Public:true }, "CreateTranslation", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double
        ], []), 
      double4x4_CreateTranslation$1A
    );

    $.Method({Static:true , Public:true }, "CreateTranslation", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.double3")], []), 
      double4x4_CreateTranslation$1B
    );

    $.Method({Static:true , Public:true }, "CreateTranslation_ROW", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4x4_CreateTranslation_ROW$1C
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateTranslation_ROW", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double
        ], []), 
      double4x4_CreateTranslation_ROW$1D
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object], []), 
      double4x4_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type], []), 
      double4x4_Equals$1E
    );

    $.Method({Static:false, Public:true }, "get_Column0", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double4"), [], []), 
      double4x4_get_Column0
    );

    $.Method({Static:false, Public:true }, "get_Column1", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double4"), [], []), 
      double4x4_get_Column1
    );

    $.Method({Static:false, Public:true }, "get_Column2", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double4"), [], []), 
      double4x4_get_Column2
    );

    $.Method({Static:false, Public:true }, "get_Column3", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double4"), [], []), 
      double4x4_get_Column3
    );

    $.Method({Static:false, Public:true }, "get_Determinant", 
      new JSIL.MethodSignature($.Double, [], []), 
      double4x4_get_Determinant
    );

    $.Method({Static:false, Public:true }, "get_IsAffine", 
      new JSIL.MethodSignature($.Boolean, [], []), 
      double4x4_get_IsAffine
    );

    $.Method({Static:false, Public:true }, "get_M11", 
      new JSIL.MethodSignature($.Double, [], []), 
      double4x4_get_M11
    );

    $.Method({Static:false, Public:true }, "get_M12", 
      new JSIL.MethodSignature($.Double, [], []), 
      double4x4_get_M12
    );

    $.Method({Static:false, Public:true }, "get_M13", 
      new JSIL.MethodSignature($.Double, [], []), 
      double4x4_get_M13
    );

    $.Method({Static:false, Public:true }, "get_M14", 
      new JSIL.MethodSignature($.Double, [], []), 
      double4x4_get_M14
    );

    $.Method({Static:false, Public:true }, "get_M21", 
      new JSIL.MethodSignature($.Double, [], []), 
      double4x4_get_M21
    );

    $.Method({Static:false, Public:true }, "get_M22", 
      new JSIL.MethodSignature($.Double, [], []), 
      double4x4_get_M22
    );

    $.Method({Static:false, Public:true }, "get_M23", 
      new JSIL.MethodSignature($.Double, [], []), 
      double4x4_get_M23
    );

    $.Method({Static:false, Public:true }, "get_M24", 
      new JSIL.MethodSignature($.Double, [], []), 
      double4x4_get_M24
    );

    $.Method({Static:false, Public:true }, "get_M31", 
      new JSIL.MethodSignature($.Double, [], []), 
      double4x4_get_M31
    );

    $.Method({Static:false, Public:true }, "get_M32", 
      new JSIL.MethodSignature($.Double, [], []), 
      double4x4_get_M32
    );

    $.Method({Static:false, Public:true }, "get_M33", 
      new JSIL.MethodSignature($.Double, [], []), 
      double4x4_get_M33
    );

    $.Method({Static:false, Public:true }, "get_M34", 
      new JSIL.MethodSignature($.Double, [], []), 
      double4x4_get_M34
    );

    $.Method({Static:false, Public:true }, "get_M41", 
      new JSIL.MethodSignature($.Double, [], []), 
      double4x4_get_M41
    );

    $.Method({Static:false, Public:true }, "get_M42", 
      new JSIL.MethodSignature($.Double, [], []), 
      double4x4_get_M42
    );

    $.Method({Static:false, Public:true }, "get_M43", 
      new JSIL.MethodSignature($.Double, [], []), 
      double4x4_get_M43
    );

    $.Method({Static:false, Public:true }, "get_M44", 
      new JSIL.MethodSignature($.Double, [], []), 
      double4x4_get_M44
    );

    $.Method({Static:false, Public:true }, "get_Offset", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double3"), [], []), 
      double4x4_get_Offset
    );

    $.Method({Static:true , Public:true }, "get_Parse", 
      new JSIL.MethodSignature($asm07.TypeRef("System.Converter`2", [$.String, $.Type]), [], []), 
      double4x4_get_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      new JSIL.MethodSignature($.Int32, [], []), 
      double4x4_GetHashCode
    );

    $.Method({Static:false, Public:true }, "Invert", 
      new JSIL.MethodSignature(null, [], []), 
      double4x4_Invert$1F
    );

    $.Method({Static:true , Public:true }, "Invert", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      double4x4_Invert$20
    );

    $.Method({Static:true , Public:true }, "InvertAffine", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      double4x4_InvertAffine
    );

    $.Method({Static:true , Public:true }, "LookAt", 
      new JSIL.MethodSignature($.Type, [
          $asm04.TypeRef("Fusee.Math.double3"), $asm04.TypeRef("Fusee.Math.double3"), 
          $asm04.TypeRef("Fusee.Math.double3")
        ], []), 
      double4x4_LookAt$21
    );

    $.Method({Static:true , Public:true }, "LookAt", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double
        ], []), 
      double4x4_LookAt$22
    );

    $.Method({Static:true , Public:true }, "LookAt_ROW", 
      new JSIL.MethodSignature($.Type, [
          $asm04.TypeRef("Fusee.Math.double3"), $asm04.TypeRef("Fusee.Math.double3"), 
          $asm04.TypeRef("Fusee.Math.double3")
        ], []), 
      double4x4_LookAt_ROW$23
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "LookAt_ROW", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double, $.Double, 
          $.Double
        ], []), 
      double4x4_LookAt_ROW$24
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "LookAtRH", 
      new JSIL.MethodSignature($.Type, [
          $asm04.TypeRef("Fusee.Math.double3"), $asm04.TypeRef("Fusee.Math.double3"), 
          $asm04.TypeRef("Fusee.Math.double3")
        ], []), 
      double4x4_LookAtRH
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double4x4_Mult$25
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4x4_Mult$26
    );

    $.Method({Static:true , Public:true }, "MultAffine", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      double4x4_MultAffine
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double4x4_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type], []), 
      double4x4_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type], []), 
      double4x4_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double4x4_op_Multiply$27
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double4"), [$.Type, $asm04.TypeRef("Fusee.Math.double4")], []), 
      double4x4_op_Multiply$28
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double4"), [$asm04.TypeRef("Fusee.Math.double4"), $.Type], []), 
      double4x4_op_Multiply$29
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double3"), [$.Type, $asm04.TypeRef("Fusee.Math.double3")], []), 
      double4x4_op_Multiply$2A
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double3"), [$asm04.TypeRef("Fusee.Math.double3"), $.Type], []), 
      double4x4_op_Multiply$2B
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double4x4_op_Subtraction
    );

    $.Method({Static:true , Public:true }, "Scale", 
      new JSIL.MethodSignature($.Type, [$.Double], []), 
      double4x4_Scale$2C
    );

    $.Method({Static:true , Public:true }, "Scale", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.double3")], []), 
      double4x4_Scale$2D
    );

    $.Method({Static:true , Public:true }, "Scale", 
      new JSIL.MethodSignature($.Type, [
          $.Double, $.Double, 
          $.Double
        ], []), 
      double4x4_Scale$2E
    );

    $.Method({Static:false, Public:true }, "set_M11", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double4x4_set_M11
    );

    $.Method({Static:false, Public:true }, "set_M12", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double4x4_set_M12
    );

    $.Method({Static:false, Public:true }, "set_M13", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double4x4_set_M13
    );

    $.Method({Static:false, Public:true }, "set_M14", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double4x4_set_M14
    );

    $.Method({Static:false, Public:true }, "set_M21", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double4x4_set_M21
    );

    $.Method({Static:false, Public:true }, "set_M22", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double4x4_set_M22
    );

    $.Method({Static:false, Public:true }, "set_M23", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double4x4_set_M23
    );

    $.Method({Static:false, Public:true }, "set_M24", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double4x4_set_M24
    );

    $.Method({Static:false, Public:true }, "set_M31", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double4x4_set_M31
    );

    $.Method({Static:false, Public:true }, "set_M32", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double4x4_set_M32
    );

    $.Method({Static:false, Public:true }, "set_M33", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double4x4_set_M33
    );

    $.Method({Static:false, Public:true }, "set_M34", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double4x4_set_M34
    );

    $.Method({Static:false, Public:true }, "set_M41", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double4x4_set_M41
    );

    $.Method({Static:false, Public:true }, "set_M42", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double4x4_set_M42
    );

    $.Method({Static:false, Public:true }, "set_M43", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double4x4_set_M43
    );

    $.Method({Static:false, Public:true }, "set_M44", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      double4x4_set_M44
    );

    $.Method({Static:true , Public:true }, "set_Parse", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("System.Converter`2", [$.String, $.Type])], []), 
      double4x4_set_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:true , Public:true }, "Substract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      double4x4_Substract
    );

    $.Method({Static:false, Public:false}, "ToArray", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Double]), [], []), 
      double4x4_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      new JSIL.MethodSignature($.String, [], []), 
      double4x4_toString
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double4"), [$.Type, $asm04.TypeRef("Fusee.Math.double4")], []), 
      double4x4_Transform
    );

    $.Method({Static:true , Public:true }, "TransformPD", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double3"), [$.Type, $asm04.TypeRef("Fusee.Math.double3")], []), 
      double4x4_TransformPD
    );

    $.Method({Static:true , Public:true }, "TransformPremult", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double4"), [$asm04.TypeRef("Fusee.Math.double4"), $.Type], []), 
      double4x4_TransformPremult
    );

    $.Method({Static:true , Public:true }, "TransformPremultPD", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double3"), [$asm04.TypeRef("Fusee.Math.double3"), $.Type], []), 
      double4x4_TransformPremultPD
    );

    $.Method({Static:false, Public:true }, "Transpose", 
      new JSIL.MethodSignature(null, [], []), 
      double4x4_Transpose$2F
    );

    $.Method({Static:true , Public:true }, "Transpose", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      double4x4_Transpose$30
    );

    $.Method({Static:true , Public:true }, "Transpose", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      double4x4_Transpose$31
    );

    $.Field({Static:false, Public:true }, "Row0", $asm04.TypeRef("Fusee.Math.double4"))
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [1]; }); 
    $.Field({Static:false, Public:true }, "Row1", $asm04.TypeRef("Fusee.Math.double4"))
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [2]; }); 
    $.Field({Static:false, Public:true }, "Row2", $asm04.TypeRef("Fusee.Math.double4"))
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [3]; }); 
    $.Field({Static:false, Public:true }, "Row3", $asm04.TypeRef("Fusee.Math.double4"))
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [4]; }); 
    $.Field({Static:true , Public:true }, "Identity", $.Type); 
    $.Field({Static:true , Public:true }, "Zero", $.Type); 
    $.Field({Static:true , Public:false}, "double4x4$Parse$value", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]))
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    function double4x4__cctor () {
      $thisType.Identity = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.Identity = $S00().Construct($T00().UnitX.MemberwiseClone(), $T00().UnitY.MemberwiseClone(), $T00().UnitZ.MemberwiseClone(), $T00().UnitW.MemberwiseClone());
      $thisType.Zero = $S00().Construct($T00().Zero.MemberwiseClone(), $T00().Zero.MemberwiseClone(), $T00().Zero.MemberwiseClone(), $T00().Zero.MemberwiseClone());
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      new JSIL.MethodSignature(null, [], []), 
      double4x4__cctor
    );

    $.Property({Static:false, Public:true }, "Determinant", $.Double);

    $.Property({Static:false, Public:true }, "Column0", $asm04.TypeRef("Fusee.Math.double4"));

    $.Property({Static:false, Public:true }, "Column1", $asm04.TypeRef("Fusee.Math.double4"));

    $.Property({Static:false, Public:true }, "Column2", $asm04.TypeRef("Fusee.Math.double4"));

    $.Property({Static:false, Public:true }, "Column3", $asm04.TypeRef("Fusee.Math.double4"));

    $.Property({Static:false, Public:true }, "M11", $.Double);

    $.Property({Static:false, Public:true }, "M12", $.Double);

    $.Property({Static:false, Public:true }, "M13", $.Double);

    $.Property({Static:false, Public:true }, "M14", $.Double);

    $.Property({Static:false, Public:true }, "M21", $.Double);

    $.Property({Static:false, Public:true }, "M22", $.Double);

    $.Property({Static:false, Public:true }, "M23", $.Double);

    $.Property({Static:false, Public:true }, "M24", $.Double);

    $.Property({Static:false, Public:true }, "M31", $.Double);

    $.Property({Static:false, Public:true }, "M32", $.Double);

    $.Property({Static:false, Public:true }, "M33", $.Double);

    $.Property({Static:false, Public:true }, "M34", $.Double);

    $.Property({Static:false, Public:true }, "M41", $.Double);

    $.Property({Static:false, Public:true }, "M42", $.Double);

    $.Property({Static:false, Public:true }, "M43", $.Double);

    $.Property({Static:false, Public:true }, "M44", $.Double);

    $.Property({Static:false, Public:true }, "Offset", $asm04.TypeRef("Fusee.Math.double3"));

    $.Property({Static:false, Public:true }, "IsAffine", $.Boolean);

    $.Property({Static:true , Public:true }, "Parse", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]));

    $.ImplementInterfaces(
      /* 0 */ $asm07.TypeRef("System.IEquatable`1", [$.Type])
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm08.TypeRef("ProtoBuf.ProtoContractAttribute"));

})();

/* struct Fusee.Math.float2 */ 

(function float2$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm07.System.Single)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Math.float3)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Math.float4)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.System.Void)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm07.System.Double)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm04.Fusee.Math.MathHelper)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm07.System.Converter$b2.Of($asm07.System.String, $asm04.Fusee.Math.float2))) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm07.System.String)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm04.Fusee.Math.Quaternion)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float2"), [$asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single")]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float2"), [$asm07.TypeRef("System.Single"), $asm04.TypeRef("Fusee.Math.float2")], []))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float2")]), $asm07.TypeRef("System.Single"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float2")])
      ], []))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float2")]), $asm07.TypeRef("System.Single"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float2")])
      ], []))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float2")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float2")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float2")])
      ], []))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("System.Single"), [$asm07.TypeRef("System.Single")], []))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float2")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float2")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float2")])
      ], []))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.Quaternion"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")])
      ], []))) ();
  };

  function float2__ctor$00 (x, y) {
    this.x = +x;
    this.y = +y;
  };

  function float2__ctor$01 (v) {
    this.x = +v.x;
    this.y = +v.y;
  };

  function float2__ctor$02 (v) {
    this.x = +v.x;
    this.y = +v.y;
  };

  function float2__ctor$03 (v) {
    this.x = +v.x;
    this.y = +v.y;
  };

  function float2_Add$04 (right) {
    this.x += +right.x;
    this.y += +right.y;
  };

  function float2_Add$05 (/* ref */ right) {
    this.x += +right.get().x;
    this.y += +right.get().y;
  };

  function float2_Add$06 ($a, $b) {
    var b = new JSIL.BoxedVariable($b);
    var a = new JSIL.BoxedVariable($a);
    $thisType.Add(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  };

  function float2_Add$07 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((a.get().x + b.get().x), (a.get().y + b.get().y)));
  };

  function float2_BaryCentric$08 (a, b, c, u, v) {
    return $thisType.op_Addition(
      $thisType.op_Addition(a.MemberwiseClone(), $S01().CallStatic($thisType, "op_Multiply", null, u, $thisType.op_Subtraction(b, a.MemberwiseClone()))).MemberwiseClone(), 
      $S01().CallStatic($thisType, "op_Multiply", null, v, $thisType.op_Subtraction(c, a.MemberwiseClone()))
    );
  };

  function float2_BaryCentric$09 (/* ref */ a, /* ref */ b, /* ref */ c, u, v, /* ref */ result) {
    result.set(a.get().MemberwiseClone());
    var temp = new JSIL.BoxedVariable(b.get().MemberwiseClone());
    $thisType.Subtract(/* ref */ temp, /* ref */ a, /* ref */ temp);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ temp, u, /* ref */ temp);
    $thisType.Add(/* ref */ result, /* ref */ temp, /* ref */ result);
    temp.set(c.get().MemberwiseClone());
    $thisType.Subtract(/* ref */ temp, /* ref */ a, /* ref */ temp);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ temp, v, /* ref */ temp);
    $thisType.Add(/* ref */ result, /* ref */ temp, /* ref */ result);
  };

  function float2_Clamp$0A (vec, min, max) {
    vec.x = +((vec.x < min.x) ? min.x : ((vec.x > max.x) ? max.x : vec.x));
    vec.y = +((vec.y < min.y) ? min.y : ((vec.y > max.y) ? max.y : vec.y));
    return vec;
  };

  function float2_Clamp$0B (/* ref */ vec, /* ref */ min, /* ref */ max, /* ref */ result) {
    result.get().x = +((vec.get().x < min.get().x) ? min.get().x : ((vec.get().x > max.get().x) ? max.get().x : vec.get().x));
    result.get().y = +((vec.get().y < min.get().y) ? min.get().y : ((vec.get().y > max.get().y) ? max.get().y : vec.get().y));
  };

  function float2_ComponentMax$0C (a, b) {
    a.x = +((a.x > b.x) ? a.x : b.x);
    a.y = +((a.y > b.y) ? a.y : b.y);
    return a;
  };

  function float2_ComponentMax$0D (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +((a.get().x > b.get().x) ? a.get().x : b.get().x);
    result.get().y = +((a.get().y > b.get().y) ? a.get().y : b.get().y);
  };

  function float2_ComponentMin$0E (a, b) {
    a.x = +((a.x < b.x) ? a.x : b.x);
    a.y = +((a.y < b.y) ? a.y : b.y);
    return a;
  };

  function float2_ComponentMin$0F (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +((a.get().x < b.get().x) ? a.get().x : b.get().x);
    result.get().y = +((a.get().y < b.get().y) ? a.get().y : b.get().y);
  };

  function float2_Div$10 (f) {
    var mult = +(1 / f);
    this.x *= +mult;
    this.y *= +mult;
  };

  function float2_Div$11 (a, f) {
    var mult = +(1 / f);
    a.x *= +mult;
    a.y *= +mult;
    return a;
  };

  function float2_Div$12 (/* ref */ a, f, /* ref */ result) {
    var mult = +(1 / f);
    result.get().x = +(a.get().x * mult);
    result.get().y = +(a.get().y * mult);
  };

  function float2_Divide$13 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector);
    $S03().CallStatic($thisType, "Divide", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  };

  function float2_Divide$14 (/* ref */ vector, scale, /* ref */ result) {
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vector, (1 / scale), /* ref */ result);
  };

  function float2_Divide$15 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale);
    var vector = new JSIL.BoxedVariable($vector);
    $S04().CallStatic($thisType, "Divide", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  };

  function float2_Divide$16 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct((vector.get().x / scale.get().x), (vector.get().y / scale.get().y)));
  };

  function float2_Dot$17 (left, right) {
    return +((left.x * right.x) + (left.y * right.y));
  };

  function float2_Dot$18 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set(((left.get().x * right.get().x) + (left.get().y * right.get().y)));
  };

  function float2_Object_Equals (obj) {
    return ($thisType.$Is(obj) && this.Equals($thisType.$Cast(obj)));
  };

  function float2_Equals$19 (other) {
    return ((this.x === other.x) && (this.y === other.y));
  };

  function float2_get_Length () {
    return +$T00().$Cast(Math.sqrt(((this.x * this.x) + (this.y * this.y))));
  };

  function float2_get_LengthFast () {
    return +(1 / $S05().CallStatic($T06(), "InverseSqrtFast", null, ((this.x * this.x) + (this.y * this.y))));
  };

  function float2_get_LengthSquared () {
    return +((this.x * this.x) + (this.y * this.y));
  };

  function float2_get_Parse () {
    return $thisType.float2$Parse$value;
  };

  function float2_get_PerpendicularLeft () {
    return $S00().Construct(-this.y, this.x);
  };

  function float2_get_PerpendicularRight () {
    return $S00().Construct(this.y, -this.x);
  };

  function float2_GetHashCode () {
    return (this.x.GetHashCode() ^ this.y.GetHashCode());
  };

  function float2_Lerp$1A (a, b, blend) {
    a.x = +((blend * (b.x - a.x)) + a.x);
    a.y = +((blend * (b.y - a.y)) + a.y);
    return a;
  };

  function float2_Lerp$1B (/* ref */ a, /* ref */ b, blend, /* ref */ result) {
    result.get().x = +((blend * (b.get().x - a.get().x)) + a.get().x);
    result.get().y = +((blend * (b.get().y - a.get().y)) + a.get().y);
  };

  function float2_Max (left, right) {
    return ((left.get_LengthSquared() >= right.get_LengthSquared()) ? left : right);
  };

  function float2_Min (left, right) {
    return ((left.get_LengthSquared() < right.get_LengthSquared()) ? left : right);
  };

  function float2_Mult$1C (f) {
    this.x *= +f;
    this.y *= +f;
  };

  function float2_Mult$1D (a, f) {
    a.x *= +f;
    a.y *= +f;
    return a;
  };

  function float2_Mult$1E (/* ref */ a, f, /* ref */ result) {
    result.get().x = +(a.get().x * f);
    result.get().y = +(a.get().y * f);
  };

  function float2_Multiply$1F ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  };

  function float2_Multiply$20 (/* ref */ vector, scale, /* ref */ result) {
    result.set($S00().Construct((vector.get().x * scale), (vector.get().y * scale)));
  };

  function float2_Multiply$21 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale);
    var vector = new JSIL.BoxedVariable($vector);
    $S06().CallStatic($thisType, "Multiply", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  };

  function float2_Multiply$22 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct((vector.get().x * scale.get().x), (vector.get().y * scale.get().y)));
  };

  function float2_Normalize$23 () {
    var scale = +(1 / this.get_Length());
    this.x *= +scale;
    this.y *= +scale;
  };

  function float2_Normalize$24 (vec) {
    var scale = +(1 / vec.get_Length());
    vec.x *= +scale;
    vec.y *= +scale;
    return vec;
  };

  function float2_Normalize$25 (/* ref */ vec, /* ref */ result) {
    var scale = +(1 / vec.get().get_Length());
    result.get().x = +(vec.get().x * scale);
    result.get().y = +(vec.get().y * scale);
  };

  function float2_NormalizeFast$26 () {
    var scale = +$S05().CallStatic($T06(), "InverseSqrtFast", null, ((this.x * this.x) + (this.y * this.y)));
    this.x *= +scale;
    this.y *= +scale;
  };

  function float2_NormalizeFast$27 (vec) {
    var scale = +$S05().CallStatic($T06(), "InverseSqrtFast", null, ((vec.x * vec.x) + (vec.y * vec.y)));
    vec.x *= +scale;
    vec.y *= +scale;
    return vec;
  };

  function float2_NormalizeFast$28 (/* ref */ vec, /* ref */ result) {
    var scale = +$S05().CallStatic($T06(), "InverseSqrtFast", null, ((vec.get().x * vec.get().x) + (vec.get().y * vec.get().y)));
    result.get().x = +(vec.get().x * scale);
    result.get().y = +(vec.get().y * scale);
  };

  function float2_op_Addition (left, right) {
    left.x += +right.x;
    left.y += +right.y;
    return left;
  };

  function float2_op_Division (vec, scale) {
    var mult = +(1 / scale);
    vec.x *= +mult;
    vec.y *= +mult;
    return vec;
  };

  function float2_op_Equality (left, right) {
    return left.Equals(right);
  };

  function float2_op_Inequality (left, right) {
    return !left.Equals(right);
  };

  function float2_op_Multiply$29 (vec, scale) {
    vec.x *= +scale;
    vec.y *= +scale;
    return vec;
  };

  function float2_op_Multiply$2A (scale, vec) {
    vec.x *= +scale;
    vec.y *= +scale;
    return vec;
  };

  function float2_op_Multiply$2B (vec1, vec2) {
    vec1.x *= +vec2.x;
    vec1.y *= +vec2.y;
    return vec1;
  };

  function float2_op_Subtraction (left, right) {
    left.x -= +right.x;
    left.y -= +right.y;
    return left;
  };

  function float2_op_UnaryNegation (vec) {
    vec.x = +-vec.x;
    vec.y = +-vec.y;
    return vec;
  };

  function float2_Scale$2C (sx, sy) {
    this.x *= +sx;
    this.y *= +sy;
  };

  function float2_Scale$2D (scale) {
    this.x *= +scale.x;
    this.y *= +scale.y;
  };

  function float2_Scale$2E (/* ref */ scale) {
    this.x *= +scale.get().x;
    this.y *= +scale.get().y;
  };

  function float2_set_Parse (value) {
    $thisType.float2$Parse$value = value;
  };

  function float2_Sub$2F (right) {
    this.x -= +right.x;
    this.y -= +right.y;
  };

  function float2_Sub$30 (/* ref */ right) {
    this.x -= +right.get().x;
    this.y -= +right.get().y;
  };

  function float2_Sub$31 (a, b) {
    a.x -= +b.x;
    a.y -= +b.y;
    return a;
  };

  function float2_Sub$32 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(a.get().x - b.get().x);
    result.get().y = +(a.get().y - b.get().y);
  };

  function float2_Subtract$33 ($a, $b) {
    var b = new JSIL.BoxedVariable($b);
    var a = new JSIL.BoxedVariable($a);
    $thisType.Subtract(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  };

  function float2_Subtract$34 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((a.get().x - b.get().x), (a.get().y - b.get().y)));
  };

  function float2_ToArray () {
    return JSIL.Array.New($T00(), [this.x, this.y]);
  };

  function float2_toString () {
    return $T08().Format("({0}, {1})", this.x, this.y);
  };

  function float2_Transform$35 ($vec, $quat) {
    var quat = new JSIL.BoxedVariable($quat);
    var vec = new JSIL.BoxedVariable($vec);
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.Transform(/* ref */ vec, /* ref */ quat, /* ref */ result);
    return result.get();
  };

  function float2_Transform$36 (/* ref */ vec, /* ref */ quat, /* ref */ result) {
    var i = new JSIL.BoxedVariable(new ($T09())());
    var t = new JSIL.BoxedVariable(new ($T09())());
    var v = new JSIL.BoxedVariable($S07().Construct(vec.get().x, vec.get().y, 0, 0));
    $T09().Invert(/* ref */ quat, /* ref */ i);
    $S08().CallStatic($T09(), "Multiply", null, /* ref */ quat, /* ref */ v, /* ref */ t);
    $S08().CallStatic($T09(), "Multiply", null, /* ref */ t, /* ref */ i, /* ref */ v);
    result.set($S00().Construct(v.get().get_x(), v.get().get_y()));
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.float2", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 2, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.Single, $.Single], []), 
      float2__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.Type], []), 
      float2__ctor$01
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"));

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.float3")], []), 
      float2__ctor$02
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"));

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.float4")], []), 
      float2__ctor$03
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"));

    $.Method({Static:false, Public:true }, "Add", 
      new JSIL.MethodSignature(null, [$.Type], []), 
      float2_Add$04
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:false, Public:true }, "Add", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      float2_Add$05
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float2_Add$06
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float2_Add$07
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type, $.Single, 
          $.Single
        ], []), 
      float2_BaryCentric$08
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float2_BaryCentric$09
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type
        ], []), 
      float2_Clamp$0A
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float2_Clamp$0B
    );

    $.Method({Static:true , Public:true }, "ComponentMax", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float2_ComponentMax$0C
    );

    $.Method({Static:true , Public:true }, "ComponentMax", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float2_ComponentMax$0D
    );

    $.Method({Static:true , Public:true }, "ComponentMin", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float2_ComponentMin$0E
    );

    $.Method({Static:true , Public:true }, "ComponentMin", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float2_ComponentMin$0F
    );

    $.Method({Static:false, Public:true }, "Div", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float2_Div$10
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single], []), 
      float2_Div$11
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float2_Div$12
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single], []), 
      float2_Divide$13
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float2_Divide$14
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float2_Divide$15
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float2_Divide$16
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature($.Single, [$.Type, $.Type], []), 
      float2_Dot$17
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Single])
        ], []), 
      float2_Dot$18
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object], []), 
      float2_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type], []), 
      float2_Equals$19
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      new JSIL.MethodSignature($.Single, [], []), 
      float2_get_Length
    );

    $.Method({Static:false, Public:true }, "get_LengthFast", 
      new JSIL.MethodSignature($.Single, [], []), 
      float2_get_LengthFast
    );

    $.Method({Static:false, Public:true }, "get_LengthSquared", 
      new JSIL.MethodSignature($.Single, [], []), 
      float2_get_LengthSquared
    );

    $.Method({Static:true , Public:true }, "get_Parse", 
      new JSIL.MethodSignature($asm07.TypeRef("System.Converter`2", [$.String, $.Type]), [], []), 
      float2_get_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_PerpendicularLeft", 
      new JSIL.MethodSignature($.Type, [], []), 
      float2_get_PerpendicularLeft
    );

    $.Method({Static:false, Public:true }, "get_PerpendicularRight", 
      new JSIL.MethodSignature($.Type, [], []), 
      float2_get_PerpendicularRight
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      new JSIL.MethodSignature($.Int32, [], []), 
      float2_GetHashCode
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Single
        ], []), 
      float2_Lerp$1A
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float2_Lerp$1B
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float2_Max
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float2_Min
    );

    $.Method({Static:false, Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float2_Mult$1C
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single], []), 
      float2_Mult$1D
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float2_Mult$1E
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single], []), 
      float2_Multiply$1F
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float2_Multiply$20
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float2_Multiply$21
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float2_Multiply$22
    );

    $.Method({Static:false, Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [], []), 
      float2_Normalize$23
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      float2_Normalize$24
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      float2_Normalize$25
    );

    $.Method({Static:false, Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature(null, [], []), 
      float2_NormalizeFast$26
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      float2_NormalizeFast$27
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      float2_NormalizeFast$28
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float2_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Division", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single], []), 
      float2_op_Division
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type], []), 
      float2_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type], []), 
      float2_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single], []), 
      float2_op_Multiply$29
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Single, $.Type], []), 
      float2_op_Multiply$2A
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float2_op_Multiply$2B
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float2_op_Subtraction
    );

    $.Method({Static:true , Public:true }, "op_UnaryNegation", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      float2_op_UnaryNegation
    );

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [$.Single, $.Single], []), 
      float2_Scale$2C
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [$.Type], []), 
      float2_Scale$2D
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      float2_Scale$2E
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "set_Parse", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("System.Converter`2", [$.String, $.Type])], []), 
      float2_set_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [$.Type], []), 
      float2_Sub$2F
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:false, Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      float2_Sub$30
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float2_Sub$31
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float2_Sub$32
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float2_Subtract$33
    );

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float2_Subtract$34
    );

    $.Method({Static:false, Public:true }, "ToArray", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Single]), [], []), 
      float2_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      new JSIL.MethodSignature($.String, [], []), 
      float2_toString
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.Quaternion")], []), 
      float2_Transform$35
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float2_Transform$36
    );

    $.Field({Static:false, Public:true }, "x", $.Single)
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [1]; }); 
    $.Field({Static:false, Public:true }, "y", $.Single)
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [2]; }); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitX", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitY", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "Zero", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "One", $.Type); 
    $.Field({Static:true , Public:false}, "float2$Parse$value", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]))
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    function float2__cctor () {
      $thisType.UnitX = new $thisType();
      $thisType.UnitY = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.One = new $thisType();
      $thisType.UnitX = $S00().Construct(1, 0);
      $thisType.UnitY = $S00().Construct(0, 1);
      $thisType.Zero = $S00().Construct(0, 0);
      $thisType.One = $S00().Construct(1, 1);
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      new JSIL.MethodSignature(null, [], []), 
      float2__cctor
    );

    $.Property({Static:false, Public:true }, "Length", $.Single);

    $.Property({Static:false, Public:true }, "LengthFast", $.Single);

    $.Property({Static:false, Public:true }, "LengthSquared", $.Single);

    $.Property({Static:false, Public:true }, "PerpendicularRight", $.Type);

    $.Property({Static:false, Public:true }, "PerpendicularLeft", $.Type);

    $.Property({Static:true , Public:true }, "Parse", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]));

    $.ImplementInterfaces(
      /* 0 */ $asm07.TypeRef("System.IEquatable`1", [$.Type])
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm08.TypeRef("ProtoBuf.ProtoContractAttribute"));

})();

/* struct Fusee.Math.float3 */ 

(function float3$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm07.System.Single)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Math.float2)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Math.float4)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm04.Fusee.Math.double3)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.System.Void)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm07.System.Double)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm07.System.Object)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm04.Fusee.Math.MathHelper)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize(System.Array.Of($asm04.Fusee.Math.float3))) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm07.System.Converter$b2.Of($asm07.System.String, $asm04.Fusee.Math.float3))) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm07.System.String)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm04.Fusee.Math.float4x4)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm04.Fusee.Math.Quaternion)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float3"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$asm07.TypeRef("System.Single"), $asm04.TypeRef("Fusee.Math.float3")], []))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")]), $asm07.TypeRef("System.Single"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")])
      ], []))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")]), $asm07.TypeRef("System.Single"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")])
      ], []))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")])
      ], []))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("System.Single"), [$asm07.TypeRef("System.Single")], []))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float2"), [$asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single")]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")])
      ], []))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float3"), [$asm04.TypeRef("Fusee.Math.double3")]))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$asm04.TypeRef("Fusee.Math.float3"), $asm07.TypeRef("System.Single")], []))) ();
  };
  var $S0A = function () {
    return ($S0A = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4x4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")])
      ], []))) ();
  };
  var $S0B = function () {
    return ($S0B = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float4"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S0C = function () {
    return ($S0C = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4x4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")])
      ], []))) ();
  };
  var $S0D = function () {
    return ($S0D = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")])
      ], []))) ();
  };
  var $S0E = function () {
    return ($S0E = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float3"), [$asm04.TypeRef("Fusee.Math.float4")]))) ();
  };
  var $S0F = function () {
    return ($S0F = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float4"), [$asm04.TypeRef("Fusee.Math.float3")]))) ();
  };

  function float3__ctor$00 (x, y, z) {
    this.x = +x;
    this.y = +y;
    this.z = +z;
  };

  function float3__ctor$01 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +0;
  };

  function float3__ctor$02 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
  };

  function float3__ctor$03 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
  };

  function float3__ctor$04 (d3) {
    this.x = +$T00().$Cast(d3.x);
    this.y = +$T00().$Cast(d3.y);
    this.z = +$T00().$Cast(d3.z);
  };

  function float3_Add$05 (right) {
    this.x += +right.x;
    this.y += +right.y;
    this.z += +right.z;
  };

  function float3_Add$06 (/* ref */ right) {
    this.x += +right.get().x;
    this.y += +right.get().y;
    this.z += +right.get().z;
  };

  function float3_Add$07 ($a, $b) {
    var b = new JSIL.BoxedVariable($b);
    var a = new JSIL.BoxedVariable($a);
    $thisType.Add(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  };

  function float3_Add$08 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((a.get().x + b.get().x), (a.get().y + b.get().y), (a.get().z + b.get().z)));
  };

  function float3_BaryCentric$09 (a, b, c, u, v) {
    return $thisType.op_Addition(
      $thisType.op_Addition(a.MemberwiseClone(), $S01().CallStatic($thisType, "op_Multiply", null, u, $thisType.op_Subtraction(b, a.MemberwiseClone()))).MemberwiseClone(), 
      $S01().CallStatic($thisType, "op_Multiply", null, v, $thisType.op_Subtraction(c, a.MemberwiseClone()))
    );
  };

  function float3_BaryCentric$0A (/* ref */ a, /* ref */ b, /* ref */ c, u, v, /* ref */ result) {
    result.set(a.get().MemberwiseClone());
    var temp = new JSIL.BoxedVariable(b.get().MemberwiseClone());
    $thisType.Subtract(/* ref */ temp, /* ref */ a, /* ref */ temp);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ temp, u, /* ref */ temp);
    $thisType.Add(/* ref */ result, /* ref */ temp, /* ref */ result);
    temp.set(c.get().MemberwiseClone());
    $thisType.Subtract(/* ref */ temp, /* ref */ a, /* ref */ temp);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ temp, v, /* ref */ temp);
    $thisType.Add(/* ref */ result, /* ref */ temp, /* ref */ result);
  };

  function float3_CalculateAngle$0B (first, second) {
    if (!((first.get_Length() <= 1.192093E-07) || (second.get_Length() <= 1.192093E-07))) {
      var result = +$T00().$Cast(Math.acos(($thisType.Dot(first, second) / (first.get_Length() * second.get_Length()))));
    } else {
      result = +0;
    }
    return +result;
  };

  function float3_CalculateAngle$0C (/* ref */ first, /* ref */ second, /* ref */ result) {
    var temp = new JSIL.BoxedVariable(0);
    $thisType.Dot(/* ref */ first, /* ref */ second, /* ref */ temp);
    if (!((first.get().get_Length() <= 1.192093E-07) || (second.get().get_Length() <= 1.192093E-07))) {
      result.set($T00().$Cast(Math.acos((temp.get() / (first.get().get_Length() * second.get().get_Length())))));
    } else {
      result.set(0);
    }
  };

  function float3_Clamp$0D (vec, min, max) {
    vec.x = +((vec.x < min.x) ? min.x : ((vec.x > max.x) ? max.x : vec.x));
    vec.y = +((vec.y < min.y) ? min.y : ((vec.y > max.y) ? max.y : vec.y));
    vec.z = +((vec.z < min.z) ? min.z : ((vec.z > max.z) ? max.z : vec.z));
    return vec;
  };

  function float3_Clamp$0E (/* ref */ vec, /* ref */ min, /* ref */ max, /* ref */ result) {
    result.get().x = +((vec.get().x < min.get().x) ? min.get().x : ((vec.get().x > max.get().x) ? max.get().x : vec.get().x));
    result.get().y = +((vec.get().y < min.get().y) ? min.get().y : ((vec.get().y > max.get().y) ? max.get().y : vec.get().y));
    result.get().z = +((vec.get().z < min.get().z) ? min.get().z : ((vec.get().z > max.get().z) ? max.get().z : vec.get().z));
  };

  function float3_ComponentMax$0F (a, b) {
    a.x = +((a.x > b.x) ? a.x : b.x);
    a.y = +((a.y > b.y) ? a.y : b.y);
    a.z = +((a.z > b.z) ? a.z : b.z);
    return a;
  };

  function float3_ComponentMax$10 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +((a.get().x > b.get().x) ? a.get().x : b.get().x);
    result.get().y = +((a.get().y > b.get().y) ? a.get().y : b.get().y);
    result.get().z = +((a.get().z > b.get().z) ? a.get().z : b.get().z);
  };

  function float3_ComponentMin$11 (a, b) {
    a.x = +((a.x < b.x) ? a.x : b.x);
    a.y = +((a.y < b.y) ? a.y : b.y);
    a.z = +((a.z < b.z) ? a.z : b.z);
    return a;
  };

  function float3_ComponentMin$12 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +((a.get().x < b.get().x) ? a.get().x : b.get().x);
    result.get().y = +((a.get().y < b.get().y) ? a.get().y : b.get().y);
    result.get().z = +((a.get().z < b.get().z) ? a.get().z : b.get().z);
  };

  function float3_Cross$13 ($left, $right) {
    var right = new JSIL.BoxedVariable($right);
    var left = new JSIL.BoxedVariable($left);
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.Cross(/* ref */ left, /* ref */ right, /* ref */ result);
    return result.get();
  };

  function float3_Cross$14 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S00().Construct(((left.get().y * right.get().z) - (left.get().z * right.get().y)), ((left.get().z * right.get().x) - (left.get().x * right.get().z)), ((left.get().x * right.get().y) - (left.get().y * right.get().x))));
  };

  function float3_Div$15 (f) {
    if (f > 1.192093E-07) {
      var mult = +(1 / f);
      this.x *= +mult;
      this.y *= +mult;
      this.z *= +mult;
    }
  };

  function float3_Div$16 (a, f) {
    if (f <= 1.192093E-07) {
      var result = $thisType.Zero.MemberwiseClone();
    } else {
      var mult = +(1 / f);
      a.x *= +mult;
      a.y *= +mult;
      a.z *= +mult;
      result = a.MemberwiseClone();
    }
    return result;
  };

  function float3_Div$17 (/* ref */ a, f, /* ref */ result) {
    if (f <= 1.192093E-07) {
      var mult = +(1 / f);
      result.get().x = +(a.get().x * mult);
      result.get().y = +(a.get().y * mult);
      result.get().z = +(a.get().z * mult);
    } else {
      result.set($thisType.Zero.MemberwiseClone());
    }
  };

  function float3_Divide$18 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector);
    $S03().CallStatic($thisType, "Divide", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  };

  function float3_Divide$19 (/* ref */ vector, scale, /* ref */ result) {
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vector, (1 / scale), /* ref */ result);
  };

  function float3_Divide$1A ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale);
    var vector = new JSIL.BoxedVariable($vector);
    $S04().CallStatic($thisType, "Divide", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  };

  function float3_Divide$1B (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct((vector.get().x / scale.get().x), (vector.get().y / scale.get().y), (vector.get().z / scale.get().z)));
  };

  function float3_Dot$1C (left, right) {
    return +(((left.x * right.x) + (left.y * right.y)) + (left.z * right.z));
  };

  function float3_Dot$1D (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set((((left.get().x * right.get().x) + (left.get().y * right.get().y)) + (left.get().z * right.get().z)));
  };

  function float3_Object_Equals (obj) {
    return ($thisType.$Is(obj) && this.Equals($thisType.$Cast(obj).MemberwiseClone()));
  };

  function float3_Equals$1E (other) {
    return (!(((Math.abs((this.x - other.x))) >= 1.192093E-07) || 
        ((Math.abs((this.y - other.y))) >= 1.192093E-07)) && ((Math.abs((this.z - other.z))) < 1.192093E-07));
  };

  function float3_get_b () {
    return +this.z;
  };

  function float3_get_g () {
    return +this.y;
  };

  function float3_get_Length () {
    return +$T00().$Cast(Math.sqrt((((this.x * this.x) + (this.y * this.y)) + (this.z * this.z))));
  };

  function float3_get_LengthFast () {
    return +(1 / $S05().CallStatic($T07(), "InverseSqrtFast", null, (((this.x * this.x) + (this.y * this.y)) + (this.z * this.z))));
  };

  function float3_get_LengthSquared () {
    return +(((this.x * this.x) + (this.y * this.y)) + (this.z * this.z));
  };

  function float3_get_Parse () {
    return $thisType.float3$Parse$value;
  };

  function float3_get_r () {
    return +this.x;
  };

  function float3_get_xy () {
    return $S06().Construct(this.x, this.y);
  };

  function float3_GetHashCode () {
    return ((this.x.GetHashCode() ^ this.y.GetHashCode()) ^ this.z.GetHashCode());
  };

  function float3_Lerp$1F (a, b, blend) {
    a.x = +((blend * (b.x - a.x)) + a.x);
    a.y = +((blend * (b.y - a.y)) + a.y);
    a.z = +((blend * (b.z - a.z)) + a.z);
    return a;
  };

  function float3_Lerp$20 (/* ref */ a, /* ref */ b, blend, /* ref */ result) {
    result.get().x = +((blend * (b.get().x - a.get().x)) + a.get().x);
    result.get().y = +((blend * (b.get().y - a.get().y)) + a.get().y);
    result.get().z = +((blend * (b.get().z - a.get().z)) + a.get().z);
  };

  function float3_Max (left, right) {
    return ((left.get_LengthSquared() >= right.get_LengthSquared()) ? left : right);
  };

  function float3_Min (left, right) {
    return ((left.get_LengthSquared() < right.get_LengthSquared()) ? left : right);
  };

  function float3_Mult$21 (f) {
    this.x *= +f;
    this.y *= +f;
    this.z *= +f;
  };

  function float3_Mult$22 (a, f) {
    a.x *= +f;
    a.y *= +f;
    a.z *= +f;
    return a;
  };

  function float3_Mult$23 (/* ref */ a, f, /* ref */ result) {
    result.get().x = +(a.get().x * f);
    result.get().y = +(a.get().y * f);
    result.get().z = +(a.get().z * f);
  };

  function float3_Multiply$24 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  };

  function float3_Multiply$25 (/* ref */ vector, scale, /* ref */ result) {
    result.set($S00().Construct((vector.get().x * scale), (vector.get().y * scale), (vector.get().z * scale)));
  };

  function float3_Multiply$26 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale);
    var vector = new JSIL.BoxedVariable($vector);
    $S07().CallStatic($thisType, "Multiply", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  };

  function float3_Multiply$27 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct((vector.get().x * scale.get().x), (vector.get().y * scale.get().y), (vector.get().z * scale.get().z)));
  };

  function float3_Normalize$28 () {
    if (this.get_Length() > 1.192093E-07) {
      var scale = +(1 / this.get_Length());
      this.x *= +scale;
      this.y *= +scale;
      this.z *= +scale;
    }
  };

  function float3_Normalize$29 (vec) {
    if (vec.get_Length() > 1.192093E-07) {
      var scale = +(1 / vec.get_Length());
      vec.x *= +scale;
      vec.y *= +scale;
      vec.z *= +scale;
    }
    return vec;
  };

  function float3_Normalize$2A (/* ref */ vec, /* ref */ result) {
    if (vec.get().get_Length() > 1.192093E-07) {
      var scale = +(1 / vec.get().get_Length());
      result.get().x = +(vec.get().x * scale);
      result.get().y = +(vec.get().y * scale);
      result.get().z = +(vec.get().z * scale);
    } else {
      result.set(vec.get().MemberwiseClone());
    }
  };

  function float3_NormalizeFast$2B () {
    var scale = +$S05().CallStatic($T07(), "InverseSqrtFast", null, (((this.x * this.x) + (this.y * this.y)) + (this.z * this.z)));
    this.x *= +scale;
    this.y *= +scale;
    this.z *= +scale;
  };

  function float3_NormalizeFast$2C (vec) {
    var scale = +$S05().CallStatic($T07(), "InverseSqrtFast", null, (((vec.x * vec.x) + (vec.y * vec.y)) + (vec.z * vec.z)));
    vec.x *= +scale;
    vec.y *= +scale;
    vec.z *= +scale;
    return vec;
  };

  function float3_NormalizeFast$2D (/* ref */ vec, /* ref */ result) {
    var scale = +$S05().CallStatic($T07(), "InverseSqrtFast", null, (((vec.get().x * vec.get().x) + (vec.get().y * vec.get().y)) + (vec.get().z * vec.get().z)));
    result.get().x = +(vec.get().x * scale);
    result.get().y = +(vec.get().y * scale);
    result.get().z = +(vec.get().z * scale);
  };

  function float3_op_Addition (left, right) {
    left.x += +right.x;
    left.y += +right.y;
    left.z += +right.z;
    return left;
  };

  function float3_op_Division (vec, scale) {
    if (!((-1.192093E-07 >= scale) || (scale >= 1.192093E-07))) {
      var result = $thisType.Zero.MemberwiseClone();
    } else {
      var mult = +(1 / scale);
      vec.x *= +mult;
      vec.y *= +mult;
      vec.z *= +mult;
      result = vec.MemberwiseClone();
    }
    return result;
  };

  function float3_op_Equality (left, right) {
    return left.Equals(right);
  };

  function float3_op_Explicit (d3) {
    return $S08().Construct(d3);
  };

  function float3_op_Inequality (left, right) {
    return !left.Equals(right);
  };

  function float3_op_Multiply$2E (vec, scale) {
    vec.x *= +scale;
    vec.y *= +scale;
    vec.z *= +scale;
    return vec;
  };

  function float3_op_Multiply$2F (scale, vec) {
    vec.x *= +scale;
    vec.y *= +scale;
    vec.z *= +scale;
    return vec;
  };

  function float3_op_Multiply$30 (vec1, vec2) {
    vec1.x *= +vec2.x;
    vec1.y *= +vec2.y;
    vec1.z *= +vec2.z;
    return vec1;
  };

  function float3_op_Subtraction (left, right) {
    left.x -= +right.x;
    left.y -= +right.y;
    left.z -= +right.z;
    return left;
  };

  function float3_op_UnaryNegation (vec) {
    vec.x = +-vec.x;
    vec.y = +-vec.y;
    vec.z = +-vec.z;
    return vec;
  };

  function float3_OrthoNormalize (normal, tangent) {
    var ret = JSIL.Array.New($thisType, 2);
    normal = $thisType.Normalize(normal.MemberwiseClone()).MemberwiseClone();
    var proj = $S09().CallStatic($thisType, "op_Multiply", null, normal.MemberwiseClone(), $thisType.Dot(tangent, normal)).MemberwiseClone();
    tangent = $thisType.op_Subtraction(tangent.MemberwiseClone(), proj.MemberwiseClone()).MemberwiseClone();
    tangent = $thisType.Normalize(tangent.MemberwiseClone()).MemberwiseClone();
    ret[0] = normal.MemberwiseClone();
    ret[1] = tangent.MemberwiseClone();
    return ret;
  };

  function float3_Scale$31 (sx, sy, sz) {
    this.x *= +sx;
    this.y *= +sy;
    this.z *= +sz;
  };

  function float3_Scale$32 (scale) {
    this.x *= +scale.x;
    this.y *= +scale.y;
    this.z *= +scale.z;
  };

  function float3_Scale$33 (/* ref */ scale) {
    this.x *= +scale.get().x;
    this.y *= +scale.get().y;
    this.z *= +scale.get().z;
  };

  function float3_set_b (value) {
    this.z = +value;
  };

  function float3_set_g (value) {
    this.y = +value;
  };

  function float3_set_Parse (value) {
    $thisType.float3$Parse$value = value;
  };

  function float3_set_r (value) {
    this.x = +value;
  };

  function float3_set_xy (value) {
    this.x = +value.x;
    this.y = +value.y;
  };

  function float3_Sub$34 (right) {
    this.x -= +right.x;
    this.y -= +right.y;
    this.z -= +right.z;
  };

  function float3_Sub$35 (/* ref */ right) {
    this.x -= +right.get().x;
    this.y -= +right.get().y;
    this.z -= +right.get().z;
  };

  function float3_Sub$36 (a, b) {
    a.x -= +b.x;
    a.y -= +b.y;
    a.z -= +b.z;
    return a;
  };

  function float3_Sub$37 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(a.get().x - b.get().x);
    result.get().y = +(a.get().y - b.get().y);
    result.get().z = +(a.get().z - b.get().z);
  };

  function float3_Subtract$38 ($a, $b) {
    var b = new JSIL.BoxedVariable($b);
    var a = new JSIL.BoxedVariable($a);
    $thisType.Subtract(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  };

  function float3_Subtract$39 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((a.get().x - b.get().x), (a.get().y - b.get().y), (a.get().z - b.get().z)));
  };

  function float3_ToArray () {
    return JSIL.Array.New($T00(), [this.x, this.y, this.z]);
  };

  function float3_toString () {
    return $T0A().Format("({0}, {1}, {2})", this.x, this.y, this.z);
  };

  function float3_Transform$3A ($vec, $mat) {
    var mat = new JSIL.BoxedVariable($mat);
    var vec = new JSIL.BoxedVariable($vec);
    var result = new JSIL.BoxedVariable(new $thisType());
    $S0A().CallStatic($thisType, "Transform", null, /* ref */ vec, /* ref */ mat, /* ref */ result);
    return result.get();
  };

  function float3_Transform$3B (/* ref */ vec, /* ref */ mat, /* ref */ result) {
    var v4 = new JSIL.BoxedVariable($S0B().Construct(vec.get().x, vec.get().y, vec.get().z, 1));
    $S0C().CallStatic($T02(), "Transform", null, /* ref */ v4, /* ref */ mat, /* ref */ v4);
    result.set(v4.get().get_xyz().MemberwiseClone());
  };

  function float3_Transform$3C ($vec, $quat) {
    var quat = new JSIL.BoxedVariable($quat);
    var vec = new JSIL.BoxedVariable($vec);
    var result = new JSIL.BoxedVariable(new $thisType());
    $S0D().CallStatic($thisType, "Transform", null, /* ref */ vec, /* ref */ quat, /* ref */ result);
    return result.get();
  };

  function float3_Transform$3D (/* ref */ vec, /* ref */ quat, /* ref */ result) {
    var temp = new JSIL.BoxedVariable(new $thisType());
    var temp2 = new JSIL.BoxedVariable(new $thisType());
    var xyz = new JSIL.BoxedVariable(quat.get().get_xyz().MemberwiseClone());
    $thisType.Cross(/* ref */ xyz, /* ref */ vec, /* ref */ temp);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vec, quat.get().get_w(), /* ref */ temp2);
    $thisType.Add(/* ref */ temp, /* ref */ temp2, /* ref */ temp);
    $thisType.Cross(/* ref */ xyz, /* ref */ temp, /* ref */ temp);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ temp, 2, /* ref */ temp);
    $thisType.Add(/* ref */ vec, /* ref */ temp, /* ref */ result);
  };

  function float3_TransformNormal$3E (norm, mat) {
    mat.Invert();
    return $thisType.TransformNormalInverse(norm, mat.MemberwiseClone());
  };

  function float3_TransformNormal$3F (/* ref */ norm, /* ref */ mat, /* ref */ result) {
    var inverse = new JSIL.BoxedVariable($T0B().Invert(mat.get().MemberwiseClone()).MemberwiseClone());
    $thisType.TransformNormalInverse(/* ref */ norm, /* ref */ inverse, /* ref */ result);
  };

  function float3_TransformNormalInverse$40 (norm, invMat) {
    var i = new $thisType();
    i.x = +$thisType.Dot(norm, $S0E().Construct(invMat.Row0.MemberwiseClone()));
    i.y = +$thisType.Dot(norm, $S0E().Construct(invMat.Row1.MemberwiseClone()));
    i.z = +$thisType.Dot(norm, $S0E().Construct(invMat.Row2.MemberwiseClone()));
    return i;
  };

  function float3_TransformNormalInverse$41 (/* ref */ norm, /* ref */ invMat, /* ref */ result) {
    result.get().x = +(((norm.get().x * invMat.get().Row0.x) + (norm.get().y * invMat.get().Row0.y)) + (norm.get().z * invMat.get().Row0.z));
    result.get().y = +(((norm.get().x * invMat.get().Row1.x) + (norm.get().y * invMat.get().Row1.y)) + (norm.get().z * invMat.get().Row1.z));
    result.get().z = +(((norm.get().x * invMat.get().Row2.x) + (norm.get().y * invMat.get().Row2.y)) + (norm.get().z * invMat.get().Row2.z));
  };

  function float3_TransformPerspective$42 ($vec, $mat) {
    var mat = new JSIL.BoxedVariable($mat);
    var vec = new JSIL.BoxedVariable($vec);
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.TransformPerspective(/* ref */ vec, /* ref */ mat, /* ref */ result);
    return result.get();
  };

  function float3_TransformPerspective$43 (/* ref */ vec, /* ref */ mat, /* ref */ result) {
    var v = new JSIL.BoxedVariable($S0F().Construct(vec.get().MemberwiseClone()));
    $S0C().CallStatic($T02(), "Transform", null, /* ref */ v, /* ref */ mat, /* ref */ v);
    if (v.get().w > 1.192093E-07) {
      result.get().x = +(v.get().x / v.get().w);
      result.get().y = +(v.get().y / v.get().w);
      result.get().z = +(v.get().z / v.get().w);
    } else {
      result.set($thisType.Zero.MemberwiseClone());
    }
  };

  function float3_TransformPosition$44 (pos, mat) {
    var p = new $thisType();
    p.x = +($thisType.Dot(pos, $S0E().Construct(mat.get_Column0().MemberwiseClone())) + mat.Row3.x);
    p.y = +($thisType.Dot(pos, $S0E().Construct(mat.get_Column1().MemberwiseClone())) + mat.Row3.y);
    p.z = +($thisType.Dot(pos, $S0E().Construct(mat.get_Column2().MemberwiseClone())) + mat.Row3.z);
    return p;
  };

  function float3_TransformPosition$45 (/* ref */ pos, /* ref */ mat, /* ref */ result) {
    result.get().x = +((((pos.get().x * mat.get().Row0.x) + (pos.get().y * mat.get().Row1.x)) + (pos.get().z * mat.get().Row2.x)) + mat.get().Row3.x);
    result.get().y = +((((pos.get().x * mat.get().Row0.y) + (pos.get().y * mat.get().Row1.y)) + (pos.get().z * mat.get().Row2.y)) + mat.get().Row3.y);
    result.get().z = +((((pos.get().x * mat.get().Row0.z) + (pos.get().y * mat.get().Row1.z)) + (pos.get().z * mat.get().Row2.z)) + mat.get().Row3.z);
  };

  function float3_TransformVector$46 (vec, mat) {
    var v = new $thisType();
    v.x = +$thisType.Dot(vec, $S0E().Construct(mat.get_Column0().MemberwiseClone()));
    v.y = +$thisType.Dot(vec, $S0E().Construct(mat.get_Column1().MemberwiseClone()));
    v.z = +$thisType.Dot(vec, $S0E().Construct(mat.get_Column2().MemberwiseClone()));
    return v;
  };

  function float3_TransformVector$47 (/* ref */ vec, /* ref */ mat, /* ref */ result) {
    result.get().x = +(((vec.get().x * mat.get().Row0.x) + (vec.get().y * mat.get().Row1.x)) + (vec.get().z * mat.get().Row2.x));
    result.get().y = +(((vec.get().x * mat.get().Row0.y) + (vec.get().y * mat.get().Row1.y)) + (vec.get().z * mat.get().Row2.y));
    result.get().z = +(((vec.get().x * mat.get().Row0.z) + (vec.get().y * mat.get().Row1.z)) + (vec.get().z * mat.get().Row2.z));
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.float3", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 3, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single
        ], []), 
      float3__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.float2")], []), 
      float3__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.Type], []), 
      float3__ctor$02
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.float4")], []), 
      float3__ctor$03
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.double3")], []), 
      float3__ctor$04
    );

    $.Method({Static:false, Public:true }, "Add", 
      new JSIL.MethodSignature(null, [$.Type], []), 
      float3_Add$05
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:false, Public:true }, "Add", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      float3_Add$06
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float3_Add$07
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float3_Add$08
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type, $.Single, 
          $.Single
        ], []), 
      float3_BaryCentric$09
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float3_BaryCentric$0A
    );

    $.Method({Static:true , Public:true }, "CalculateAngle", 
      new JSIL.MethodSignature($.Single, [$.Type, $.Type], []), 
      float3_CalculateAngle$0B
    );

    $.Method({Static:true , Public:true }, "CalculateAngle", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Single])
        ], []), 
      float3_CalculateAngle$0C
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type
        ], []), 
      float3_Clamp$0D
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float3_Clamp$0E
    );

    $.Method({Static:true , Public:true }, "ComponentMax", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float3_ComponentMax$0F
    );

    $.Method({Static:true , Public:true }, "ComponentMax", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float3_ComponentMax$10
    );

    $.Method({Static:true , Public:true }, "ComponentMin", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float3_ComponentMin$11
    );

    $.Method({Static:true , Public:true }, "ComponentMin", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float3_ComponentMin$12
    );

    $.Method({Static:true , Public:true }, "Cross", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float3_Cross$13
    );

    $.Method({Static:true , Public:true }, "Cross", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float3_Cross$14
    );

    $.Method({Static:false, Public:true }, "Div", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float3_Div$15
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single], []), 
      float3_Div$16
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float3_Div$17
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single], []), 
      float3_Divide$18
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float3_Divide$19
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float3_Divide$1A
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float3_Divide$1B
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature($.Single, [$.Type, $.Type], []), 
      float3_Dot$1C
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Single])
        ], []), 
      float3_Dot$1D
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object], []), 
      float3_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type], []), 
      float3_Equals$1E
    );

    $.Method({Static:false, Public:true }, "get_b", 
      new JSIL.MethodSignature($.Single, [], []), 
      float3_get_b
    );

    $.Method({Static:false, Public:true }, "get_g", 
      new JSIL.MethodSignature($.Single, [], []), 
      float3_get_g
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      new JSIL.MethodSignature($.Single, [], []), 
      float3_get_Length
    );

    $.Method({Static:false, Public:true }, "get_LengthFast", 
      new JSIL.MethodSignature($.Single, [], []), 
      float3_get_LengthFast
    );

    $.Method({Static:false, Public:true }, "get_LengthSquared", 
      new JSIL.MethodSignature($.Single, [], []), 
      float3_get_LengthSquared
    );

    $.Method({Static:true , Public:true }, "get_Parse", 
      new JSIL.MethodSignature($asm07.TypeRef("System.Converter`2", [$.String, $.Type]), [], []), 
      float3_get_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_r", 
      new JSIL.MethodSignature($.Single, [], []), 
      float3_get_r
    );

    $.Method({Static:false, Public:true }, "get_xy", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float2"), [], []), 
      float3_get_xy
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      new JSIL.MethodSignature($.Int32, [], []), 
      float3_GetHashCode
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Single
        ], []), 
      float3_Lerp$1F
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float3_Lerp$20
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float3_Max
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float3_Min
    );

    $.Method({Static:false, Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float3_Mult$21
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single], []), 
      float3_Mult$22
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float3_Mult$23
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single], []), 
      float3_Multiply$24
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float3_Multiply$25
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float3_Multiply$26
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float3_Multiply$27
    );

    $.Method({Static:false, Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [], []), 
      float3_Normalize$28
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      float3_Normalize$29
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      float3_Normalize$2A
    );

    $.Method({Static:false, Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature(null, [], []), 
      float3_NormalizeFast$2B
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      float3_NormalizeFast$2C
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      float3_NormalizeFast$2D
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float3_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Division", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single], []), 
      float3_op_Division
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type], []), 
      float3_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Explicit", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.double3")], []), 
      float3_op_Explicit
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type], []), 
      float3_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single], []), 
      float3_op_Multiply$2E
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Single, $.Type], []), 
      float3_op_Multiply$2F
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float3_op_Multiply$30
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float3_op_Subtraction
    );

    $.Method({Static:true , Public:true }, "op_UnaryNegation", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      float3_op_UnaryNegation
    );

    $.Method({Static:true , Public:true }, "OrthoNormalize", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Type]), [$.Type, $.Type], []), 
      float3_OrthoNormalize
    );

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single
        ], []), 
      float3_Scale$31
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [$.Type], []), 
      float3_Scale$32
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      float3_Scale$33
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "set_b", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float3_set_b
    );

    $.Method({Static:false, Public:true }, "set_g", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float3_set_g
    );

    $.Method({Static:true , Public:true }, "set_Parse", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("System.Converter`2", [$.String, $.Type])], []), 
      float3_set_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "set_r", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float3_set_r
    );

    $.Method({Static:false, Public:true }, "set_xy", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.float2")], []), 
      float3_set_xy
    );

    $.Method({Static:false, Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [$.Type], []), 
      float3_Sub$34
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:false, Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      float3_Sub$35
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float3_Sub$36
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float3_Sub$37
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float3_Subtract$38
    );

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float3_Subtract$39
    );

    $.Method({Static:false, Public:true }, "ToArray", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Single]), [], []), 
      float3_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      new JSIL.MethodSignature($.String, [], []), 
      float3_toString
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.float4x4")], []), 
      float3_Transform$3A
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float3_Transform$3B
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.Quaternion")], []), 
      float3_Transform$3C
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float3_Transform$3D
    );

    $.Method({Static:true , Public:true }, "TransformNormal", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.float4x4")], []), 
      float3_TransformNormal$3E
    );

    $.Method({Static:true , Public:true }, "TransformNormal", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float3_TransformNormal$3F
    );

    $.Method({Static:true , Public:true }, "TransformNormalInverse", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.float4x4")], []), 
      float3_TransformNormalInverse$40
    );

    $.Method({Static:true , Public:true }, "TransformNormalInverse", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float3_TransformNormalInverse$41
    );

    $.Method({Static:true , Public:true }, "TransformPerspective", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.float4x4")], []), 
      float3_TransformPerspective$42
    );

    $.Method({Static:true , Public:true }, "TransformPerspective", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float3_TransformPerspective$43
    );

    $.Method({Static:true , Public:true }, "TransformPosition", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.float4x4")], []), 
      float3_TransformPosition$44
    );

    $.Method({Static:true , Public:true }, "TransformPosition", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float3_TransformPosition$45
    );

    $.Method({Static:true , Public:true }, "TransformVector", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.float4x4")], []), 
      float3_TransformVector$46
    );

    $.Method({Static:true , Public:true }, "TransformVector", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float3_TransformVector$47
    );

    $.Field({Static:false, Public:true }, "x", $.Single)
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [1]; }); 
    $.Field({Static:false, Public:true }, "y", $.Single)
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [2]; }); 
    $.Field({Static:false, Public:true }, "z", $.Single)
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [3]; }); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitX", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitY", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "UnitZ", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "Zero", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "One", $.Type); 
    $.Field({Static:true , Public:false}, "float3$Parse$value", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]))
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    function float3__cctor () {
      $thisType.UnitX = new $thisType();
      $thisType.UnitY = new $thisType();
      $thisType.UnitZ = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.One = new $thisType();
      $thisType.UnitX = $S00().Construct(1, 0, 0);
      $thisType.UnitY = $S00().Construct(0, 1, 0);
      $thisType.UnitZ = $S00().Construct(0, 0, 1);
      $thisType.Zero = $S00().Construct(0, 0, 0);
      $thisType.One = $S00().Construct(1, 1, 1);
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      new JSIL.MethodSignature(null, [], []), 
      float3__cctor
    );

    $.Property({Static:false, Public:true }, "Length", $.Single);

    $.Property({Static:false, Public:true }, "LengthFast", $.Single);

    $.Property({Static:false, Public:true }, "LengthSquared", $.Single);

    $.Property({Static:false, Public:true }, "xy", $asm04.TypeRef("Fusee.Math.float2"));

    $.Property({Static:false, Public:true }, "r", $.Single);

    $.Property({Static:false, Public:true }, "g", $.Single);

    $.Property({Static:false, Public:true }, "b", $.Single);

    $.Property({Static:true , Public:true }, "Parse", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]));

    $.ImplementInterfaces(
      /* 0 */ $asm07.TypeRef("System.IEquatable`1", [$.Type])
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm08.TypeRef("ProtoBuf.ProtoContractAttribute"));

})();

/* struct Fusee.Math.float3x3 */ 

(function float3x3$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Math.float3)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm07.System.Single)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Math.float4x4)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.System.Object)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.System.String)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float3x3"), [
        $asm04.TypeRef("Fusee.Math.float3"), $asm04.TypeRef("Fusee.Math.float3"), 
        $asm04.TypeRef("Fusee.Math.float3")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float3x3"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float3"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single")
      ]))) ();
  };

  function float3x3__ctor$00 (row0, row1, row2) {
    this.Row0 = row0;
    this.Row1 = row1;
    this.Row2 = row2;
  };

  function float3x3__ctor$01 (m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    this.Row0 = $S02().Construct(m00, m01, m02);
    this.Row1 = $S02().Construct(m10, m11, m12);
    this.Row2 = $S02().Construct(m20, m21, m22);
  };

  function float3x3__ctor$02 (mat4) {
    this.Row0 = $S02().Construct(mat4.Row0.x, mat4.Row0.y, mat4.Row0.z);
    this.Row1 = $S02().Construct(mat4.Row1.x, mat4.Row1.y, mat4.Row1.z);
    this.Row2 = $S02().Construct(mat4.Row2.x, mat4.Row2.y, mat4.Row2.z);
  };

  function float3x3_Add (left, right) {
    return $S01().Construct((left.get_M11() + right.get_M11()), (left.get_M12() + right.get_M12()), (left.get_M13() + right.get_M13()), (left.get_M21() + right.get_M21()), (left.get_M22() + right.get_M22()), (left.get_M23() + right.get_M23()), (left.get_M31() + right.get_M31()), (left.get_M32() + right.get_M32()), (left.get_M33() + right.get_M33()));
  };

  function float3x3_Object_Equals (obj) {
    return ($thisType.$Is(obj) && this.Equals($thisType.$Cast(obj).MemberwiseClone()));
  };

  function float3x3_Equals$03 (other) {
    return (!(!$T00().op_Equality(this.Row0.MemberwiseClone(), other.Row0.MemberwiseClone()) || 
        !$T00().op_Equality(this.Row1.MemberwiseClone(), other.Row1.MemberwiseClone())) && $T00().op_Equality(this.Row2.MemberwiseClone(), other.Row2.MemberwiseClone()));
  };

  function float3x3_get_Column0 () {
    return $S02().Construct(this.Row0.x, this.Row1.x, this.Row2.x);
  };

  function float3x3_get_Column1 () {
    return $S02().Construct(this.Row0.y, this.Row1.y, this.Row2.y);
  };

  function float3x3_get_Column2 () {
    return $S02().Construct(this.Row0.z, this.Row1.z, this.Row2.z);
  };

  function float3x3_get_Determinant () {
    return +(((((((this.Row0.x * this.Row1.y) * this.Row2.z) + ((this.Row0.y * this.Row1.z) * this.Row2.x)) + ((this.Row0.z * this.Row1.x) * this.Row2.y)) - ((this.Row0.z * this.Row1.y) * this.Row2.x)) - ((this.Row0.y * this.Row1.x) * this.Row2.z)) - ((this.Row0.x * this.Row1.z) * this.Row2.y));
  };

  function float3x3_get_IsAffine () {
    return $T00().op_Equality(this.get_Column2().MemberwiseClone(), $T00().UnitZ.MemberwiseClone());
  };

  function float3x3_get_M11 () {
    return +this.Row0.x;
  };

  function float3x3_get_M12 () {
    return +this.Row0.y;
  };

  function float3x3_get_M13 () {
    return +this.Row0.z;
  };

  function float3x3_get_M21 () {
    return +this.Row1.x;
  };

  function float3x3_get_M22 () {
    return +this.Row1.y;
  };

  function float3x3_get_M23 () {
    return +this.Row1.z;
  };

  function float3x3_get_M31 () {
    return +this.Row2.x;
  };

  function float3x3_get_M32 () {
    return +this.Row2.y;
  };

  function float3x3_get_M33 () {
    return +this.Row2.z;
  };

  function float3x3_GetHashCode () {
    return ((this.Row0.GetHashCode() ^ this.Row1.GetHashCode()) ^ this.Row2.GetHashCode());
  };

  function float3x3_Mult$04 ($left, $right) {
    var right = new JSIL.BoxedVariable($right);
    var left = new JSIL.BoxedVariable($left);
    var result = new JSIL.BoxedVariable(new $thisType());
    if ($thisType.op_Equality(left.get().MemberwiseClone(), $thisType.Identity.MemberwiseClone())) {
      var result2 = right.get().MemberwiseClone();
    } else if ($thisType.op_Equality(right.get().MemberwiseClone(), $thisType.Identity.MemberwiseClone())) {
      result2 = left.get().MemberwiseClone();
    } else if (!(!$thisType.op_Equality(left.get().MemberwiseClone(), $thisType.Zero.MemberwiseClone()) && !$thisType.op_Equality(right.get().MemberwiseClone(), $thisType.Zero.MemberwiseClone()))) {
      result2 = $thisType.Zero.MemberwiseClone();
    } else {
      $thisType.Mult(/* ref */ left, /* ref */ right, /* ref */ result);
      result2 = result.get().MemberwiseClone();
    }
    return result2;
  };

  function float3x3_Mult$05 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S01().Construct((((left.get().get_M11() * right.get().get_M11()) + (left.get().get_M12() * right.get().get_M21())) + (left.get().get_M13() * right.get().get_M31())), (((left.get().get_M11() * right.get().get_M12()) + (left.get().get_M12() * right.get().get_M22())) + (left.get().get_M13() * right.get().get_M32())), (((left.get().get_M11() * right.get().get_M13()) + (left.get().get_M12() * right.get().get_M23())) + (left.get().get_M13() * right.get().get_M33())), (((left.get().get_M21() * right.get().get_M11()) + (left.get().get_M22() * right.get().get_M21())) + (left.get().get_M23() * right.get().get_M31())), (((left.get().get_M21() * right.get().get_M12()) + (left.get().get_M22() * right.get().get_M22())) + (left.get().get_M23() * right.get().get_M32())), (((left.get().get_M21() * right.get().get_M13()) + (left.get().get_M22() * right.get().get_M23())) + (left.get().get_M23() * right.get().get_M33())), (((left.get().get_M31() * right.get().get_M11()) + (left.get().get_M32() * right.get().get_M21())) + (left.get().get_M33() * right.get().get_M31())), (((left.get().get_M31() * right.get().get_M12()) + (left.get().get_M32() * right.get().get_M22())) + (left.get().get_M33() * right.get().get_M32())), (((left.get().get_M31() * right.get().get_M13()) + (left.get().get_M32() * right.get().get_M23())) + (left.get().get_M33() * right.get().get_M33()))));
  };

  function float3x3_op_Addition (left, right) {
    return $thisType.Add(left, right);
  };

  function float3x3_op_Equality (left, right) {
    return left.Equals(right);
  };

  function float3x3_op_Inequality (left, right) {
    return !left.Equals(right);
  };

  function float3x3_op_Multiply$06 (left, right) {
    return $thisType.Mult(left, right);
  };

  function float3x3_op_Multiply$07 (matrix, vector) {
    return $S02().Construct((((matrix.get_Column0().x * vector.x) + (matrix.get_Column1().x * vector.y)) + (matrix.get_Column2().x * vector.z)), (((matrix.get_Column0().y * vector.x) + (matrix.get_Column1().y * vector.y)) + (matrix.get_Column2().y * vector.z)), (((matrix.get_Column0().z * vector.x) + (matrix.get_Column1().z * vector.y)) + (matrix.get_Column2().z * vector.z)));
  };

  function float3x3_op_Multiply$08 (vector, matrix) {
    return $S02().Construct((((matrix.get_M11() * vector.x) + (matrix.get_M21() * vector.y)) + (matrix.get_M31() * vector.z)), (((matrix.get_M12() * vector.x) + (matrix.get_M22() * vector.y)) + (matrix.get_M32() * vector.z)), (((matrix.get_M13() * vector.x) + (matrix.get_M23() * vector.y)) + (matrix.get_M33() * vector.z)));
  };

  function float3x3_op_Subtraction (left, right) {
    return $thisType.Substract(left, right);
  };

  function float3x3_set_M11 (value) {
    this.Row0.x = +value;
  };

  function float3x3_set_M12 (value) {
    this.Row0.y = +value;
  };

  function float3x3_set_M13 (value) {
    this.Row0.z = +value;
  };

  function float3x3_set_M21 (value) {
    this.Row1.x = +value;
  };

  function float3x3_set_M22 (value) {
    this.Row1.y = +value;
  };

  function float3x3_set_M23 (value) {
    this.Row1.z = +value;
  };

  function float3x3_set_M31 (value) {
    this.Row2.x = +value;
  };

  function float3x3_set_M32 (value) {
    this.Row2.y = +value;
  };

  function float3x3_set_M33 (value) {
    this.Row2.z = +value;
  };

  function float3x3_Substract (left, right) {
    return $S01().Construct((left.get_M11() - right.get_M11()), (left.get_M12() - right.get_M12()), (left.get_M13() - right.get_M13()), (left.get_M21() - right.get_M21()), (left.get_M22() - right.get_M22()), (left.get_M23() - right.get_M23()), (left.get_M31() - right.get_M31()), (left.get_M32() - right.get_M32()), (left.get_M33() - right.get_M33()));
  };

  function float3x3_ToArray () {
    return JSIL.Array.New($T01(), [this.get_M11(), this.get_M12(), this.get_M13(), this.get_M21(), this.get_M22(), this.get_M23(), this.get_M31(), this.get_M32(), this.get_M33()]);
  };

  function float3x3_toString () {
    return $T04().Format("{0}\n{1}\n{2}", this.Row0, this.Row1, this.Row2);
  };

  function float3x3_Transpose$09 () {
    JSIL.CopyMembers($thisType.Transpose(this.MemberwiseClone()), this);
  };

  function float3x3_Transpose$0A (mat) {
    return $S00().Construct(mat.get_Column0().MemberwiseClone(), mat.get_Column1().MemberwiseClone(), mat.get_Column2().MemberwiseClone());
  };

  function float3x3_Transpose$0B (/* ref */ mat, /* ref */ result) {
    result.get().Row0 = mat.get().get_Column0().MemberwiseClone();
    result.get().Row1 = mat.get().get_Column1().MemberwiseClone();
    result.get().Row2 = mat.get().get_Column2().MemberwiseClone();
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.float3x3", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 9, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm04.TypeRef("Fusee.Math.float3"), $asm04.TypeRef("Fusee.Math.float3"), 
          $asm04.TypeRef("Fusee.Math.float3")
        ], []), 
      float3x3__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single
        ], []), 
      float3x3__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.float4x4")], []), 
      float3x3__ctor$02
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float3x3_Add
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object], []), 
      float3x3_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type], []), 
      float3x3_Equals$03
    );

    $.Method({Static:false, Public:true }, "get_Column0", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [], []), 
      float3x3_get_Column0
    );

    $.Method({Static:false, Public:true }, "get_Column1", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [], []), 
      float3x3_get_Column1
    );

    $.Method({Static:false, Public:true }, "get_Column2", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [], []), 
      float3x3_get_Column2
    );

    $.Method({Static:false, Public:true }, "get_Determinant", 
      new JSIL.MethodSignature($.Single, [], []), 
      float3x3_get_Determinant
    );

    $.Method({Static:false, Public:true }, "get_IsAffine", 
      new JSIL.MethodSignature($.Boolean, [], []), 
      float3x3_get_IsAffine
    );

    $.Method({Static:false, Public:true }, "get_M11", 
      new JSIL.MethodSignature($.Single, [], []), 
      float3x3_get_M11
    );

    $.Method({Static:false, Public:true }, "get_M12", 
      new JSIL.MethodSignature($.Single, [], []), 
      float3x3_get_M12
    );

    $.Method({Static:false, Public:true }, "get_M13", 
      new JSIL.MethodSignature($.Single, [], []), 
      float3x3_get_M13
    );

    $.Method({Static:false, Public:true }, "get_M21", 
      new JSIL.MethodSignature($.Single, [], []), 
      float3x3_get_M21
    );

    $.Method({Static:false, Public:true }, "get_M22", 
      new JSIL.MethodSignature($.Single, [], []), 
      float3x3_get_M22
    );

    $.Method({Static:false, Public:true }, "get_M23", 
      new JSIL.MethodSignature($.Single, [], []), 
      float3x3_get_M23
    );

    $.Method({Static:false, Public:true }, "get_M31", 
      new JSIL.MethodSignature($.Single, [], []), 
      float3x3_get_M31
    );

    $.Method({Static:false, Public:true }, "get_M32", 
      new JSIL.MethodSignature($.Single, [], []), 
      float3x3_get_M32
    );

    $.Method({Static:false, Public:true }, "get_M33", 
      new JSIL.MethodSignature($.Single, [], []), 
      float3x3_get_M33
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      new JSIL.MethodSignature($.Int32, [], []), 
      float3x3_GetHashCode
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float3x3_Mult$04
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float3x3_Mult$05
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float3x3_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type], []), 
      float3x3_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type], []), 
      float3x3_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float3x3_op_Multiply$06
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$.Type, $asm04.TypeRef("Fusee.Math.float3")], []), 
      float3x3_op_Multiply$07
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$asm04.TypeRef("Fusee.Math.float3"), $.Type], []), 
      float3x3_op_Multiply$08
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float3x3_op_Subtraction
    );

    $.Method({Static:false, Public:true }, "set_M11", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float3x3_set_M11
    );

    $.Method({Static:false, Public:true }, "set_M12", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float3x3_set_M12
    );

    $.Method({Static:false, Public:true }, "set_M13", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float3x3_set_M13
    );

    $.Method({Static:false, Public:true }, "set_M21", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float3x3_set_M21
    );

    $.Method({Static:false, Public:true }, "set_M22", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float3x3_set_M22
    );

    $.Method({Static:false, Public:true }, "set_M23", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float3x3_set_M23
    );

    $.Method({Static:false, Public:true }, "set_M31", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float3x3_set_M31
    );

    $.Method({Static:false, Public:true }, "set_M32", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float3x3_set_M32
    );

    $.Method({Static:false, Public:true }, "set_M33", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float3x3_set_M33
    );

    $.Method({Static:true , Public:true }, "Substract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float3x3_Substract
    );

    $.Method({Static:false, Public:false}, "ToArray", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Single]), [], []), 
      float3x3_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      new JSIL.MethodSignature($.String, [], []), 
      float3x3_toString
    );

    $.Method({Static:false, Public:true }, "Transpose", 
      new JSIL.MethodSignature(null, [], []), 
      float3x3_Transpose$09
    );

    $.Method({Static:true , Public:true }, "Transpose", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      float3x3_Transpose$0A
    );

    $.Method({Static:true , Public:true }, "Transpose", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      float3x3_Transpose$0B
    );

    $.Field({Static:false, Public:true }, "Row0", $asm04.TypeRef("Fusee.Math.float3")); 
    $.Field({Static:false, Public:true }, "Row1", $asm04.TypeRef("Fusee.Math.float3")); 
    $.Field({Static:false, Public:true }, "Row2", $asm04.TypeRef("Fusee.Math.float3")); 
    $.Field({Static:true , Public:true }, "Identity", $.Type); 
    $.Field({Static:true , Public:true }, "Zero", $.Type); 
    function float3x3__cctor () {
      $thisType.Identity = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.Identity = $S00().Construct($T00().UnitX.MemberwiseClone(), $T00().UnitY.MemberwiseClone(), $T00().UnitZ.MemberwiseClone());
      $thisType.Zero = $S01().Construct(0, 0, 0, 0, 0, 0, 0, 0, 0);
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      new JSIL.MethodSignature(null, [], []), 
      float3x3__cctor
    );

    $.Property({Static:false, Public:true }, "Determinant", $.Single);

    $.Property({Static:false, Public:true }, "Column0", $asm04.TypeRef("Fusee.Math.float3"));

    $.Property({Static:false, Public:true }, "Column1", $asm04.TypeRef("Fusee.Math.float3"));

    $.Property({Static:false, Public:true }, "Column2", $asm04.TypeRef("Fusee.Math.float3"));

    $.Property({Static:false, Public:true }, "M11", $.Single);

    $.Property({Static:false, Public:true }, "M12", $.Single);

    $.Property({Static:false, Public:true }, "M13", $.Single);

    $.Property({Static:false, Public:true }, "M21", $.Single);

    $.Property({Static:false, Public:true }, "M22", $.Single);

    $.Property({Static:false, Public:true }, "M23", $.Single);

    $.Property({Static:false, Public:true }, "M31", $.Single);

    $.Property({Static:false, Public:true }, "M32", $.Single);

    $.Property({Static:false, Public:true }, "M33", $.Single);

    $.Property({Static:false, Public:true }, "IsAffine", $.Boolean);

    $.ImplementInterfaces(
      /* 0 */ $asm07.TypeRef("System.IEquatable`1", [$.Type])
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Math.float4 */ 

(function float4$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm07.System.Single)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm04.Fusee.Math.float2)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Math.float3)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm04.Fusee.Math.double4)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.System.Object)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm07.System.Void)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm07.System.Double)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm04.Fusee.Math.MathHelper)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm07.System.Math)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm07.System.Converter$b2.Of($asm07.System.String, $asm04.Fusee.Math.float4))) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm07.System.String)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm04.Fusee.Math.float4x4)) ();
  };
  var $T0C = function () {
    return ($T0C = JSIL.Memoize($asm04.Fusee.Math.Quaternion)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float4"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float4"), [$asm07.TypeRef("System.Single"), $asm04.TypeRef("Fusee.Math.float4")], []))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")]), $asm07.TypeRef("System.Single"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")])
      ], []))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")]), $asm07.TypeRef("System.Single"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")])
      ], []))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")])
      ], []))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("System.Single"), [$asm07.TypeRef("System.Single")], []))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float2"), [$asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single")]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float3"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")])
      ], []))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float4"), [$asm04.TypeRef("Fusee.Math.double4")]))) ();
  };
  var $S0A = function () {
    return ($S0A = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("System.Double"), [$asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Int32")], []))) ();
  };
  var $S0B = function () {
    return ($S0B = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4x4")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")])
      ], []))) ();
  };
  var $S0C = function () {
    return ($S0C = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4")])
      ], []))) ();
  };
  var $S0D = function () {
    return ($S0D = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.Quaternion"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S0E = function () {
    return ($S0E = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")])
      ], []))) ();
  };

  function float4__ctor$00 (x, y, z, w) {
    JSIL.CopyMembers(new $thisType(), this);
    this.x = +x;
    this.y = +y;
    this.z = +z;
    this.w = +w;
  };

  function float4__ctor$01 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +0;
    this.w = +0;
  };

  function float4__ctor$02 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
    this.w = +0;
  };

  function float4__ctor$03 (v, ww) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
    this.w = +ww;
  };

  function float4__ctor$04 (v) {
    this.x = +v.x;
    this.y = +v.y;
    this.z = +v.z;
    this.w = +v.w;
  };

  function float4__ctor$05 (d4) {
    this.x = +$T00().$Cast(d4.x);
    this.y = +$T00().$Cast(d4.y);
    this.z = +$T00().$Cast(d4.z);
    this.w = +$T00().$Cast(d4.w);
  };

  function float4_Add$06 (right) {
    this.x += +right.x;
    this.y += +right.y;
    this.z += +right.z;
    this.w += +right.w;
  };

  function float4_Add$07 (/* ref */ right) {
    this.x += +right.get().x;
    this.y += +right.get().y;
    this.z += +right.get().z;
    this.w += +right.get().w;
  };

  function float4_Add$08 ($a, $b) {
    var b = new JSIL.BoxedVariable($b);
    var a = new JSIL.BoxedVariable($a);
    $thisType.Add(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  };

  function float4_Add$09 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((a.get().x + b.get().x), (a.get().y + b.get().y), (a.get().z + b.get().z), (a.get().w + b.get().w)));
  };

  function float4_BaryCentric$0A (a, b, c, u, v) {
    return $thisType.op_Addition(
      $thisType.op_Addition(a.MemberwiseClone(), $S01().CallStatic($thisType, "op_Multiply", null, u, $thisType.op_Subtraction(b, a.MemberwiseClone()))).MemberwiseClone(), 
      $S01().CallStatic($thisType, "op_Multiply", null, v, $thisType.op_Subtraction(c, a.MemberwiseClone()))
    );
  };

  function float4_BaryCentric$0B (/* ref */ a, /* ref */ b, /* ref */ c, u, v, /* ref */ result) {
    result.set(a.get().MemberwiseClone());
    var temp = new JSIL.BoxedVariable(b.get().MemberwiseClone());
    $thisType.Subtract(/* ref */ temp, /* ref */ a, /* ref */ temp);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ temp, u, /* ref */ temp);
    $thisType.Add(/* ref */ result, /* ref */ temp, /* ref */ result);
    temp.set(c.get().MemberwiseClone());
    $thisType.Subtract(/* ref */ temp, /* ref */ a, /* ref */ temp);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ temp, v, /* ref */ temp);
    $thisType.Add(/* ref */ result, /* ref */ temp, /* ref */ result);
  };

  function float4_Clamp$0C (vec, min, max) {
    vec.x = +((vec.x < min.x) ? min.x : ((vec.x > max.x) ? max.x : vec.x));
    vec.y = +((vec.y < min.y) ? min.y : ((vec.y > max.y) ? max.y : vec.y));
    vec.z = +((vec.x < min.z) ? min.z : ((vec.z > max.z) ? max.z : vec.z));
    vec.w = +((vec.y < min.w) ? min.w : ((vec.w > max.w) ? max.w : vec.w));
    return vec;
  };

  function float4_Clamp$0D (/* ref */ vec, /* ref */ min, /* ref */ max, /* ref */ result) {
    result.get().x = +((vec.get().x < min.get().x) ? min.get().x : ((vec.get().x > max.get().x) ? max.get().x : vec.get().x));
    result.get().y = +((vec.get().y < min.get().y) ? min.get().y : ((vec.get().y > max.get().y) ? max.get().y : vec.get().y));
    result.get().z = +((vec.get().x < min.get().z) ? min.get().z : ((vec.get().z > max.get().z) ? max.get().z : vec.get().z));
    result.get().w = +((vec.get().y < min.get().w) ? min.get().w : ((vec.get().w > max.get().w) ? max.get().w : vec.get().w));
  };

  function float4_Div$0E (f) {
    var mult = +(1 / f);
    this.x *= +mult;
    this.y *= +mult;
    this.z *= +mult;
    this.w *= +mult;
  };

  function float4_Div$0F (a, f) {
    var mult = +(1 / f);
    a.x *= +mult;
    a.y *= +mult;
    a.z *= +mult;
    a.w *= +mult;
    return a;
  };

  function float4_Div$10 (/* ref */ a, f, /* ref */ result) {
    var mult = +(1 / f);
    result.get().x = +(a.get().x * mult);
    result.get().y = +(a.get().y * mult);
    result.get().z = +(a.get().z * mult);
    result.get().w = +(a.get().w * mult);
  };

  function float4_Divide$11 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector);
    $S03().CallStatic($thisType, "Divide", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  };

  function float4_Divide$12 (/* ref */ vector, scale, /* ref */ result) {
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vector, (1 / scale), /* ref */ result);
  };

  function float4_Divide$13 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale);
    var vector = new JSIL.BoxedVariable($vector);
    $S04().CallStatic($thisType, "Divide", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  };

  function float4_Divide$14 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct((vector.get().x / scale.get().x), (vector.get().y / scale.get().y), (vector.get().z / scale.get().z), (vector.get().w / scale.get().w)));
  };

  function float4_Dot$15 (left, right) {
    return +((((left.x * right.x) + (left.y * right.y)) + (left.z * right.z)) + (left.w * right.w));
  };

  function float4_Dot$16 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set(((((left.get().x * right.get().x) + (left.get().y * right.get().y)) + (left.get().z * right.get().z)) + (left.get().w * right.get().w)));
  };

  function float4_Object_Equals (obj) {
    return ($thisType.$Is(obj) && this.Equals($thisType.$Cast(obj).MemberwiseClone()));
  };

  function float4_Equals$17 (other) {
    return (!(((Math.abs((this.x - other.x))) >= 1.192093E-07) || 
        ((Math.abs((this.y - other.y))) >= 1.192093E-07) || 
        ((Math.abs((this.z - other.z))) >= 1.192093E-07)) && ((Math.abs((this.w - other.w))) < 1.192093E-07));
  };

  function float4_get_a () {
    return +this.w;
  };

  function float4_get_b () {
    return +this.z;
  };

  function float4_get_g () {
    return +this.y;
  };

  function float4_get_Length () {
    return +$T00().$Cast(Math.sqrt(((((this.x * this.x) + (this.y * this.y)) + (this.z * this.z)) + (this.w * this.w))));
  };

  function float4_get_LengthFast () {
    return +(1 / $S05().CallStatic($T07(), "InverseSqrtFast", null, ((((this.x * this.x) + (this.y * this.y)) + (this.z * this.z)) + (this.w * this.w))));
  };

  function float4_get_LengthSquared () {
    return +((((this.x * this.x) + (this.y * this.y)) + (this.z * this.z)) + (this.w * this.w));
  };

  function float4_get_Parse () {
    return $thisType.float4$Parse$value;
  };

  function float4_get_r () {
    return +this.x;
  };

  function float4_get_rgb () {
    return this.get_xyz();
  };

  function float4_get_xy () {
    return $S06().Construct(this.x, this.y);
  };

  function float4_get_xyz () {
    return $S07().Construct(this.x, this.y, this.z);
  };

  function float4_GetHashCode () {
    return (((this.x.GetHashCode() ^ this.y.GetHashCode()) ^ this.z.GetHashCode()) ^ this.w.GetHashCode());
  };

  function float4_Lerp$18 (a, b, blend) {
    a.x = +((blend * (b.x - a.x)) + a.x);
    a.y = +((blend * (b.y - a.y)) + a.y);
    a.z = +((blend * (b.z - a.z)) + a.z);
    a.w = +((blend * (b.w - a.w)) + a.w);
    return a;
  };

  function float4_Lerp$19 (/* ref */ a, /* ref */ b, blend, /* ref */ result) {
    result.get().x = +((blend * (b.get().x - a.get().x)) + a.get().x);
    result.get().y = +((blend * (b.get().y - a.get().y)) + a.get().y);
    result.get().z = +((blend * (b.get().z - a.get().z)) + a.get().z);
    result.get().w = +((blend * (b.get().w - a.get().w)) + a.get().w);
  };

  function float4_Max$1A (a, b) {
    a.x = +((a.x > b.x) ? a.x : b.x);
    a.y = +((a.y > b.y) ? a.y : b.y);
    a.z = +((a.z > b.z) ? a.z : b.z);
    a.w = +((a.w > b.w) ? a.w : b.w);
    return a;
  };

  function float4_Max$1B (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +((a.get().x > b.get().x) ? a.get().x : b.get().x);
    result.get().y = +((a.get().y > b.get().y) ? a.get().y : b.get().y);
    result.get().z = +((a.get().z > b.get().z) ? a.get().z : b.get().z);
    result.get().w = +((a.get().w > b.get().w) ? a.get().w : b.get().w);
  };

  function float4_Min$1C (a, b) {
    a.x = +((a.x < b.x) ? a.x : b.x);
    a.y = +((a.y < b.y) ? a.y : b.y);
    a.z = +((a.z < b.z) ? a.z : b.z);
    a.w = +((a.w < b.w) ? a.w : b.w);
    return a;
  };

  function float4_Min$1D (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +((a.get().x < b.get().x) ? a.get().x : b.get().x);
    result.get().y = +((a.get().y < b.get().y) ? a.get().y : b.get().y);
    result.get().z = +((a.get().z < b.get().z) ? a.get().z : b.get().z);
    result.get().w = +((a.get().w < b.get().w) ? a.get().w : b.get().w);
  };

  function float4_Mult$1E (f) {
    this.x *= +f;
    this.y *= +f;
    this.z *= +f;
    this.w *= +f;
  };

  function float4_Mult$1F (a, f) {
    a.x *= +f;
    a.y *= +f;
    a.z *= +f;
    a.w *= +f;
    return a;
  };

  function float4_Mult$20 (/* ref */ a, f, /* ref */ result) {
    result.get().x = +(a.get().x * f);
    result.get().y = +(a.get().y * f);
    result.get().z = +(a.get().z * f);
    result.get().w = +(a.get().w * f);
  };

  function float4_Multiply$21 ($vector, scale) {
    var vector = new JSIL.BoxedVariable($vector);
    $S02().CallStatic($thisType, "Multiply", null, /* ref */ vector, scale, /* ref */ vector);
    return vector.get();
  };

  function float4_Multiply$22 (/* ref */ vector, scale, /* ref */ result) {
    result.set($S00().Construct((vector.get().x * scale), (vector.get().y * scale), (vector.get().z * scale), (vector.get().w * scale)));
  };

  function float4_Multiply$23 ($vector, $scale) {
    var scale = new JSIL.BoxedVariable($scale);
    var vector = new JSIL.BoxedVariable($vector);
    $S08().CallStatic($thisType, "Multiply", null, /* ref */ vector, /* ref */ scale, /* ref */ vector);
    return vector.get();
  };

  function float4_Multiply$24 (/* ref */ vector, /* ref */ scale, /* ref */ result) {
    result.set($S00().Construct((vector.get().x * scale.get().x), (vector.get().y * scale.get().y), (vector.get().z * scale.get().z), (vector.get().w * scale.get().w)));
  };

  function float4_Normalize$25 () {
    var scale = +(1 / this.get_Length());
    this.x *= +scale;
    this.y *= +scale;
    this.z *= +scale;
    this.w *= +scale;
  };

  function float4_Normalize$26 (vec) {
    var scale = +(1 / vec.get_Length());
    vec.x *= +scale;
    vec.y *= +scale;
    vec.z *= +scale;
    vec.w *= +scale;
    return vec;
  };

  function float4_Normalize$27 (/* ref */ vec, /* ref */ result) {
    var scale = +(1 / vec.get().get_Length());
    result.get().x = +(vec.get().x * scale);
    result.get().y = +(vec.get().y * scale);
    result.get().z = +(vec.get().z * scale);
    result.get().w = +(vec.get().w * scale);
  };

  function float4_NormalizeFast$28 () {
    var scale = +$S05().CallStatic($T07(), "InverseSqrtFast", null, ((((this.x * this.x) + (this.y * this.y)) + (this.z * this.z)) + (this.w * this.w)));
    this.x *= +scale;
    this.y *= +scale;
    this.z *= +scale;
    this.w *= +scale;
  };

  function float4_NormalizeFast$29 (vec) {
    var scale = +$S05().CallStatic($T07(), "InverseSqrtFast", null, ((((vec.x * vec.x) + (vec.y * vec.y)) + (vec.z * vec.z)) + (vec.w * vec.w)));
    vec.x *= +scale;
    vec.y *= +scale;
    vec.z *= +scale;
    vec.w *= +scale;
    return vec;
  };

  function float4_NormalizeFast$2A (/* ref */ vec, /* ref */ result) {
    var scale = +$S05().CallStatic($T07(), "InverseSqrtFast", null, ((((vec.get().x * vec.get().x) + (vec.get().y * vec.get().y)) + (vec.get().z * vec.get().z)) + (vec.get().w * vec.get().w)));
    result.get().x = +(vec.get().x * scale);
    result.get().y = +(vec.get().y * scale);
    result.get().z = +(vec.get().z * scale);
    result.get().w = +(vec.get().w * scale);
  };

  function float4_op_Addition (left, right) {
    left.x += +right.x;
    left.y += +right.y;
    left.z += +right.z;
    left.w += +right.w;
    return left;
  };

  function float4_op_Division (vec, scale) {
    var mult = +(1 / scale);
    vec.x *= +mult;
    vec.y *= +mult;
    vec.z *= +mult;
    vec.w *= +mult;
    return vec;
  };

  function float4_op_Equality (left, right) {
    return left.Equals(right);
  };

  function float4_op_Explicit (d4) {
    return $S09().Construct(d4);
  };

  function float4_op_Inequality (left, right) {
    return !left.Equals(right);
  };

  function float4_op_Multiply$2B (vec, scale) {
    vec.x *= +scale;
    vec.y *= +scale;
    vec.z *= +scale;
    vec.w *= +scale;
    return vec;
  };

  function float4_op_Multiply$2C (scale, vec) {
    vec.x *= +scale;
    vec.y *= +scale;
    vec.z *= +scale;
    vec.w *= +scale;
    return vec;
  };

  function float4_op_Subtraction (left, right) {
    left.x -= +right.x;
    left.y -= +right.y;
    left.z -= +right.z;
    left.w -= +right.w;
    return left;
  };

  function float4_op_UnaryNegation (vec) {
    vec.x = +-vec.x;
    vec.y = +-vec.y;
    vec.z = +-vec.z;
    vec.w = +-vec.w;
    return vec;
  };

  function float4_Round$2D () {
    this.x = +$T00().$Cast($S0A().CallStatic($T08(), "Round", null, this.x, 6));
    this.y = +$T00().$Cast($S0A().CallStatic($T08(), "Round", null, this.y, 6));
    this.z = +$T00().$Cast($S0A().CallStatic($T08(), "Round", null, this.z, 6));
    this.w = +$T00().$Cast($S0A().CallStatic($T08(), "Round", null, this.w, 6));
  };

  function float4_Round$2E (vec) {
    return $S00().Construct($T00().$Cast($S0A().CallStatic($T08(), "Round", null, vec.x, 6)), $T00().$Cast($S0A().CallStatic($T08(), "Round", null, vec.y, 6)), $T00().$Cast($S0A().CallStatic($T08(), "Round", null, vec.z, 6)), $T00().$Cast($S0A().CallStatic($T08(), "Round", null, vec.w, 6)));
  };

  function float4_Scale$2F (sx, sy, sz, sw) {
    this.x *= +sx;
    this.y *= +sy;
    this.z *= +sz;
    this.w *= +sw;
  };

  function float4_Scale$30 (scale) {
    this.x *= +scale.x;
    this.y *= +scale.y;
    this.z *= +scale.z;
    this.w *= +scale.w;
  };

  function float4_Scale$31 (/* ref */ scale) {
    this.x *= +scale.get().x;
    this.y *= +scale.get().y;
    this.z *= +scale.get().z;
    this.w *= +scale.get().w;
  };

  function float4_set_a (value) {
    this.w = +value;
  };

  function float4_set_b (value) {
    this.z = +value;
  };

  function float4_set_g (value) {
    this.y = +value;
  };

  function float4_set_Parse (value) {
    $thisType.float4$Parse$value = value;
  };

  function float4_set_r (value) {
    this.x = +value;
  };

  function float4_set_rgb (value) {
    (this.xyz = value);
  };

  function float4_set_xy (value) {
    this.x = +value.x;
    this.y = +value.y;
  };

  function float4_set_xyz (value) {
    this.x = +value.x;
    this.y = +value.y;
    this.z = +value.z;
  };

  function float4_Sub$32 (right) {
    this.x -= +right.x;
    this.y -= +right.y;
    this.z -= +right.z;
    this.w -= +right.w;
  };

  function float4_Sub$33 (/* ref */ right) {
    this.x -= +right.get().x;
    this.y -= +right.get().y;
    this.z -= +right.get().z;
    this.w -= +right.get().w;
  };

  function float4_Sub$34 (a, b) {
    a.x -= +b.x;
    a.y -= +b.y;
    a.z -= +b.z;
    a.w -= +b.w;
    return a;
  };

  function float4_Sub$35 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.get().x = +(a.get().x - b.get().x);
    result.get().y = +(a.get().y - b.get().y);
    result.get().z = +(a.get().z - b.get().z);
    result.get().w = +(a.get().w - b.get().w);
  };

  function float4_Subtract$36 ($a, $b) {
    var b = new JSIL.BoxedVariable($b);
    var a = new JSIL.BoxedVariable($a);
    $thisType.Subtract(/* ref */ a, /* ref */ b, /* ref */ a);
    return a.get();
  };

  function float4_Subtract$37 (/* ref */ a, /* ref */ b, /* ref */ result) {
    result.set($S00().Construct((a.get().x - b.get().x), (a.get().y - b.get().y), (a.get().z - b.get().z), (a.get().w - b.get().w)));
  };

  function float4_ToArray () {
    return JSIL.Array.New($T00(), [this.x, this.y, this.z, this.w]);
  };

  function float4_toString () {
    return $T0A().Format("({0}, {1}, {2}, {3})", JSIL.Array.New($T04(), [this.x, this.y, this.z, this.w]));
  };

  function float4_Transform$38 ($vec, $mat) {
    var mat = new JSIL.BoxedVariable($mat);
    var vec = new JSIL.BoxedVariable($vec);
    var result = new JSIL.BoxedVariable(new $thisType());
    $S0B().CallStatic($thisType, "Transform", null, /* ref */ vec, /* ref */ mat, /* ref */ result);
    return result.get();
  };

  function float4_Transform$39 (/* ref */ vec, /* ref */ mat, /* ref */ result) {
    result.set($S00().Construct(((((vec.get().x * mat.get().Row0.x) + (vec.get().y * mat.get().Row1.x)) + (vec.get().z * mat.get().Row2.x)) + (vec.get().w * mat.get().Row3.x)), ((((vec.get().x * mat.get().Row0.y) + (vec.get().y * mat.get().Row1.y)) + (vec.get().z * mat.get().Row2.y)) + (vec.get().w * mat.get().Row3.y)), ((((vec.get().x * mat.get().Row0.z) + (vec.get().y * mat.get().Row1.z)) + (vec.get().z * mat.get().Row2.z)) + (vec.get().w * mat.get().Row3.z)), ((((vec.get().x * mat.get().Row0.w) + (vec.get().y * mat.get().Row1.w)) + (vec.get().z * mat.get().Row2.w)) + (vec.get().w * mat.get().Row3.w))));
  };

  function float4_Transform$3A ($vec, $quat) {
    var quat = new JSIL.BoxedVariable($quat);
    var vec = new JSIL.BoxedVariable($vec);
    var result = new JSIL.BoxedVariable(new $thisType());
    $S0C().CallStatic($thisType, "Transform", null, /* ref */ vec, /* ref */ quat, /* ref */ result);
    return result.get();
  };

  function float4_Transform$3B (/* ref */ vec, /* ref */ quat, /* ref */ result) {
    var i = new JSIL.BoxedVariable(new ($T0C())());
    var t = new JSIL.BoxedVariable(new ($T0C())());
    var v = new JSIL.BoxedVariable($S0D().Construct(vec.get().x, vec.get().y, vec.get().z, vec.get().w));
    $T0C().Invert(/* ref */ quat, /* ref */ i);
    $S0E().CallStatic($T0C(), "Multiply", null, /* ref */ quat, /* ref */ v, /* ref */ t);
    $S0E().CallStatic($T0C(), "Multiply", null, /* ref */ t, /* ref */ i, /* ref */ v);
    result.set($S00().Construct(v.get().get_x(), v.get().get_y(), v.get().get_z(), v.get().get_w()));
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.float4", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 4, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single
        ], []), 
      float4__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.float2")], []), 
      float4__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.float3")], []), 
      float4__ctor$02
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.float3"), $.Single], []), 
      float4__ctor$03
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$.Type], []), 
      float4__ctor$04
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.double4")], []), 
      float4__ctor$05
    );

    $.Method({Static:false, Public:true }, "Add", 
      new JSIL.MethodSignature(null, [$.Type], []), 
      float4_Add$06
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:false, Public:true }, "Add", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      float4_Add$07
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Add() method instead."]; });

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float4_Add$08
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4_Add$09
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type, $.Single, 
          $.Single
        ], []), 
      float4_BaryCentric$0A
    );

    $.Method({Static:true , Public:true }, "BaryCentric", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4_BaryCentric$0B
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Type
        ], []), 
      float4_Clamp$0C
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4_Clamp$0D
    );

    $.Method({Static:false, Public:true }, "Div", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float4_Div$0E
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Divide() method instead."]; });

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single], []), 
      float4_Div$0F
    );

    $.Method({Static:true , Public:true }, "Div", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4_Div$10
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single], []), 
      float4_Divide$11
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4_Divide$12
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float4_Divide$13
    );

    $.Method({Static:true , Public:true }, "Divide", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4_Divide$14
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature($.Single, [$.Type, $.Type], []), 
      float4_Dot$15
    );

    $.Method({Static:true , Public:true }, "Dot", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Single])
        ], []), 
      float4_Dot$16
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object], []), 
      float4_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type], []), 
      float4_Equals$17
    );

    $.Method({Static:false, Public:true }, "get_a", 
      new JSIL.MethodSignature($.Single, [], []), 
      float4_get_a
    );

    $.Method({Static:false, Public:true }, "get_b", 
      new JSIL.MethodSignature($.Single, [], []), 
      float4_get_b
    );

    $.Method({Static:false, Public:true }, "get_g", 
      new JSIL.MethodSignature($.Single, [], []), 
      float4_get_g
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      new JSIL.MethodSignature($.Single, [], []), 
      float4_get_Length
    );

    $.Method({Static:false, Public:true }, "get_LengthFast", 
      new JSIL.MethodSignature($.Single, [], []), 
      float4_get_LengthFast
    );

    $.Method({Static:false, Public:true }, "get_LengthSquared", 
      new JSIL.MethodSignature($.Single, [], []), 
      float4_get_LengthSquared
    );

    $.Method({Static:true , Public:true }, "get_Parse", 
      new JSIL.MethodSignature($asm07.TypeRef("System.Converter`2", [$.String, $.Type]), [], []), 
      float4_get_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "get_r", 
      new JSIL.MethodSignature($.Single, [], []), 
      float4_get_r
    );

    $.Method({Static:false, Public:true }, "get_rgb", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [], []), 
      float4_get_rgb
    );

    $.Method({Static:false, Public:true }, "get_xy", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float2"), [], []), 
      float4_get_xy
    );

    $.Method({Static:false, Public:true }, "get_xyz", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [], []), 
      float4_get_xyz
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      new JSIL.MethodSignature($.Int32, [], []), 
      float4_GetHashCode
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Single
        ], []), 
      float4_Lerp$18
    );

    $.Method({Static:true , Public:true }, "Lerp", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4_Lerp$19
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float4_Max$1A
    );

    $.Method({Static:true , Public:true }, "Max", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4_Max$1B
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float4_Min$1C
    );

    $.Method({Static:true , Public:true }, "Min", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4_Min$1D
    );

    $.Method({Static:false, Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float4_Mult$1E
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single], []), 
      float4_Mult$1F
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4_Mult$20
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single], []), 
      float4_Multiply$21
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4_Multiply$22
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float4_Multiply$23
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4_Multiply$24
    );

    $.Method({Static:false, Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [], []), 
      float4_Normalize$25
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      float4_Normalize$26
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      float4_Normalize$27
    );

    $.Method({Static:false, Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature(null, [], []), 
      float4_NormalizeFast$28
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      float4_NormalizeFast$29
    );

    $.Method({Static:true , Public:true }, "NormalizeFast", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      float4_NormalizeFast$2A
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float4_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Division", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single], []), 
      float4_op_Division
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type], []), 
      float4_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Explicit", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.double4")], []), 
      float4_op_Explicit
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type], []), 
      float4_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single], []), 
      float4_op_Multiply$2B
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Single, $.Type], []), 
      float4_op_Multiply$2C
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float4_op_Subtraction
    );

    $.Method({Static:true , Public:true }, "op_UnaryNegation", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      float4_op_UnaryNegation
    );

    $.Method({Static:false, Public:true }, "Round", 
      new JSIL.MethodSignature(null, [], []), 
      float4_Round$2D
    );

    $.Method({Static:true , Public:true }, "Round", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      float4_Round$2E
    );

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single
        ], []), 
      float4_Scale$2F
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [$.Type], []), 
      float4_Scale$30
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "Scale", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      float4_Scale$31
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Multiply() method instead."]; });

    $.Method({Static:false, Public:true }, "set_a", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float4_set_a
    );

    $.Method({Static:false, Public:true }, "set_b", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float4_set_b
    );

    $.Method({Static:false, Public:true }, "set_g", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float4_set_g
    );

    $.Method({Static:true , Public:true }, "set_Parse", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("System.Converter`2", [$.String, $.Type])], []), 
      float4_set_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true }, "set_r", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float4_set_r
    );

    $.Method({Static:false, Public:true }, "set_rgb", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.float3")], []), 
      float4_set_rgb
    );

    $.Method({Static:false, Public:true }, "set_xy", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.float2")], []), 
      float4_set_xy
    );

    $.Method({Static:false, Public:true }, "set_xyz", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.float3")], []), 
      float4_set_xyz
    );

    $.Method({Static:false, Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [$.Type], []), 
      float4_Sub$32
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:false, Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      float4_Sub$33
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use static Subtract() method instead."]; });

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float4_Sub$34
    );

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4_Sub$35
    );

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float4_Subtract$36
    );

    $.Method({Static:true , Public:true }, "Subtract", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4_Subtract$37
    );

    $.Method({Static:false, Public:true }, "ToArray", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Single]), [], []), 
      float4_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      new JSIL.MethodSignature($.String, [], []), 
      float4_toString
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.float4x4")], []), 
      float4_Transform$38
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4x4")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4_Transform$39
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($.Type, [$.Type, $asm04.TypeRef("Fusee.Math.Quaternion")], []), 
      float4_Transform$3A
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4_Transform$3B
    );

    $.Field({Static:false, Public:true }, "x", $.Single)
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [1]; }); 
    $.Field({Static:false, Public:true }, "y", $.Single)
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [2]; }); 
    $.Field({Static:false, Public:true }, "z", $.Single)
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [3]; }); 
    $.Field({Static:false, Public:true }, "w", $.Single)
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [4]; }); 
    $.Field({Static:true , Public:true }, "UnitX", $.Type); 
    $.Field({Static:true , Public:true }, "UnitY", $.Type); 
    $.Field({Static:true , Public:true }, "UnitZ", $.Type); 
    $.Field({Static:true , Public:true }, "UnitW", $.Type); 
    $.Field({Static:true , Public:true }, "Zero", $.Type); 
    $.Field({Static:true , Public:true , ReadOnly:true }, "One", $.Type); 
    $.Field({Static:true , Public:false}, "float4$Parse$value", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]))
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    function float4__cctor () {
      $thisType.UnitX = new $thisType();
      $thisType.UnitY = new $thisType();
      $thisType.UnitZ = new $thisType();
      $thisType.UnitW = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.One = new $thisType();
      $thisType.UnitX = $S00().Construct(1, 0, 0, 0);
      $thisType.UnitY = $S00().Construct(0, 1, 0, 0);
      $thisType.UnitZ = $S00().Construct(0, 0, 1, 0);
      $thisType.UnitW = $S00().Construct(0, 0, 0, 1);
      $thisType.Zero = $S00().Construct(0, 0, 0, 0);
      $thisType.One = $S00().Construct(1, 1, 1, 1);
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      new JSIL.MethodSignature(null, [], []), 
      float4__cctor
    );

    $.Property({Static:false, Public:true }, "Length", $.Single);

    $.Property({Static:false, Public:true }, "LengthFast", $.Single);

    $.Property({Static:false, Public:true }, "LengthSquared", $.Single);

    $.Property({Static:false, Public:true }, "xy", $asm04.TypeRef("Fusee.Math.float2"));

    $.Property({Static:false, Public:true }, "xyz", $asm04.TypeRef("Fusee.Math.float3"));

    $.Property({Static:false, Public:true }, "r", $.Single);

    $.Property({Static:false, Public:true }, "g", $.Single);

    $.Property({Static:false, Public:true }, "b", $.Single);

    $.Property({Static:false, Public:true }, "rgb", $asm04.TypeRef("Fusee.Math.float3"));

    $.Property({Static:false, Public:true }, "a", $.Single);

    $.Property({Static:true , Public:true }, "Parse", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]));

    $.ImplementInterfaces(
      /* 0 */ $asm07.TypeRef("System.IEquatable`1", [$.Type])
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm08.TypeRef("ProtoBuf.ProtoContractAttribute"));

})();

/* struct Fusee.Math.float4x4 */ 

(function float4x4$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Math.float4)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm07.System.Single)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm04.Fusee.Math.double4x4)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm04.Fusee.Math.float3)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.System.Void)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm07.System.Double)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm07.System.ArgumentOutOfRangeException)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm07.System.Object)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize($asm07.System.ApplicationException)) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm07.System.Converter$b2.Of($asm07.System.String, $asm04.Fusee.Math.float4x4))) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm07.System.String)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float4x4"), [
        $asm04.TypeRef("Fusee.Math.float4"), $asm04.TypeRef("Fusee.Math.float4"), 
        $asm04.TypeRef("Fusee.Math.float4"), $asm04.TypeRef("Fusee.Math.float4")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float4"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float4x4"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("System.ArgumentOutOfRangeException"), [$asm07.TypeRef("System.String")]))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature(null, [$asm07.TypeRef("System.Single"), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float4x4")])], []))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float3"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("System.ApplicationException"), [$asm07.TypeRef("System.String")]))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float4x4"), [$asm04.TypeRef("Fusee.Math.double4x4")]))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float4"), [$asm04.TypeRef("Fusee.Math.float4"), $asm07.TypeRef("System.Single")], []))) ();
  };

  function float4x4__ctor$00 (row0, row1, row2, row3) {
    this.Row0 = row0;
    this.Row1 = row1;
    this.Row2 = row2;
    this.Row3 = row3;
  };

  function float4x4__ctor$01 (m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    this.Row0 = $S01().Construct(m00, m01, m02, m03);
    this.Row1 = $S01().Construct(m10, m11, m12, m13);
    this.Row2 = $S01().Construct(m20, m21, m22, m23);
    this.Row3 = $S01().Construct(m30, m31, m32, m33);
  };

  function float4x4__ctor$02 (d4x4) {
    this.Row0 = $T00().op_Explicit(d4x4.Row0.MemberwiseClone());
    this.Row1 = $T00().op_Explicit(d4x4.Row1.MemberwiseClone());
    this.Row2 = $T00().op_Explicit(d4x4.Row2.MemberwiseClone());
    this.Row3 = $T00().op_Explicit(d4x4.Row3.MemberwiseClone());
  };

  function float4x4_Add (left, right) {
    return $S02().Construct((left.get_M11() + right.get_M11()), (left.get_M12() + right.get_M12()), (left.get_M13() + right.get_M13()), (left.get_M14() + right.get_M14()), (left.get_M21() + right.get_M21()), (left.get_M22() + right.get_M22()), (left.get_M23() + right.get_M23()), (left.get_M24() + right.get_M24()), (left.get_M31() + right.get_M31()), (left.get_M32() + right.get_M32()), (left.get_M33() + right.get_M33()), (left.get_M34() + right.get_M34()), (left.get_M41() + right.get_M41()), (left.get_M42() + right.get_M42()), (left.get_M43() + right.get_M43()), (left.get_M44() + right.get_M44()));
  };

  function float4x4_CreateFromAxisAngle$03 (axis, angle, /* ref */ result) {
    var cos = +$T01().$Cast(Math.cos(-angle));
    var sin = +$T01().$Cast(Math.sin(-angle));
    var t = +(1 - cos);
    axis.Normalize();
    result.set($S02().Construct((((t * axis.x) * axis.x) + cos), (((t * axis.x) * axis.y) + (sin * axis.z)), (((t * axis.x) * axis.z) - (sin * axis.y)), 0, (((t * axis.x) * axis.y) - (sin * axis.z)), (((t * axis.y) * axis.y) + cos), (((t * axis.y) * axis.z) + (sin * axis.x)), 0, (((t * axis.x) * axis.z) + (sin * axis.y)), (((t * axis.y) * axis.z) - (sin * axis.x)), (((t * axis.z) * axis.z) + cos), 0, 0, 0, 0, 1));
  };

  function float4x4_CreateFromAxisAngle$04 (axis, angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateFromAxisAngle(axis, angle, /* ref */ result);
    return result.get();
  };

  function float4x4_CreateOrthographic$05 (width, height, zNear, zFar, /* ref */ result) {
    $thisType.CreateOrthographicOffCenter(
      (-width / 2), 
      (width / 2), 
      (-height / 2), 
      (height / 2), 
      zNear, 
      zFar, 
      /* ref */ result
    );
  };

  function float4x4_CreateOrthographic$06 (width, height, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateOrthographicOffCenter(
      (-width / 2), 
      (width / 2), 
      (-height / 2), 
      (height / 2), 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  };

  function float4x4_CreateOrthographicOffCenter$07 (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    result.set(new $thisType());
    var invRL = +(1 / (right - left));
    var invTB = +(1 / (top - bottom));
    var invFN = +(1 / (zFar - zNear));
    result.get().set_M11((2 * invRL));
    result.get().set_M22((2 * invTB));
    result.get().set_M33((2 * invFN));
    result.get().set_M14((-(right + left) * invRL));
    result.get().set_M24((-(top + bottom) * invTB));
    result.get().set_M34((-(zFar + zNear) * invFN));
    result.get().set_M44(1);
  };

  function float4x4_CreateOrthographicOffCenter$08 (left, right, bottom, top, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateOrthographicOffCenter(
      left, 
      right, 
      bottom, 
      top, 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  };

  function float4x4_CreateOrthographicOffCenterRH (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    result.set(new $thisType());
    var invRL = +(1 / (right - left));
    var invTB = +(1 / (top - bottom));
    var invFN = +(1 / (zFar - zNear));
    result.get().set_M11((2 * invRL));
    result.get().set_M22((2 * invTB));
    result.get().set_M33((-2 * invFN));
    result.get().set_M14((-(right + left) * invRL));
    result.get().set_M24((-(top + bottom) * invTB));
    result.get().set_M34((-(zFar + zNear) * invFN));
    result.get().set_M44(1);
  };

  function float4x4_CreatePerspectiveFieldOfView$09 (fovy, aspect, zNear, zFar, /* ref */ result) {
    if (!((fovy > 0) && (fovy <= 3.1415926535897931))) {
      throw $S03().Construct("fovy");
    }
    if (aspect <= 0) {
      throw $S03().Construct("aspect");
    }
    if (zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    if (zFar <= 0) {
      throw $S03().Construct("zFar");
    }
    if (zNear >= zFar) {
      throw $S03().Construct("zNear");
    }
    var yMax = +(zNear * $T01().$Cast(Math.tan((0.5 * fovy))));
    var yMin = +-yMax;
    $thisType.CreatePerspectiveOffCenter(
      (yMin * aspect), 
      (yMax * aspect), 
      yMin, 
      yMax, 
      zNear, 
      zFar, 
      /* ref */ result
    );
  };

  function float4x4_CreatePerspectiveFieldOfView$0A (fovy, aspect, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreatePerspectiveFieldOfView(
      fovy, 
      aspect, 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  };

  function float4x4_CreatePerspectiveFieldOfView_ROW$0B (fovy, aspect, zNear, zFar, /* ref */ result) {
    if (!((fovy > 0) && (fovy <= 3.1415926535897931))) {
      throw $S03().Construct("fovy");
    }
    if (aspect <= 0) {
      throw $S03().Construct("aspect");
    }
    if (zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    if (zFar <= 0) {
      throw $S03().Construct("zFar");
    }
    if (zNear >= zFar) {
      throw $S03().Construct("zNear");
    }
    var yMax = +(zNear * $T01().$Cast(Math.tan((0.5 * fovy))));
    var yMin = +-yMax;
    $thisType.CreatePerspectiveOffCenter_ROW(
      (yMin * aspect), 
      (yMax * aspect), 
      yMin, 
      yMax, 
      zNear, 
      zFar, 
      /* ref */ result
    );
  };

  function float4x4_CreatePerspectiveFieldOfView_ROW$0C (fovy, aspect, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreatePerspectiveFieldOfView_ROW(
      fovy, 
      aspect, 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  };

  function float4x4_CreatePerspectiveOffCenter$0D (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    if (zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    if (zFar <= 0) {
      throw $S03().Construct("zFar");
    }
    if (zNear >= zFar) {
      throw $S03().Construct("zNear");
    }
    result.set($S02().Construct(((2 * zNear) / (right - left)), 0, ((left + right) / (left - right)), 0, 0, ((2 * zNear) / (top - bottom)), ((top + bottom) / (bottom - top)), 0, 0, 0, ((zFar + zNear) / (zFar - zNear)), (-((2 * zFar) * zNear) / (zFar - zNear)), 0, 0, 1, 0));
  };

  function float4x4_CreatePerspectiveOffCenter$0E (left, right, bottom, top, zNear, zFar) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreatePerspectiveOffCenter(
      left, 
      right, 
      bottom, 
      top, 
      zNear, 
      zFar, 
      /* ref */ result
    );
    return result.get();
  };

  function float4x4_CreatePerspectiveOffCenter_ROW (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    if (zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    if (zFar <= 0) {
      throw $S03().Construct("zFar");
    }
    if (zNear >= zFar) {
      throw $S03().Construct("zNear");
    }
    result.set($S02().Construct(((2 * zNear) / (right - left)), 0, 0, 0, 0, ((2 * zNear) / (top - bottom)), 0, 0, ((left + right) / (left - right)), ((top + bottom) / (bottom - top)), ((zFar + zNear) / (zFar - zNear)), 1, 0, 0, (-((2 * zFar) * zNear) / (zFar - zNear)), 0));
  };

  function float4x4_CreatePerspectiveOffCenterRH (left, right, bottom, top, zNear, zFar, /* ref */ result) {
    if (zNear <= 0) {
      throw $S03().Construct("zNear");
    }
    if (zFar <= 0) {
      throw $S03().Construct("zFar");
    }
    if (zNear >= zFar) {
      throw $S03().Construct("zNear");
    }
    result.set($S02().Construct(((2 * zNear) / (right - left)), 0, ((right + left) / (right - left)), 0, 0, ((2 * zNear) / (top - bottom)), ((top + bottom) / (top - bottom)), 0, 0, 0, (-(zFar + zNear) / (zFar - zNear)), (-((2 * zFar) * zNear) / (zFar - zNear)), 0, 0, -1, 0));
  };

  function float4x4_CreateRotationX$0F (angle, /* ref */ result) {
    var cos = +$T01().$Cast(Math.cos(angle));
    var sin = +$T01().$Cast(Math.sin(angle));
    result.get().Row0 = $T00().UnitX.MemberwiseClone();
    result.get().Row1 = $S01().Construct(0, cos, -sin, 0);
    result.get().Row2 = $S01().Construct(0, sin, cos, 0);
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  };

  function float4x4_CreateRotationX$10 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationX(angle, /* ref */ result);
    return result.get();
  };

  function float4x4_CreateRotationX_ROW$11 (angle, /* ref */ result) {
    var cos = +$T01().$Cast(Math.cos(angle));
    var sin = +$T01().$Cast(Math.sin(angle));
    result.get().Row0 = $T00().UnitX.MemberwiseClone();
    result.get().Row1 = $S01().Construct(0, cos, sin, 0);
    result.get().Row2 = $S01().Construct(0, -sin, cos, 0);
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  };

  function float4x4_CreateRotationX_ROW$12 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationX_ROW(angle, /* ref */ result);
    return result.get();
  };

  function float4x4_CreateRotationY$13 (angle, /* ref */ result) {
    var cos = +$T01().$Cast(Math.cos(angle));
    var sin = +$T01().$Cast(Math.sin(angle));
    result.get().Row0 = $S01().Construct(cos, 0, sin, 0);
    result.get().Row1 = $T00().UnitY.MemberwiseClone();
    result.get().Row2 = $S01().Construct(-sin, 0, cos, 0);
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  };

  function float4x4_CreateRotationY$14 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationY(angle, /* ref */ result);
    return result.get();
  };

  function float4x4_CreateRotationY_ROW$15 (angle, /* ref */ result) {
    var cos = +$T01().$Cast(Math.cos(angle));
    var sin = +$T01().$Cast(Math.sin(angle));
    result.get().Row0 = $S01().Construct(cos, 0, -sin, 0);
    result.get().Row1 = $T00().UnitY.MemberwiseClone();
    result.get().Row2 = $S01().Construct(sin, 0, cos, 0);
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  };

  function float4x4_CreateRotationY_ROW$16 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationY_ROW(angle, /* ref */ result);
    return result.get();
  };

  function float4x4_CreateRotationZ$17 (angle, /* ref */ result) {
    var cos = +$T01().$Cast(Math.cos(angle));
    var sin = +$T01().$Cast(Math.sin(angle));
    result.get().Row0 = $S01().Construct(cos, -sin, 0, 0);
    result.get().Row1 = $S01().Construct(sin, cos, 0, 0);
    result.get().Row2 = $T00().UnitZ.MemberwiseClone();
    result.get().Row3 = $T00().UnitW.MemberwiseClone();
  };

  function float4x4_CreateRotationZ$18 (angle) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateRotationZ(angle, /* ref */ result);
    return result.get();
  };

  function float4x4_CreateScale$19 (scale, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    result.get().set_M11(scale);
    result.get().set_M22(scale);
    result.get().set_M33(scale);
  };

  function float4x4_CreateScale$1A (scale) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $S04().CallStatic($thisType, "CreateScale", null, scale, /* ref */ result);
    return result.get();
  };

  function float4x4_CreateScale$1B (x, y, z, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    result.get().set_M11(x);
    result.get().set_M22(y);
    result.get().set_M33(z);
  };

  function float4x4_CreateScale$1C (/* ref */ vector, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    result.get().set_M11(vector.get().x);
    result.get().set_M22(vector.get().y);
    result.get().set_M33(vector.get().z);
  };

  function float4x4_CreateScale$1D (x, y, z) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateScale(x, y, z, /* ref */ result);
    return result.get();
  };

  function float4x4_CreateScale$1E (vector) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateScale(vector.x, vector.y, vector.z, /* ref */ result);
    return result.get();
  };

  function float4x4_CreateTranslation$1F (x, y, z, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    result.get().set_M14(x);
    result.get().set_M24(y);
    result.get().set_M34(z);
  };

  function float4x4_CreateTranslation$20 (/* ref */ vector, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    result.get().set_M14(vector.get().x);
    result.get().set_M24(vector.get().y);
    result.get().set_M34(vector.get().z);
  };

  function float4x4_CreateTranslation$21 (x, y, z) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateTranslation(x, y, z, /* ref */ result);
    return result.get();
  };

  function float4x4_CreateTranslation$22 (vector) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateTranslation(vector.x, vector.y, vector.z, /* ref */ result);
    return result.get();
  };

  function float4x4_CreateTranslation_ROW$23 (x, y, z, /* ref */ result) {
    result.set($thisType.Identity.MemberwiseClone());
    result.get().Row3 = $S01().Construct(x, y, z, 1);
  };

  function float4x4_CreateTranslation_ROW$24 (x, y, z) {
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.CreateTranslation_ROW(x, y, z, /* ref */ result);
    return result.get();
  };

  function float4x4_Object_Equals (obj) {
    return ($thisType.$Is(obj) && this.Equals($thisType.$Cast(obj).MemberwiseClone()));
  };

  function float4x4_Equals$25 (other) {
    return (!(!$T00().op_Equality(this.Row0.MemberwiseClone(), other.Row0.MemberwiseClone()) || 
        !$T00().op_Equality(this.Row1.MemberwiseClone(), other.Row1.MemberwiseClone()) || 
        !$T00().op_Equality(this.Row2.MemberwiseClone(), other.Row2.MemberwiseClone())) && $T00().op_Equality(this.Row3.MemberwiseClone(), other.Row3.MemberwiseClone()));
  };

  function float4x4_get_Column0 () {
    return $S01().Construct(this.Row0.x, this.Row1.x, this.Row2.x, this.Row3.x);
  };

  function float4x4_get_Column1 () {
    return $S01().Construct(this.Row0.y, this.Row1.y, this.Row2.y, this.Row3.y);
  };

  function float4x4_get_Column2 () {
    return $S01().Construct(this.Row0.z, this.Row1.z, this.Row2.z, this.Row3.z);
  };

  function float4x4_get_Column3 () {
    return $S01().Construct(this.Row0.w, this.Row1.w, this.Row2.w, this.Row3.w);
  };

  function float4x4_get_Determinant () {
    return +((((((((((((((((((((((((((this.Row0.x * this.Row1.y) * this.Row2.z) * this.Row3.w) - (((this.Row0.x * this.Row1.y) * this.Row2.w) * this.Row3.z)) + (((this.Row0.x * this.Row1.z) * this.Row2.w) * this.Row3.y)) - (((this.Row0.x * this.Row1.z) * this.Row2.y) * this.Row3.w)) + (((this.Row0.x * this.Row1.w) * this.Row2.y) * this.Row3.z)) - (((this.Row0.x * this.Row1.w) * this.Row2.z) * this.Row3.y)) - (((this.Row0.y * this.Row1.z) * this.Row2.w) * this.Row3.x)) + (((this.Row0.y * this.Row1.z) * this.Row2.x) * this.Row3.w)) - (((this.Row0.y * this.Row1.w) * this.Row2.x) * this.Row3.z)) + (((this.Row0.y * this.Row1.w) * this.Row2.z) * this.Row3.x)) - (((this.Row0.y * this.Row1.x) * this.Row2.z) * this.Row3.w)) + (((this.Row0.y * this.Row1.x) * this.Row2.w) * this.Row3.z)) + (((this.Row0.z * this.Row1.w) * this.Row2.x) * this.Row3.y)) - (((this.Row0.z * this.Row1.w) * this.Row2.y) * this.Row3.x)) + (((this.Row0.z * this.Row1.x) * this.Row2.y) * this.Row3.w)) - (((this.Row0.z * this.Row1.x) * this.Row2.w) * this.Row3.y)) + (((this.Row0.z * this.Row1.y) * this.Row2.w) * this.Row3.x)) - (((this.Row0.z * this.Row1.y) * this.Row2.x) * this.Row3.w)) - (((this.Row0.w * this.Row1.x) * this.Row2.y) * this.Row3.z)) + (((this.Row0.w * this.Row1.x) * this.Row2.z) * this.Row3.y)) - (((this.Row0.w * this.Row1.y) * this.Row2.z) * this.Row3.x)) + (((this.Row0.w * this.Row1.y) * this.Row2.x) * this.Row3.z)) - (((this.Row0.w * this.Row1.z) * this.Row2.x) * this.Row3.y)) + (((this.Row0.w * this.Row1.z) * this.Row2.y) * this.Row3.x));
  };

  function float4x4_get_IsAffine () {
    return $T00().op_Equality(this.Row3.MemberwiseClone(), $T00().UnitW.MemberwiseClone());
  };

  function float4x4_get_M11 () {
    return +this.Row0.x;
  };

  function float4x4_get_M12 () {
    return +this.Row0.y;
  };

  function float4x4_get_M13 () {
    return +this.Row0.z;
  };

  function float4x4_get_M14 () {
    return +this.Row0.w;
  };

  function float4x4_get_M21 () {
    return +this.Row1.x;
  };

  function float4x4_get_M22 () {
    return +this.Row1.y;
  };

  function float4x4_get_M23 () {
    return +this.Row1.z;
  };

  function float4x4_get_M24 () {
    return +this.Row1.w;
  };

  function float4x4_get_M31 () {
    return +this.Row2.x;
  };

  function float4x4_get_M32 () {
    return +this.Row2.y;
  };

  function float4x4_get_M33 () {
    return +this.Row2.z;
  };

  function float4x4_get_M34 () {
    return +this.Row2.w;
  };

  function float4x4_get_M41 () {
    return +this.Row3.x;
  };

  function float4x4_get_M42 () {
    return +this.Row3.y;
  };

  function float4x4_get_M43 () {
    return +this.Row3.z;
  };

  function float4x4_get_M44 () {
    return +this.Row3.w;
  };

  function float4x4_get_Offset () {
    return $S05().Construct(this.Row0.w, this.Row1.w, this.Row2.w);
  };

  function float4x4_get_Parse () {
    return $thisType.float4x4$Parse$value;
  };

  function float4x4_GetHashCode () {
    return (((this.Row0.GetHashCode() ^ this.Row1.GetHashCode()) ^ this.Row2.GetHashCode()) ^ this.Row3.GetHashCode());
  };

  function float4x4_Invert$26 () {
    JSIL.CopyMembers($thisType.Invert(this.MemberwiseClone()).MemberwiseClone(), this);
  };

  function float4x4_Invert$27 (mat) {
    if (!(!$thisType.op_Equality(mat.MemberwiseClone(), $thisType.Identity.MemberwiseClone()) && !$thisType.op_Equality(mat.MemberwiseClone(), $thisType.Zero.MemberwiseClone()))) {
      var result = mat.MemberwiseClone();
    } else {
      mat.Transpose();
      var tmp0 = +(mat.get_M33() * mat.get_M44());
      var tmp = +(mat.get_M34() * mat.get_M43());
      var tmp2 = +(mat.get_M32() * mat.get_M44());
      var tmp3 = +(mat.get_M34() * mat.get_M42());
      var tmp4 = +(mat.get_M32() * mat.get_M43());
      var tmp5 = +(mat.get_M33() * mat.get_M42());
      var tmp6 = +(mat.get_M31() * mat.get_M44());
      var tmp7 = +(mat.get_M34() * mat.get_M41());
      var tmp8 = +(mat.get_M31() * mat.get_M43());
      var tmp9 = +(mat.get_M33() * mat.get_M41());
      var tmp10 = +(mat.get_M31() * mat.get_M42());
      var tmp11 = +(mat.get_M32() * mat.get_M41());
      var m11 = +(((tmp0 * mat.get_M22()) + (tmp3 * mat.get_M23())) + (tmp4 * mat.get_M24()));
      m11 -= +(((tmp * mat.get_M22()) + (tmp2 * mat.get_M23())) + (tmp5 * mat.get_M24()));
      var m12 = +(((tmp * mat.get_M21()) + (tmp6 * mat.get_M23())) + (tmp9 * mat.get_M24()));
      m12 -= +(((tmp0 * mat.get_M21()) + (tmp7 * mat.get_M23())) + (tmp8 * mat.get_M24()));
      var m13 = +(((tmp2 * mat.get_M21()) + (tmp7 * mat.get_M22())) + (tmp10 * mat.get_M24()));
      m13 -= +(((tmp3 * mat.get_M21()) + (tmp6 * mat.get_M22())) + (tmp11 * mat.get_M24()));
      var m14 = +(((tmp5 * mat.get_M21()) + (tmp8 * mat.get_M22())) + (tmp11 * mat.get_M23()));
      m14 -= +(((tmp4 * mat.get_M21()) + (tmp9 * mat.get_M22())) + (tmp10 * mat.get_M23()));
      var m15 = +(((tmp * mat.get_M12()) + (tmp2 * mat.get_M13())) + (tmp5 * mat.get_M14()));
      m15 -= +(((tmp0 * mat.get_M12()) + (tmp3 * mat.get_M13())) + (tmp4 * mat.get_M14()));
      var m16 = +(((tmp0 * mat.get_M11()) + (tmp7 * mat.get_M13())) + (tmp8 * mat.get_M14()));
      m16 -= +(((tmp * mat.get_M11()) + (tmp6 * mat.get_M13())) + (tmp9 * mat.get_M14()));
      var m17 = +(((tmp3 * mat.get_M11()) + (tmp6 * mat.get_M12())) + (tmp11 * mat.get_M14()));
      m17 -= +(((tmp2 * mat.get_M11()) + (tmp7 * mat.get_M12())) + (tmp10 * mat.get_M14()));
      var m18 = +(((tmp4 * mat.get_M11()) + (tmp9 * mat.get_M12())) + (tmp10 * mat.get_M13()));
      m18 -= +(((tmp5 * mat.get_M11()) + (tmp8 * mat.get_M12())) + (tmp11 * mat.get_M13()));
      tmp0 = +(mat.get_M13() * mat.get_M24());
      tmp = +(mat.get_M14() * mat.get_M23());
      tmp2 = +(mat.get_M12() * mat.get_M24());
      tmp3 = +(mat.get_M14() * mat.get_M22());
      tmp4 = +(mat.get_M12() * mat.get_M23());
      tmp5 = +(mat.get_M13() * mat.get_M22());
      tmp6 = +(mat.get_M11() * mat.get_M24());
      tmp7 = +(mat.get_M14() * mat.get_M21());
      tmp8 = +(mat.get_M11() * mat.get_M23());
      tmp9 = +(mat.get_M13() * mat.get_M21());
      tmp10 = +(mat.get_M11() * mat.get_M22());
      tmp11 = +(mat.get_M12() * mat.get_M21());
      var m19 = +(((tmp0 * mat.get_M42()) + (tmp3 * mat.get_M43())) + (tmp4 * mat.get_M44()));
      m19 -= +(((tmp * mat.get_M42()) + (tmp2 * mat.get_M43())) + (tmp5 * mat.get_M44()));
      var m20 = +(((tmp * mat.get_M41()) + (tmp6 * mat.get_M43())) + (tmp9 * mat.get_M44()));
      m20 -= +(((tmp0 * mat.get_M41()) + (tmp7 * mat.get_M43())) + (tmp8 * mat.get_M44()));
      var m21 = +(((tmp2 * mat.get_M41()) + (tmp7 * mat.get_M42())) + (tmp10 * mat.get_M44()));
      m21 -= +(((tmp3 * mat.get_M41()) + (tmp6 * mat.get_M42())) + (tmp11 * mat.get_M44()));
      var m22 = +(((tmp5 * mat.get_M41()) + (tmp8 * mat.get_M42())) + (tmp11 * mat.get_M43()));
      m22 -= +(((tmp4 * mat.get_M41()) + (tmp9 * mat.get_M42())) + (tmp10 * mat.get_M43()));
      var m23 = +(((tmp2 * mat.get_M33()) + (tmp5 * mat.get_M34())) + (tmp * mat.get_M32()));
      m23 -= +(((tmp4 * mat.get_M34()) + (tmp0 * mat.get_M32())) + (tmp3 * mat.get_M33()));
      var m24 = +(((tmp8 * mat.get_M34()) + (tmp0 * mat.get_M31())) + (tmp7 * mat.get_M33()));
      m24 -= +(((tmp6 * mat.get_M33()) + (tmp9 * mat.get_M34())) + (tmp * mat.get_M31()));
      var m25 = +(((tmp6 * mat.get_M32()) + (tmp11 * mat.get_M34())) + (tmp3 * mat.get_M31()));
      m25 -= +(((tmp10 * mat.get_M34()) + (tmp2 * mat.get_M31())) + (tmp7 * mat.get_M32()));
      var m26 = +(((tmp10 * mat.get_M33()) + (tmp4 * mat.get_M31())) + (tmp9 * mat.get_M32()));
      m26 -= +(((tmp8 * mat.get_M32()) + (tmp11 * mat.get_M33())) + (tmp5 * mat.get_M31()));
      var det = +((((mat.get_M11() * m11) + (mat.get_M12() * m12)) + (mat.get_M13() * m13)) + (mat.get_M14() * m14));
      if (!((det <= 1.192093E-07) && (det >= -1.192093E-07))) {
        det = +(1 / det);
        $thisType.prototype._ctor.call(mat, 
          (det * m11), 
          (det * m12), 
          (det * m13), 
          (det * m14), 
          (det * m15), 
          (det * m16), 
          (det * m17), 
          (det * m18), 
          (det * m19), 
          (det * m20), 
          (det * m21), 
          (det * m22), 
          (det * m23), 
          (det * m24), 
          (det * m25), 
          (det * m26)
        );
      } else {
        mat.Transpose();
      }
      result = mat.MemberwiseClone();
    }
    return result;
  };

  function float4x4_InvertAffine (mat) {
    throw $S06().Construct("InvertAffine is broken (probably since column order notation)");
  };

  function float4x4_LookAt$28 (eye, target, up) {
    var z = $T03().Normalize($T03().op_Subtraction(target, eye.MemberwiseClone()));
    var x = $T03().Normalize($T03().Cross(up, z.MemberwiseClone()).MemberwiseClone());
    var y = $T03().Cross(z.MemberwiseClone(), x.MemberwiseClone());
    return $S02().Construct(x.x, x.y, x.z, -$T03().Dot(x, eye), y.x, y.y, y.z, -$T03().Dot(y, eye), z.x, z.y, z.z, -$T03().Dot(z, eye), 0, 0, 0, 1);
  };

  function float4x4_LookAt$29 (eyeX, eyeY, eyeZ, targetX, targetY, targetZ, upX, upY, upZ) {
    return $thisType.LookAt($S05().Construct(eyeX, eyeY, eyeZ), $S05().Construct(targetX, targetY, targetZ), $S05().Construct(upX, upY, upZ));
  };

  function float4x4_LookAt_ROW$2A (eye, target, up) {
    var z = $T03().Normalize($T03().op_Subtraction(target, eye.MemberwiseClone()));
    var x = $T03().Normalize($T03().Cross(up, z.MemberwiseClone()).MemberwiseClone());
    var y = $T03().Cross(z.MemberwiseClone(), x.MemberwiseClone());
    return $S00().Construct($S01().Construct(x.x, y.x, z.x, 0), $S01().Construct(x.y, y.y, z.y, 0), $S01().Construct(x.z, y.z, z.z, 0), $S01().Construct(-$T03().Dot(x, eye), -$T03().Dot(y, eye), -$T03().Dot(z, eye), 1));
  };

  function float4x4_LookAt_ROW$2B (eyeX, eyeY, eyeZ, targetX, targetY, targetZ, upX, upY, upZ) {
    return $thisType.LookAt_ROW($S05().Construct(eyeX, eyeY, eyeZ), $S05().Construct(targetX, targetY, targetZ), $S05().Construct(upX, upY, upZ));
  };

  function float4x4_LookAtRH (eye, target, up) {
    var z = $T03().Normalize($T03().op_Subtraction(eye.MemberwiseClone(), target).MemberwiseClone());
    var x = $T03().Normalize($T03().Cross(up, z.MemberwiseClone()).MemberwiseClone());
    var y = $T03().Cross(z.MemberwiseClone(), x.MemberwiseClone());
    return $S02().Construct(x.x, x.y, x.z, -$T03().Dot(x, eye), y.x, y.y, y.z, -$T03().Dot(y, eye), z.x, z.y, z.z, -$T03().Dot(z, eye), 0, 0, 0, 1);
  };

  function float4x4_Mult$2C ($left, $right) {
    var right = new JSIL.BoxedVariable($right);
    var left = new JSIL.BoxedVariable($left);
    var result = new JSIL.BoxedVariable(new $thisType());
    if ($thisType.op_Equality(left.get().MemberwiseClone(), $thisType.Identity.MemberwiseClone())) {
      var result2 = right.get().MemberwiseClone();
    } else if ($thisType.op_Equality(right.get().MemberwiseClone(), $thisType.Identity.MemberwiseClone())) {
      result2 = left.get().MemberwiseClone();
    } else if (!(!$thisType.op_Equality(left.get().MemberwiseClone(), $thisType.Zero.MemberwiseClone()) && !$thisType.op_Equality(right.get().MemberwiseClone(), $thisType.Zero.MemberwiseClone()))) {
      result2 = $thisType.Zero.MemberwiseClone();
    } else {
      if (!(!left.get().get_IsAffine() || !right.get().get_IsAffine())) {
        $thisType.MultAffine(/* ref */ left, /* ref */ right, /* ref */ result);
      } else {
        $thisType.Mult(/* ref */ left, /* ref */ right, /* ref */ result);
      }
      result2 = result.get().MemberwiseClone();
    }
    return result2;
  };

  function float4x4_Mult$2D (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct(((((left.get().get_M11() * right.get().get_M11()) + (left.get().get_M12() * right.get().get_M21())) + (left.get().get_M13() * right.get().get_M31())) + (left.get().get_M14() * right.get().get_M41())), ((((left.get().get_M11() * right.get().get_M12()) + (left.get().get_M12() * right.get().get_M22())) + (left.get().get_M13() * right.get().get_M32())) + (left.get().get_M14() * right.get().get_M42())), ((((left.get().get_M11() * right.get().get_M13()) + (left.get().get_M12() * right.get().get_M23())) + (left.get().get_M13() * right.get().get_M33())) + (left.get().get_M14() * right.get().get_M43())), ((((left.get().get_M11() * right.get().get_M14()) + (left.get().get_M12() * right.get().get_M24())) + (left.get().get_M13() * right.get().get_M34())) + (left.get().get_M14() * right.get().get_M44())), ((((left.get().get_M21() * right.get().get_M11()) + (left.get().get_M22() * right.get().get_M21())) + (left.get().get_M23() * right.get().get_M31())) + (left.get().get_M24() * right.get().get_M41())), ((((left.get().get_M21() * right.get().get_M12()) + (left.get().get_M22() * right.get().get_M22())) + (left.get().get_M23() * right.get().get_M32())) + (left.get().get_M24() * right.get().get_M42())), ((((left.get().get_M21() * right.get().get_M13()) + (left.get().get_M22() * right.get().get_M23())) + (left.get().get_M23() * right.get().get_M33())) + (left.get().get_M24() * right.get().get_M43())), ((((left.get().get_M21() * right.get().get_M14()) + (left.get().get_M22() * right.get().get_M24())) + (left.get().get_M23() * right.get().get_M34())) + (left.get().get_M24() * right.get().get_M44())), ((((left.get().get_M31() * right.get().get_M11()) + (left.get().get_M32() * right.get().get_M21())) + (left.get().get_M33() * right.get().get_M31())) + (left.get().get_M34() * right.get().get_M41())), ((((left.get().get_M31() * right.get().get_M12()) + (left.get().get_M32() * right.get().get_M22())) + (left.get().get_M33() * right.get().get_M32())) + (left.get().get_M34() * right.get().get_M42())), ((((left.get().get_M31() * right.get().get_M13()) + (left.get().get_M32() * right.get().get_M23())) + (left.get().get_M33() * right.get().get_M33())) + (left.get().get_M34() * right.get().get_M43())), ((((left.get().get_M31() * right.get().get_M14()) + (left.get().get_M32() * right.get().get_M24())) + (left.get().get_M33() * right.get().get_M34())) + (left.get().get_M34() * right.get().get_M44())), ((((left.get().get_M41() * right.get().get_M11()) + (left.get().get_M42() * right.get().get_M21())) + (left.get().get_M43() * right.get().get_M31())) + (left.get().get_M44() * right.get().get_M41())), ((((left.get().get_M41() * right.get().get_M12()) + (left.get().get_M42() * right.get().get_M22())) + (left.get().get_M43() * right.get().get_M32())) + (left.get().get_M44() * right.get().get_M42())), ((((left.get().get_M41() * right.get().get_M13()) + (left.get().get_M42() * right.get().get_M23())) + (left.get().get_M43() * right.get().get_M33())) + (left.get().get_M44() * right.get().get_M43())), ((((left.get().get_M41() * right.get().get_M14()) + (left.get().get_M42() * right.get().get_M24())) + (left.get().get_M43() * right.get().get_M34())) + (left.get().get_M44() * right.get().get_M44()))));
  };

  function float4x4_MultAffine (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct((((left.get().get_M11() * right.get().get_M11()) + (left.get().get_M12() * right.get().get_M21())) + (left.get().get_M13() * right.get().get_M31())), (((left.get().get_M11() * right.get().get_M12()) + (left.get().get_M12() * right.get().get_M22())) + (left.get().get_M13() * right.get().get_M32())), (((left.get().get_M11() * right.get().get_M13()) + (left.get().get_M12() * right.get().get_M23())) + (left.get().get_M13() * right.get().get_M33())), ((((left.get().get_M11() * right.get().get_M14()) + (left.get().get_M12() * right.get().get_M24())) + (left.get().get_M13() * right.get().get_M34())) + left.get().get_M14()), (((left.get().get_M21() * right.get().get_M11()) + (left.get().get_M22() * right.get().get_M21())) + (left.get().get_M23() * right.get().get_M31())), (((left.get().get_M21() * right.get().get_M12()) + (left.get().get_M22() * right.get().get_M22())) + (left.get().get_M23() * right.get().get_M32())), (((left.get().get_M21() * right.get().get_M13()) + (left.get().get_M22() * right.get().get_M23())) + (left.get().get_M23() * right.get().get_M33())), ((((left.get().get_M21() * right.get().get_M14()) + (left.get().get_M22() * right.get().get_M24())) + (left.get().get_M23() * right.get().get_M34())) + left.get().get_M24()), (((left.get().get_M31() * right.get().get_M11()) + (left.get().get_M32() * right.get().get_M21())) + (left.get().get_M33() * right.get().get_M31())), (((left.get().get_M31() * right.get().get_M12()) + (left.get().get_M32() * right.get().get_M22())) + (left.get().get_M33() * right.get().get_M32())), (((left.get().get_M31() * right.get().get_M13()) + (left.get().get_M32() * right.get().get_M23())) + (left.get().get_M33() * right.get().get_M33())), ((((left.get().get_M31() * right.get().get_M14()) + (left.get().get_M32() * right.get().get_M24())) + (left.get().get_M33() * right.get().get_M34())) + left.get().get_M34()), 0, 0, 0, 1));
  };

  function float4x4_op_Addition (left, right) {
    return $thisType.Add(left, right);
  };

  function float4x4_op_Equality (left, right) {
    return left.Equals(right);
  };

  function float4x4_op_Explicit (d4x4) {
    return $S07().Construct(d4x4);
  };

  function float4x4_op_Inequality (left, right) {
    return !left.Equals(right);
  };

  function float4x4_op_Multiply$2E (left, right) {
    return $thisType.Mult(left, right);
  };

  function float4x4_op_Multiply$2F (matrix, vector) {
    return $thisType.Transform(matrix, vector);
  };

  function float4x4_op_Multiply$30 (vector, matrix) {
    return $thisType.TransformPremult(vector, matrix);
  };

  function float4x4_op_Multiply$31 (matrix, vector) {
    return $thisType.TransformPD(matrix, vector);
  };

  function float4x4_op_Multiply$32 (vector, matrix) {
    return $thisType.TransformPremultPD(vector, matrix);
  };

  function float4x4_op_Subtraction (left, right) {
    return $thisType.Substract(left, right);
  };

  function float4x4_Round$33 () {
    this.Row0.Round();
    this.Row1.Round();
    this.Row2.Round();
    this.Row3.Round();
  };

  function float4x4_Round$34 (mat) {
    return $S00().Construct($T00().Round(mat.Row0.MemberwiseClone()), $T00().Round(mat.Row1.MemberwiseClone()), $T00().Round(mat.Row2.MemberwiseClone()), $T00().Round(mat.Row3.MemberwiseClone()));
  };

  function float4x4_Scale$35 (scale) {
    return $thisType.Scale(scale, scale, scale);
  };

  function float4x4_Scale$36 (scale) {
    return $thisType.Scale(scale.x, scale.y, scale.z);
  };

  function float4x4_Scale$37 (x, y, z) {
    var result = new $thisType();
    result.Row0 = $S08().CallStatic($T00(), "op_Multiply", null, $T00().UnitX.MemberwiseClone(), x).MemberwiseClone();
    result.Row1 = $S08().CallStatic($T00(), "op_Multiply", null, $T00().UnitY.MemberwiseClone(), y).MemberwiseClone();
    result.Row2 = $S08().CallStatic($T00(), "op_Multiply", null, $T00().UnitZ.MemberwiseClone(), z).MemberwiseClone();
    result.Row3 = $T00().UnitW.MemberwiseClone();
    return result;
  };

  function float4x4_set_M11 (value) {
    this.Row0.x = +value;
  };

  function float4x4_set_M12 (value) {
    this.Row0.y = +value;
  };

  function float4x4_set_M13 (value) {
    this.Row0.z = +value;
  };

  function float4x4_set_M14 (value) {
    this.Row0.w = +value;
  };

  function float4x4_set_M21 (value) {
    this.Row1.x = +value;
  };

  function float4x4_set_M22 (value) {
    this.Row1.y = +value;
  };

  function float4x4_set_M23 (value) {
    this.Row1.z = +value;
  };

  function float4x4_set_M24 (value) {
    this.Row1.w = +value;
  };

  function float4x4_set_M31 (value) {
    this.Row2.x = +value;
  };

  function float4x4_set_M32 (value) {
    this.Row2.y = +value;
  };

  function float4x4_set_M33 (value) {
    this.Row2.z = +value;
  };

  function float4x4_set_M34 (value) {
    this.Row2.w = +value;
  };

  function float4x4_set_M41 (value) {
    this.Row3.x = +value;
  };

  function float4x4_set_M42 (value) {
    this.Row3.y = +value;
  };

  function float4x4_set_M43 (value) {
    this.Row3.z = +value;
  };

  function float4x4_set_M44 (value) {
    this.Row3.w = +value;
  };

  function float4x4_set_Parse (value) {
    $thisType.float4x4$Parse$value = value;
  };

  function float4x4_Substract (left, right) {
    return $S02().Construct((left.get_M11() - right.get_M11()), (left.get_M12() - right.get_M12()), (left.get_M13() - right.get_M13()), (left.get_M14() - right.get_M14()), (left.get_M21() - right.get_M21()), (left.get_M22() - right.get_M22()), (left.get_M23() - right.get_M23()), (left.get_M24() - right.get_M24()), (left.get_M31() - right.get_M31()), (left.get_M32() - right.get_M32()), (left.get_M33() - right.get_M33()), (left.get_M34() - right.get_M34()), (left.get_M41() - right.get_M41()), (left.get_M42() - right.get_M42()), (left.get_M43() - right.get_M43()), (left.get_M44() - right.get_M44()));
  };

  function float4x4_ToArray () {
    return JSIL.Array.New($T01(), [this.get_M11(), this.get_M12(), this.get_M13(), this.get_M14(), this.get_M21(), this.get_M22(), this.get_M23(), this.get_M24(), this.get_M31(), this.get_M32(), this.get_M33(), this.get_M34(), this.get_M41(), this.get_M42(), this.get_M43(), this.get_M44()]);
  };

  function float4x4_toString () {
    return $T0A().Format("{0}\n{1}\n{2}\n{3}", JSIL.Array.New($T07(), [this.Row0, this.Row1, this.Row2, this.Row3]));
  };

  function float4x4_Transform (matrix, vector) {
    return $S01().Construct(((((matrix.get_M11() * vector.x) + (matrix.get_M12() * vector.y)) + (matrix.get_M13() * vector.z)) + (matrix.get_M14() * vector.w)), ((((matrix.get_M21() * vector.x) + (matrix.get_M22() * vector.y)) + (matrix.get_M23() * vector.z)) + (matrix.get_M24() * vector.w)), ((((matrix.get_M31() * vector.x) + (matrix.get_M32() * vector.y)) + (matrix.get_M33() * vector.z)) + (matrix.get_M34() * vector.w)), ((((matrix.get_M41() * vector.x) + (matrix.get_M42() * vector.y)) + (matrix.get_M43() * vector.z)) + (matrix.get_M44() * vector.w)));
  };

  function float4x4_TransformPD (matrix, vector) {
    var w = +((((matrix.get_M41() * vector.x) + (matrix.get_M42() * vector.y)) + (matrix.get_M43() * vector.z)) + matrix.get_M44());
    return $S05().Construct((((((matrix.get_M11() * vector.x) + (matrix.get_M12() * vector.y)) + (matrix.get_M13() * vector.z)) + matrix.get_M14()) / w), (((((matrix.get_M21() * vector.x) + (matrix.get_M22() * vector.y)) + (matrix.get_M23() * vector.z)) + matrix.get_M24()) / w), (((((matrix.get_M31() * vector.x) + (matrix.get_M32() * vector.y)) + (matrix.get_M33() * vector.z)) + matrix.get_M34()) / w));
  };

  function float4x4_TransformPremult (vector, matrix) {
    return $S01().Construct(((((matrix.get_M11() * vector.x) + (matrix.get_M21() * vector.y)) + (matrix.get_M31() * vector.z)) + (matrix.get_M41() * vector.w)), ((((matrix.get_M12() * vector.x) + (matrix.get_M22() * vector.y)) + (matrix.get_M32() * vector.z)) + (matrix.get_M42() * vector.w)), ((((matrix.get_M13() * vector.x) + (matrix.get_M23() * vector.y)) + (matrix.get_M33() * vector.z)) + (matrix.get_M43() * vector.w)), ((((matrix.get_M14() * vector.x) + (matrix.get_M24() * vector.y)) + (matrix.get_M34() * vector.z)) + (matrix.get_M44() * vector.w)));
  };

  function float4x4_TransformPremultPD (vector, matrix) {
    var w = +((((matrix.get_M14() * vector.x) + (matrix.get_M24() * vector.y)) + (matrix.get_M34() * vector.z)) + matrix.get_M44());
    return $S05().Construct((((((matrix.get_M11() * vector.x) + (matrix.get_M21() * vector.y)) + (matrix.get_M31() * vector.z)) + matrix.get_M41()) / w), (((((matrix.get_M12() * vector.x) + (matrix.get_M22() * vector.y)) + (matrix.get_M32() * vector.z)) + matrix.get_M42()) / w), (((((matrix.get_M13() * vector.x) + (matrix.get_M23() * vector.y)) + (matrix.get_M33() * vector.z)) + matrix.get_M43()) / w));
  };

  function float4x4_Transpose$38 () {
    JSIL.CopyMembers($thisType.Transpose(this.MemberwiseClone()), this);
  };

  function float4x4_Transpose$39 (mat) {
    return $S00().Construct(mat.get_Column0().MemberwiseClone(), mat.get_Column1().MemberwiseClone(), mat.get_Column2().MemberwiseClone(), mat.get_Column3().MemberwiseClone());
  };

  function float4x4_Transpose$3A (/* ref */ mat, /* ref */ result) {
    result.get().Row0 = mat.get().get_Column0().MemberwiseClone();
    result.get().Row1 = mat.get().get_Column1().MemberwiseClone();
    result.get().Row2 = mat.get().get_Column2().MemberwiseClone();
    result.get().Row3 = mat.get().get_Column3().MemberwiseClone();
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.float4x4", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 16, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $asm04.TypeRef("Fusee.Math.float4"), $asm04.TypeRef("Fusee.Math.float4"), 
          $asm04.TypeRef("Fusee.Math.float4"), $asm04.TypeRef("Fusee.Math.float4")
        ], []), 
      float4x4__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single
        ], []), 
      float4x4__ctor$01
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.double4x4")], []), 
      float4x4__ctor$02
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float4x4_Add
    );

    $.Method({Static:true , Public:true }, "CreateFromAxisAngle", 
      new JSIL.MethodSignature(null, [
          $asm04.TypeRef("Fusee.Math.float3"), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4x4_CreateFromAxisAngle$03
    );

    $.Method({Static:true , Public:true }, "CreateFromAxisAngle", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.float3"), $.Single], []), 
      float4x4_CreateFromAxisAngle$04
    );

    $.Method({Static:true , Public:true }, "CreateOrthographic", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4x4_CreateOrthographic$05
    );

    $.Method({Static:true , Public:true }, "CreateOrthographic", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single, $.Single
        ], []), 
      float4x4_CreateOrthographic$06
    );

    $.Method({Static:true , Public:true }, "CreateOrthographicOffCenter", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4x4_CreateOrthographicOffCenter$07
    );

    $.Method({Static:true , Public:true }, "CreateOrthographicOffCenter", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single
        ], []), 
      float4x4_CreateOrthographicOffCenter$08
    );

    $.Method({Static:true , Public:true }, "CreateOrthographicOffCenterRH", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4x4_CreateOrthographicOffCenterRH
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveFieldOfView", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4x4_CreatePerspectiveFieldOfView$09
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveFieldOfView", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single, $.Single
        ], []), 
      float4x4_CreatePerspectiveFieldOfView$0A
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveFieldOfView_ROW", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4x4_CreatePerspectiveFieldOfView_ROW$0B
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreatePerspectiveFieldOfView_ROW", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single, $.Single
        ], []), 
      float4x4_CreatePerspectiveFieldOfView_ROW$0C
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreatePerspectiveOffCenter", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4x4_CreatePerspectiveOffCenter$0D
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveOffCenter", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single
        ], []), 
      float4x4_CreatePerspectiveOffCenter$0E
    );

    $.Method({Static:true , Public:true }, "CreatePerspectiveOffCenter_ROW", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4x4_CreatePerspectiveOffCenter_ROW
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreatePerspectiveOffCenterRH", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4x4_CreatePerspectiveOffCenterRH
    );

    $.Method({Static:true , Public:true }, "CreateRotationX", 
      new JSIL.MethodSignature(null, [$.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      float4x4_CreateRotationX$0F
    );

    $.Method({Static:true , Public:true }, "CreateRotationX", 
      new JSIL.MethodSignature($.Type, [$.Single], []), 
      float4x4_CreateRotationX$10
    );

    $.Method({Static:true , Public:true }, "CreateRotationX_ROW", 
      new JSIL.MethodSignature(null, [$.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      float4x4_CreateRotationX_ROW$11
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateRotationX_ROW", 
      new JSIL.MethodSignature($.Type, [$.Single], []), 
      float4x4_CreateRotationX_ROW$12
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateRotationY", 
      new JSIL.MethodSignature(null, [$.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      float4x4_CreateRotationY$13
    );

    $.Method({Static:true , Public:true }, "CreateRotationY", 
      new JSIL.MethodSignature($.Type, [$.Single], []), 
      float4x4_CreateRotationY$14
    );

    $.Method({Static:true , Public:true }, "CreateRotationY_ROW", 
      new JSIL.MethodSignature(null, [$.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      float4x4_CreateRotationY_ROW$15
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateRotationY_ROW", 
      new JSIL.MethodSignature($.Type, [$.Single], []), 
      float4x4_CreateRotationY_ROW$16
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateRotationZ", 
      new JSIL.MethodSignature(null, [$.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      float4x4_CreateRotationZ$17
    );

    $.Method({Static:true , Public:true }, "CreateRotationZ", 
      new JSIL.MethodSignature($.Type, [$.Single], []), 
      float4x4_CreateRotationZ$18
    );

    $.Method({Static:true , Public:true }, "CreateScale", 
      new JSIL.MethodSignature(null, [$.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      float4x4_CreateScale$19
    );

    $.Method({Static:true , Public:true }, "CreateScale", 
      new JSIL.MethodSignature($.Type, [$.Single], []), 
      float4x4_CreateScale$1A
    );

    $.Method({Static:true , Public:true }, "CreateScale", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4x4_CreateScale$1B
    );

    $.Method({Static:true , Public:true }, "CreateScale", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      float4x4_CreateScale$1C
    );

    $.Method({Static:true , Public:true }, "CreateScale", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single
        ], []), 
      float4x4_CreateScale$1D
    );

    $.Method({Static:true , Public:true }, "CreateScale", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.float3")], []), 
      float4x4_CreateScale$1E
    );

    $.Method({Static:true , Public:true }, "CreateTranslation", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4x4_CreateTranslation$1F
    );

    $.Method({Static:true , Public:true }, "CreateTranslation", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      float4x4_CreateTranslation$20
    );

    $.Method({Static:true , Public:true }, "CreateTranslation", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single
        ], []), 
      float4x4_CreateTranslation$21
    );

    $.Method({Static:true , Public:true }, "CreateTranslation", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.float3")], []), 
      float4x4_CreateTranslation$22
    );

    $.Method({Static:true , Public:true }, "CreateTranslation_ROW", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4x4_CreateTranslation_ROW$23
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "CreateTranslation_ROW", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single
        ], []), 
      float4x4_CreateTranslation_ROW$24
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object], []), 
      float4x4_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type], []), 
      float4x4_Equals$25
    );

    $.Method({Static:false, Public:true }, "get_Column0", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float4"), [], []), 
      float4x4_get_Column0
    );

    $.Method({Static:false, Public:true }, "get_Column1", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float4"), [], []), 
      float4x4_get_Column1
    );

    $.Method({Static:false, Public:true }, "get_Column2", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float4"), [], []), 
      float4x4_get_Column2
    );

    $.Method({Static:false, Public:true }, "get_Column3", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float4"), [], []), 
      float4x4_get_Column3
    );

    $.Method({Static:false, Public:true }, "get_Determinant", 
      new JSIL.MethodSignature($.Single, [], []), 
      float4x4_get_Determinant
    );

    $.Method({Static:false, Public:true }, "get_IsAffine", 
      new JSIL.MethodSignature($.Boolean, [], []), 
      float4x4_get_IsAffine
    );

    $.Method({Static:false, Public:true }, "get_M11", 
      new JSIL.MethodSignature($.Single, [], []), 
      float4x4_get_M11
    );

    $.Method({Static:false, Public:true }, "get_M12", 
      new JSIL.MethodSignature($.Single, [], []), 
      float4x4_get_M12
    );

    $.Method({Static:false, Public:true }, "get_M13", 
      new JSIL.MethodSignature($.Single, [], []), 
      float4x4_get_M13
    );

    $.Method({Static:false, Public:true }, "get_M14", 
      new JSIL.MethodSignature($.Single, [], []), 
      float4x4_get_M14
    );

    $.Method({Static:false, Public:true }, "get_M21", 
      new JSIL.MethodSignature($.Single, [], []), 
      float4x4_get_M21
    );

    $.Method({Static:false, Public:true }, "get_M22", 
      new JSIL.MethodSignature($.Single, [], []), 
      float4x4_get_M22
    );

    $.Method({Static:false, Public:true }, "get_M23", 
      new JSIL.MethodSignature($.Single, [], []), 
      float4x4_get_M23
    );

    $.Method({Static:false, Public:true }, "get_M24", 
      new JSIL.MethodSignature($.Single, [], []), 
      float4x4_get_M24
    );

    $.Method({Static:false, Public:true }, "get_M31", 
      new JSIL.MethodSignature($.Single, [], []), 
      float4x4_get_M31
    );

    $.Method({Static:false, Public:true }, "get_M32", 
      new JSIL.MethodSignature($.Single, [], []), 
      float4x4_get_M32
    );

    $.Method({Static:false, Public:true }, "get_M33", 
      new JSIL.MethodSignature($.Single, [], []), 
      float4x4_get_M33
    );

    $.Method({Static:false, Public:true }, "get_M34", 
      new JSIL.MethodSignature($.Single, [], []), 
      float4x4_get_M34
    );

    $.Method({Static:false, Public:true }, "get_M41", 
      new JSIL.MethodSignature($.Single, [], []), 
      float4x4_get_M41
    );

    $.Method({Static:false, Public:true }, "get_M42", 
      new JSIL.MethodSignature($.Single, [], []), 
      float4x4_get_M42
    );

    $.Method({Static:false, Public:true }, "get_M43", 
      new JSIL.MethodSignature($.Single, [], []), 
      float4x4_get_M43
    );

    $.Method({Static:false, Public:true }, "get_M44", 
      new JSIL.MethodSignature($.Single, [], []), 
      float4x4_get_M44
    );

    $.Method({Static:false, Public:true }, "get_Offset", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [], []), 
      float4x4_get_Offset
    );

    $.Method({Static:true , Public:true }, "get_Parse", 
      new JSIL.MethodSignature($asm07.TypeRef("System.Converter`2", [$.String, $.Type]), [], []), 
      float4x4_get_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      new JSIL.MethodSignature($.Int32, [], []), 
      float4x4_GetHashCode
    );

    $.Method({Static:false, Public:true }, "Invert", 
      new JSIL.MethodSignature(null, [], []), 
      float4x4_Invert$26
    );

    $.Method({Static:true , Public:true }, "Invert", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      float4x4_Invert$27
    );

    $.Method({Static:true , Public:true }, "InvertAffine", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      float4x4_InvertAffine
    );

    $.Method({Static:true , Public:true }, "LookAt", 
      new JSIL.MethodSignature($.Type, [
          $asm04.TypeRef("Fusee.Math.float3"), $asm04.TypeRef("Fusee.Math.float3"), 
          $asm04.TypeRef("Fusee.Math.float3")
        ], []), 
      float4x4_LookAt$28
    );

    $.Method({Static:true , Public:true }, "LookAt", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single
        ], []), 
      float4x4_LookAt$29
    );

    $.Method({Static:true , Public:true }, "LookAt_ROW", 
      new JSIL.MethodSignature($.Type, [
          $asm04.TypeRef("Fusee.Math.float3"), $asm04.TypeRef("Fusee.Math.float3"), 
          $asm04.TypeRef("Fusee.Math.float3")
        ], []), 
      float4x4_LookAt_ROW$2A
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "LookAt_ROW", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single, $.Single, 
          $.Single
        ], []), 
      float4x4_LookAt_ROW$2B
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Only for testing and debugging purposes during the row notation -> column notation code transition of the math library"]; });

    $.Method({Static:true , Public:true }, "LookAtRH", 
      new JSIL.MethodSignature($.Type, [
          $asm04.TypeRef("Fusee.Math.float3"), $asm04.TypeRef("Fusee.Math.float3"), 
          $asm04.TypeRef("Fusee.Math.float3")
        ], []), 
      float4x4_LookAtRH
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float4x4_Mult$2C
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4x4_Mult$2D
    );

    $.Method({Static:true , Public:true }, "MultAffine", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      float4x4_MultAffine
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float4x4_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type], []), 
      float4x4_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Explicit", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.double4x4")], []), 
      float4x4_op_Explicit
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type], []), 
      float4x4_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float4x4_op_Multiply$2E
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float4"), [$.Type, $asm04.TypeRef("Fusee.Math.float4")], []), 
      float4x4_op_Multiply$2F
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float4"), [$asm04.TypeRef("Fusee.Math.float4"), $.Type], []), 
      float4x4_op_Multiply$30
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$.Type, $asm04.TypeRef("Fusee.Math.float3")], []), 
      float4x4_op_Multiply$31
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$asm04.TypeRef("Fusee.Math.float3"), $.Type], []), 
      float4x4_op_Multiply$32
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float4x4_op_Subtraction
    );

    $.Method({Static:false, Public:true }, "Round", 
      new JSIL.MethodSignature(null, [], []), 
      float4x4_Round$33
    );

    $.Method({Static:true , Public:true }, "Round", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      float4x4_Round$34
    );

    $.Method({Static:true , Public:true }, "Scale", 
      new JSIL.MethodSignature($.Type, [$.Single], []), 
      float4x4_Scale$35
    );

    $.Method({Static:true , Public:true }, "Scale", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.float3")], []), 
      float4x4_Scale$36
    );

    $.Method({Static:true , Public:true }, "Scale", 
      new JSIL.MethodSignature($.Type, [
          $.Single, $.Single, 
          $.Single
        ], []), 
      float4x4_Scale$37
    );

    $.Method({Static:false, Public:true }, "set_M11", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float4x4_set_M11
    );

    $.Method({Static:false, Public:true }, "set_M12", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float4x4_set_M12
    );

    $.Method({Static:false, Public:true }, "set_M13", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float4x4_set_M13
    );

    $.Method({Static:false, Public:true }, "set_M14", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float4x4_set_M14
    );

    $.Method({Static:false, Public:true }, "set_M21", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float4x4_set_M21
    );

    $.Method({Static:false, Public:true }, "set_M22", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float4x4_set_M22
    );

    $.Method({Static:false, Public:true }, "set_M23", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float4x4_set_M23
    );

    $.Method({Static:false, Public:true }, "set_M24", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float4x4_set_M24
    );

    $.Method({Static:false, Public:true }, "set_M31", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float4x4_set_M31
    );

    $.Method({Static:false, Public:true }, "set_M32", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float4x4_set_M32
    );

    $.Method({Static:false, Public:true }, "set_M33", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float4x4_set_M33
    );

    $.Method({Static:false, Public:true }, "set_M34", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float4x4_set_M34
    );

    $.Method({Static:false, Public:true }, "set_M41", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float4x4_set_M41
    );

    $.Method({Static:false, Public:true }, "set_M42", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float4x4_set_M42
    );

    $.Method({Static:false, Public:true }, "set_M43", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float4x4_set_M43
    );

    $.Method({Static:false, Public:true }, "set_M44", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      float4x4_set_M44
    );

    $.Method({Static:true , Public:true }, "set_Parse", 
      new JSIL.MethodSignature(null, [$asm07.TypeRef("System.Converter`2", [$.String, $.Type])], []), 
      float4x4_set_Parse
    )
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute"));

    $.Method({Static:true , Public:true }, "Substract", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      float4x4_Substract
    );

    $.Method({Static:false, Public:false}, "ToArray", 
      new JSIL.MethodSignature($jsilcore.TypeRef("System.Array", [$.Single]), [], []), 
      float4x4_ToArray
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      new JSIL.MethodSignature($.String, [], []), 
      float4x4_toString
    );

    $.Method({Static:true , Public:true }, "Transform", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float4"), [$.Type, $asm04.TypeRef("Fusee.Math.float4")], []), 
      float4x4_Transform
    );

    $.Method({Static:true , Public:true }, "TransformPD", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$.Type, $asm04.TypeRef("Fusee.Math.float3")], []), 
      float4x4_TransformPD
    );

    $.Method({Static:true , Public:true }, "TransformPremult", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float4"), [$asm04.TypeRef("Fusee.Math.float4"), $.Type], []), 
      float4x4_TransformPremult
    );

    $.Method({Static:true , Public:true }, "TransformPremultPD", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$asm04.TypeRef("Fusee.Math.float3"), $.Type], []), 
      float4x4_TransformPremultPD
    );

    $.Method({Static:false, Public:true }, "Transpose", 
      new JSIL.MethodSignature(null, [], []), 
      float4x4_Transpose$38
    );

    $.Method({Static:true , Public:true }, "Transpose", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      float4x4_Transpose$39
    );

    $.Method({Static:true , Public:true }, "Transpose", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      float4x4_Transpose$3A
    );

    $.Field({Static:false, Public:true }, "Row0", $asm04.TypeRef("Fusee.Math.float4"))
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [1]; }); 
    $.Field({Static:false, Public:true }, "Row1", $asm04.TypeRef("Fusee.Math.float4"))
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [2]; }); 
    $.Field({Static:false, Public:true }, "Row2", $asm04.TypeRef("Fusee.Math.float4"))
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [3]; }); 
    $.Field({Static:false, Public:true }, "Row3", $asm04.TypeRef("Fusee.Math.float4"))
      .Attribute($asm08.TypeRef("ProtoBuf.ProtoMemberAttribute"), function () { return [4]; }); 
    $.Field({Static:true , Public:true }, "Identity", $.Type); 
    $.Field({Static:true , Public:true }, "Zero", $.Type); 
    $.Field({Static:true , Public:false}, "float4x4$Parse$value", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]))
      .Attribute($asm07.TypeRef("System.Runtime.CompilerServices.CompilerGeneratedAttribute")); 
    function float4x4__cctor () {
      $thisType.Identity = new $thisType();
      $thisType.Zero = new $thisType();
      $thisType.Identity = $S00().Construct($T00().UnitX.MemberwiseClone(), $T00().UnitY.MemberwiseClone(), $T00().UnitZ.MemberwiseClone(), $T00().UnitW.MemberwiseClone());
      $thisType.Zero = $S00().Construct($T00().Zero.MemberwiseClone(), $T00().Zero.MemberwiseClone(), $T00().Zero.MemberwiseClone(), $T00().Zero.MemberwiseClone());
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      new JSIL.MethodSignature(null, [], []), 
      float4x4__cctor
    );

    $.Property({Static:false, Public:true }, "Determinant", $.Single);

    $.Property({Static:false, Public:true }, "Column0", $asm04.TypeRef("Fusee.Math.float4"));

    $.Property({Static:false, Public:true }, "Column1", $asm04.TypeRef("Fusee.Math.float4"));

    $.Property({Static:false, Public:true }, "Column2", $asm04.TypeRef("Fusee.Math.float4"));

    $.Property({Static:false, Public:true }, "Column3", $asm04.TypeRef("Fusee.Math.float4"));

    $.Property({Static:false, Public:true }, "M11", $.Single);

    $.Property({Static:false, Public:true }, "M12", $.Single);

    $.Property({Static:false, Public:true }, "M13", $.Single);

    $.Property({Static:false, Public:true }, "M14", $.Single);

    $.Property({Static:false, Public:true }, "M21", $.Single);

    $.Property({Static:false, Public:true }, "M22", $.Single);

    $.Property({Static:false, Public:true }, "M23", $.Single);

    $.Property({Static:false, Public:true }, "M24", $.Single);

    $.Property({Static:false, Public:true }, "M31", $.Single);

    $.Property({Static:false, Public:true }, "M32", $.Single);

    $.Property({Static:false, Public:true }, "M33", $.Single);

    $.Property({Static:false, Public:true }, "M34", $.Single);

    $.Property({Static:false, Public:true }, "M41", $.Single);

    $.Property({Static:false, Public:true }, "M42", $.Single);

    $.Property({Static:false, Public:true }, "M43", $.Single);

    $.Property({Static:false, Public:true }, "M44", $.Single);

    $.Property({Static:false, Public:true }, "Offset", $asm04.TypeRef("Fusee.Math.float3"));

    $.Property({Static:false, Public:true }, "IsAffine", $.Boolean);

    $.Property({Static:true , Public:true }, "Parse", $asm07.TypeRef("System.Converter`2", [$.String, $.Type]));

    $.ImplementInterfaces(
      /* 0 */ $asm07.TypeRef("System.IEquatable`1", [$.Type])
    );

    return function (newThisType) { $thisType = newThisType; }; 
  })
    .Attribute($asm08.TypeRef("ProtoBuf.ProtoContractAttribute"));

})();

/* class Fusee.Math.NamespaceDoc */ 

(function NamespaceDoc$Members () {
  var $, $thisType;
  function NamespaceDoc__ctor () {
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.Object"), 
      Name: "Fusee.Math.NamespaceDoc", 
      IsPublic: false, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [], []), 
      NamespaceDoc__ctor
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Math.M */ 

(function M$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm07.System.Type)) ();
  };

  function M_Saturate$b1 (T, val, lower, upper) {
    var $im00 = $asm07.System.IComparable$b1.Of(T).CompareTo;
    return (($im00.Call(lower, null, JSIL.CloneParameter(T, val)) < 0) ? (($im00.Call(val, null, JSIL.CloneParameter(T, upper)) < 0) ? val : upper) : lower);
  };

  JSIL.MakeStaticClass("Fusee.Math.M", true, [], function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:true , Public:true }, "Saturate", 
      new JSIL.MethodSignature("!!0", [
          "!!0", "!!0", 
          "!!0"
        ], ["T"]), 
      M_Saturate$b1
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Math.QuaternionD */ 

(function QuaternionD$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Math.double3)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm07.System.Double)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm07.System.Object)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.System.Void)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm04.Fusee.Math.double4)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm07.System.String)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.QuaternionD"), [
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.double3"), [
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double")
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.QuaternionD"), [$asm04.TypeRef("Fusee.Math.double3"), $asm07.TypeRef("System.Double")]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double3"), [$asm04.TypeRef("Fusee.Math.double3"), $asm07.TypeRef("System.Double")], []))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double3"), [$asm07.TypeRef("System.Double"), $asm04.TypeRef("Fusee.Math.double3")], []))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")])
      ], []))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")]), $asm07.TypeRef("System.Double"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.QuaternionD")])
      ], []))) ();
  };

  function QuaternionD__ctor$00 (v, w) {
    this._xyz = v;
    this._w = +w;
  };

  function QuaternionD__ctor$01 (xx, yy, zz, w) {
    $thisType.prototype._ctor.call(this, $S01().Construct(xx, yy, zz), w);
  };

  function QuaternionD_Add$02 (left, right) {
    return $S02().Construct($T00().op_Addition(
        left.get_xyz().MemberwiseClone(), 
        right.get_xyz().MemberwiseClone()
      ).MemberwiseClone(), (left.get_w() + right.get_w()));
  };

  function QuaternionD_Add$03 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct($T00().op_Addition(
          left.get().get_xyz().MemberwiseClone(), 
          right.get().get_xyz().MemberwiseClone()
        ).MemberwiseClone(), (left.get().get_w() + right.get().get_w())));
  };

  function QuaternionD_Conjugate$04 () {
    (this.xyz = $T00().op_UnaryNegation(this.xyz.MemberwiseClone()).MemberwiseClone());
  };

  function QuaternionD_Conjugate$05 (q) {
    return $S02().Construct($T00().op_UnaryNegation(q.get_xyz().MemberwiseClone()).MemberwiseClone(), q.get_w());
  };

  function QuaternionD_Conjugate$06 (/* ref */ q, /* ref */ result) {
    result.set($S02().Construct($T00().op_UnaryNegation(q.get().get_xyz().MemberwiseClone()).MemberwiseClone(), q.get().get_w()));
  };

  function QuaternionD_Object_Equals (other) {
    return ($thisType.$Is(other) && $thisType.op_Equality(this.MemberwiseClone(), $thisType.$Cast(other).MemberwiseClone()));
  };

  function QuaternionD_Equals$07 (other) {
    return ($T00().op_Equality(
        this.get_xyz().MemberwiseClone(), 
        other.get_xyz()
      ) && ((Math.abs((this.get_w() - other.get_w()))) < 1.11022302462516E-16));
  };

  function QuaternionD_FromAxisAngle (axis, angle) {
    if (axis.get_LengthSquared() > 1.11022302462516E-16) {
      var result2 = $thisType.Identity.MemberwiseClone();
    } else {
      var result = $thisType.Identity.MemberwiseClone();
      angle *= +0.5;
      axis.Normalize();
      (result.xyz = $S03().CallStatic($T00(), "op_Multiply", null, axis.MemberwiseClone(), Math.sin(angle)).MemberwiseClone());
      result.set_w(Math.cos(angle));
      result2 = $thisType.Normalize(result.MemberwiseClone()).MemberwiseClone();
    }
    return result2;
  };

  function QuaternionD_get_Length () {
    return +Math.sqrt(((this.get_w() * this.get_w()) + this.get_xyz().get_LengthSquared()));
  };

  function QuaternionD_get_LengthSquared () {
    return +((this.get_w() * this.get_w()) + this.get_xyz().get_LengthSquared());
  };

  function QuaternionD_get_w () {
    return +this._w;
  };

  function QuaternionD_get_x () {
    return +this._xyz.x;
  };

  function QuaternionD_get_xyz () {
    return this._xyz;
  };

  function QuaternionD_get_y () {
    return +this._xyz.y;
  };

  function QuaternionD_get_z () {
    return +this._xyz.z;
  };

  function QuaternionD_GetHashCode () {
    return (this.get_xyz().GetHashCode() ^ this.get_w().GetHashCode());
  };

  function QuaternionD_Invert$08 ($q) {
    var q = new JSIL.BoxedVariable($q);
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.Invert(/* ref */ q, /* ref */ result);
    return result.get();
  };

  function QuaternionD_Invert$09 (/* ref */ q, /* ref */ result) {
    var lengthSq = +q.get().get_LengthSquared();
    if (lengthSq > 1.11022302462516E-16) {
      var i = +(1 / lengthSq);
      result.set($S02().Construct($S03().CallStatic($T00(), "op_Multiply", null, q.get().get_xyz().MemberwiseClone(), -i).MemberwiseClone(), (q.get().get_w() * i)));
    } else {
      result.set(q.get().MemberwiseClone());
    }
  };

  function QuaternionD_Mult$0A (left, right) {
    return $S02().Construct($T00().op_Addition(
        $T00().op_Addition(
          $S04().CallStatic($T00(), "op_Multiply", null, 
            right.get_w(), 
            left.get_xyz().MemberwiseClone()
          ).MemberwiseClone(), 
          $S04().CallStatic($T00(), "op_Multiply", null, 
            left.get_w(), 
            right.get_xyz().MemberwiseClone()
          ).MemberwiseClone()
        ).MemberwiseClone(), 
        $T00().Cross(
          left.get_xyz().MemberwiseClone(), 
          right.get_xyz().MemberwiseClone()
        ).MemberwiseClone()
      ).MemberwiseClone(), ((left.get_w() * right.get_w()) - $T00().Dot(
          left.get_xyz(), 
          right.get_xyz()
        )));
  };

  function QuaternionD_Mult$0B (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct($T00().op_Addition(
          $T00().op_Addition(
            $S04().CallStatic($T00(), "op_Multiply", null, 
              right.get().get_w(), 
              left.get().get_xyz().MemberwiseClone()
            ).MemberwiseClone(), 
            $S04().CallStatic($T00(), "op_Multiply", null, 
              left.get().get_w(), 
              right.get().get_xyz().MemberwiseClone()
            ).MemberwiseClone()
          ).MemberwiseClone(), 
          $T00().Cross(
            left.get().get_xyz().MemberwiseClone(), 
            right.get().get_xyz().MemberwiseClone()
          ).MemberwiseClone()
        ).MemberwiseClone(), ((left.get().get_w() * right.get().get_w()) - $T00().Dot(
            left.get().get_xyz(), 
            right.get().get_xyz()
          ))));
  };

  function QuaternionD_Multiply$0C ($left, $right) {
    var right = new JSIL.BoxedVariable($right);
    var left = new JSIL.BoxedVariable($left);
    var result = new JSIL.BoxedVariable(new $thisType());
    $S05().CallStatic($thisType, "Multiply", null, /* ref */ left, /* ref */ right, /* ref */ result);
    return result.get();
  };

  function QuaternionD_Multiply$0D (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S00().Construct(((((left.get().get_w() * right.get().get_x()) + (left.get().get_x() * right.get().get_w())) + (left.get().get_y() * right.get().get_z())) - (left.get().get_z() * right.get().get_y())), ((((left.get().get_w() * right.get().get_y()) + (left.get().get_y() * right.get().get_w())) + (left.get().get_z() * right.get().get_x())) - (left.get().get_x() * right.get().get_z())), ((((left.get().get_w() * right.get().get_z()) + (left.get().get_z() * right.get().get_w())) + (left.get().get_x() * right.get().get_y())) - (left.get().get_y() * right.get().get_x())), ((((left.get().get_w() * right.get().get_w()) - (left.get().get_x() * right.get().get_x())) - (left.get().get_y() * right.get().get_y())) - (left.get().get_z() * right.get().get_z()))));
  };

  function QuaternionD_Multiply$0E (/* ref */ quaternionD, scale, /* ref */ result) {
    result.set($S00().Construct((quaternionD.get().get_x() * scale), (quaternionD.get().get_y() * scale), (quaternionD.get().get_z() * scale), (quaternionD.get().get_w() * scale)));
  };

  function QuaternionD_Multiply$0F (quaternionD, scale) {
    return $S00().Construct((quaternionD.get_x() * scale), (quaternionD.get_y() * scale), (quaternionD.get_z() * scale), (quaternionD.get_w() * scale));
  };

  function QuaternionD_Normalize$10 () {
    var $temp00;
    if (this.get_Length() > 1.11022302462516E-16) {
      var scale = +(1 / this.get_Length());
      (this.xyz = $S03().CallStatic($T00(), "op_Multiply", null, this.xyz.MemberwiseClone(), scale).MemberwiseClone());
      ($temp00 = +(this.get_w() * scale), 
        this.set_w($temp00), 
        $temp00);
    }
  };

  function QuaternionD_Normalize$11 ($q) {
    var q = new JSIL.BoxedVariable($q);
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.Normalize(/* ref */ q, /* ref */ result);
    return result.get();
  };

  function QuaternionD_Normalize$12 (/* ref */ q, /* ref */ result) {
    if (q.get().get_Length() <= 1.1920930376163597E-07) {
      var scale = +0;
    } else {
      scale = +(1 / q.get().get_Length());
    }
    result.set($S02().Construct($S03().CallStatic($T00(), "op_Multiply", null, q.get().get_xyz().MemberwiseClone(), scale).MemberwiseClone(), (q.get().get_w() * scale)));
  };

  function QuaternionD_op_Addition (left, right) {
    var $temp00;
    (left.xyz = $T00().op_Addition(left.xyz.MemberwiseClone(), right.get_xyz().MemberwiseClone()).MemberwiseClone());
    ($temp00 = +(left.get_w() + right.get_w()), 
      left.set_w($temp00), 
      $temp00);
    return left;
  };

  function QuaternionD_op_Equality (left, right) {
    return left.Equals(right);
  };

  function QuaternionD_op_Inequality (left, right) {
    return !left.Equals(right);
  };

  function QuaternionD_op_Multiply$13 ($left, $right) {
    var right = new JSIL.BoxedVariable($right);
    var left = new JSIL.BoxedVariable($left);
    $S05().CallStatic($thisType, "Multiply", null, /* ref */ left, /* ref */ right, /* ref */ left);
    return left.get();
  };

  function QuaternionD_op_Multiply$14 ($quaternionD, scale) {
    var quaternionD = new JSIL.BoxedVariable($quaternionD);
    $S06().CallStatic($thisType, "Multiply", null, /* ref */ quaternionD, scale, /* ref */ quaternionD);
    return quaternionD.get();
  };

  function QuaternionD_op_Multiply$15 (scale, quaternionD) {
    return $S00().Construct((quaternionD.get_x() * scale), (quaternionD.get_y() * scale), (quaternionD.get_z() * scale), (quaternionD.get_w() * scale));
  };

  function QuaternionD_op_Subtraction (left, right) {
    var $temp00;
    (left.xyz = $T00().op_Subtraction(left.xyz.MemberwiseClone(), right.get_xyz().MemberwiseClone()).MemberwiseClone());
    ($temp00 = +(left.get_w() - right.get_w()), 
      left.set_w($temp00), 
      $temp00);
    return left;
  };

  function QuaternionD_set_w (value) {
    this._w = +value;
  };

  function QuaternionD_set_x (value) {
    this._xyz.x = +value;
  };

  function QuaternionD_set_xyz (value) {
    this._xyz = value;
  };

  function QuaternionD_set_y (value) {
    this._xyz.y = +value;
  };

  function QuaternionD_set_z (value) {
    this._xyz.z = +value;
  };

  function QuaternionD_Slerp (q1, q2, blend) {
    var result = new $thisType();
    if (q1.get_LengthSquared() < 1.11022302462516E-16) {
      var result2 = ((q2.get_LengthSquared() <= 1.1920930376163597E-07) ? $thisType.Identity : q2).MemberwiseClone();
    } else if (q2.get_LengthSquared() < 1.11022302462516E-16) {
      result2 = q1.MemberwiseClone();
    } else {
      var cosHalfAngle = +((q1.get_w() * q2.get_w()) + $T00().Dot(
          q1.get_xyz(), 
          q2.get_xyz()
        ));
      if (!((cosHalfAngle < 1) && (cosHalfAngle > -1))) {
        result2 = q1.MemberwiseClone();
      } else {
        if (cosHalfAngle < 0) {
          (q2.xyz = $T00().op_UnaryNegation(q2.xyz.MemberwiseClone()).MemberwiseClone());
          q2.set_w(-q2.get_w());
          cosHalfAngle = +-cosHalfAngle;
        }
        if (cosHalfAngle < 0.99000000953674316) {
          var halfAngle = +(Math.acos(cosHalfAngle));
          var sinHalfAngle = +(Math.sin(halfAngle));
          var oneOverSinHalfAngle = +(1 / sinHalfAngle);
          var blendA = +((Math.sin((halfAngle * (1 - blend)))) * oneOverSinHalfAngle);
          var blendB = +((Math.sin((halfAngle * blend))) * oneOverSinHalfAngle);
        } else {
          blendA = +(1 - blend);
          blendB = +blend;
        }
        $thisType.prototype._ctor.call(result, 
          $T00().op_Addition(
            $S04().CallStatic($T00(), "op_Multiply", null, blendA, q1.get_xyz().MemberwiseClone()).MemberwiseClone(), 
            $S04().CallStatic($T00(), "op_Multiply", null, blendB, q2.get_xyz().MemberwiseClone()).MemberwiseClone()
          ).MemberwiseClone(), 
          ((blendA * q1.get_w()) + (blendB * q2.get_w()))
        );
        result2 = ((result.get_LengthSquared() > 1.11022302462516E-16) ? $thisType.Normalize(result.MemberwiseClone()) : $thisType.Identity).MemberwiseClone();
      }
    }
    return result2;
  };

  function QuaternionD_Sub$16 (left, right) {
    return $S02().Construct($T00().op_Subtraction(
        left.get_xyz().MemberwiseClone(), 
        right.get_xyz().MemberwiseClone()
      ).MemberwiseClone(), (left.get_w() - right.get_w()));
  };

  function QuaternionD_Sub$17 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct($T00().op_Subtraction(
          left.get().get_xyz().MemberwiseClone(), 
          right.get().get_xyz().MemberwiseClone()
        ).MemberwiseClone(), (left.get().get_w() - right.get().get_w())));
  };

  function QuaternionD_ToAxisAngle$18 (/* ref */ axis, /* ref */ angle) {
    var result = this.ToAxisAngle();
    axis.set(result.get_xyz().MemberwiseClone());
    angle.set(result.w);
  };

  function QuaternionD_ToAxisAngle$19 () {
    var q = this.MemberwiseClone();
    if (q.get_w() > 1) {
      q.Normalize();
    }
    var result = (new ($T04())()).__Initialize__({
        w: (2 * (Math.acos(q.get_w())))}
    );
    var den = +(Math.sqrt((1 - (q.get_w() * q.get_w()))));
    if (den > 1.11022302462516E-16) {
      (result.xyz = $T00().op_Division(q.get_xyz().MemberwiseClone(), den).MemberwiseClone());
    } else {
      (result.xyz = $T00().UnitX.MemberwiseClone());
    }
    return result;
  };

  function QuaternionD_toString () {
    return $T05().Format(
      "V: {0}, w: {1}", 
      this.get_xyz(), 
      this.get_w()
    );
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.QuaternionD", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 4, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.double3"), $.Double], []), 
      QuaternionD__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Double, $.Double, 
          $.Double, $.Double
        ], []), 
      QuaternionD__ctor$01
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      QuaternionD_Add$02
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      QuaternionD_Add$03
    );

    $.Method({Static:false, Public:true }, "Conjugate", 
      new JSIL.MethodSignature(null, [], []), 
      QuaternionD_Conjugate$04
    );

    $.Method({Static:true , Public:true }, "Conjugate", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      QuaternionD_Conjugate$05
    );

    $.Method({Static:true , Public:true }, "Conjugate", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      QuaternionD_Conjugate$06
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object], []), 
      QuaternionD_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type], []), 
      QuaternionD_Equals$07
    );

    $.Method({Static:true , Public:true }, "FromAxisAngle", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.double3"), $.Double], []), 
      QuaternionD_FromAxisAngle
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      new JSIL.MethodSignature($.Double, [], []), 
      QuaternionD_get_Length
    );

    $.Method({Static:false, Public:true }, "get_LengthSquared", 
      new JSIL.MethodSignature($.Double, [], []), 
      QuaternionD_get_LengthSquared
    );

    $.Method({Static:false, Public:true }, "get_w", 
      new JSIL.MethodSignature($.Double, [], []), 
      QuaternionD_get_w
    );

    $.Method({Static:false, Public:true }, "get_x", 
      new JSIL.MethodSignature($.Double, [], []), 
      QuaternionD_get_x
    );

    $.Method({Static:false, Public:true }, "get_xyz", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double3"), [], []), 
      QuaternionD_get_xyz
    );

    $.Method({Static:false, Public:true }, "get_y", 
      new JSIL.MethodSignature($.Double, [], []), 
      QuaternionD_get_y
    );

    $.Method({Static:false, Public:true }, "get_z", 
      new JSIL.MethodSignature($.Double, [], []), 
      QuaternionD_get_z
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      new JSIL.MethodSignature($.Int32, [], []), 
      QuaternionD_GetHashCode
    );

    $.Method({Static:true , Public:true }, "Invert", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      QuaternionD_Invert$08
    );

    $.Method({Static:true , Public:true }, "Invert", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      QuaternionD_Invert$09
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      QuaternionD_Mult$0A
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use Multiply instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      QuaternionD_Mult$0B
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use Multiply instead."]; });

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      QuaternionD_Multiply$0C
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      QuaternionD_Multiply$0D
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Double, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      QuaternionD_Multiply$0E
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double], []), 
      QuaternionD_Multiply$0F
    );

    $.Method({Static:false, Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [], []), 
      QuaternionD_Normalize$10
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      QuaternionD_Normalize$11
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      QuaternionD_Normalize$12
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      QuaternionD_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type], []), 
      QuaternionD_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type], []), 
      QuaternionD_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      QuaternionD_op_Multiply$13
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Double], []), 
      QuaternionD_op_Multiply$14
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Double, $.Type], []), 
      QuaternionD_op_Multiply$15
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      QuaternionD_op_Subtraction
    );

    $.Method({Static:false, Public:true }, "set_w", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      QuaternionD_set_w
    );

    $.Method({Static:false, Public:true }, "set_x", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      QuaternionD_set_x
    );

    $.Method({Static:false, Public:true }, "set_xyz", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.double3")], []), 
      QuaternionD_set_xyz
    );

    $.Method({Static:false, Public:true }, "set_y", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      QuaternionD_set_y
    );

    $.Method({Static:false, Public:true }, "set_z", 
      new JSIL.MethodSignature(null, [$.Double], []), 
      QuaternionD_set_z
    );

    $.Method({Static:true , Public:true }, "Slerp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Double
        ], []), 
      QuaternionD_Slerp
    );

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      QuaternionD_Sub$16
    );

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      QuaternionD_Sub$17
    );

    $.Method({Static:false, Public:true }, "ToAxisAngle", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.double3")]), $jsilcore.TypeRef("JSIL.Reference", [$.Double])], []), 
      QuaternionD_ToAxisAngle$18
    );

    $.Method({Static:false, Public:true }, "ToAxisAngle", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.double4"), [], []), 
      QuaternionD_ToAxisAngle$19
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      new JSIL.MethodSignature($.String, [], []), 
      QuaternionD_toString
    );

    $.Field({Static:false, Public:false}, "_xyz", $asm04.TypeRef("Fusee.Math.double3")); 
    $.Field({Static:false, Public:false}, "_w", $.Double); 
    $.Field({Static:true , Public:true }, "Identity", $.Type); 
    function QuaternionD__cctor () {
      $thisType.Identity = new $thisType();
      $thisType.Identity = $S00().Construct(0, 0, 0, 1);
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      new JSIL.MethodSignature(null, [], []), 
      QuaternionD__cctor
    );

    $.Property({Static:false, Public:true }, "xyz", $asm04.TypeRef("Fusee.Math.double3"));

    $.Property({Static:false, Public:true }, "x", $.Double);

    $.Property({Static:false, Public:true }, "y", $.Double);

    $.Property({Static:false, Public:true }, "z", $.Double);

    $.Property({Static:false, Public:true }, "w", $.Double);

    $.Property({Static:false, Public:true }, "Length", $.Double);

    $.Property({Static:false, Public:true }, "LengthSquared", $.Double);

    $.ImplementInterfaces(
      /* 0 */ $asm07.TypeRef("System.IEquatable`1", [$.Type])
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* class Fusee.Math.MathHelper */ 

(function MathHelper$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm07.System.Int32)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm07.System.Int64)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm07.System.Double)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.System.Single)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.System.Void)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm04.Fusee.Math.float4)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm07.System.UInt32)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm07.System.ArgumentOutOfRangeException)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("System.Single"), [$asm07.TypeRef("System.Single")], []))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm07.TypeRef("System.ArgumentOutOfRangeException"), [$asm07.TypeRef("System.String"), $asm07.TypeRef("System.String")]))) ();
  };

  function MathHelper__ctor () {
  };

  function MathHelper_BinomialCoefficient (n, k) {
    return $T01().op_Division(
      $thisType.Factorial(n), 
      $T01().op_Multiplication(
        $thisType.Factorial(k), 
        $thisType.Factorial(((n - k) | 0))
      )
    );
  };

  function MathHelper_Clamp$00 (val, min, max) {
    return +((val < min) ? min : ((val > max) ? max : val));
  };

  function MathHelper_Clamp$01 (val, min, max) {
    return +((val < min) ? min : ((val > max) ? max : val));
  };

  function MathHelper_DegreesToRadians (degrees) {
    return +(degrees * 0.0174532924);
  };

  function MathHelper_Equals$02 (a, b) {
    return ((Math.abs((a - b))) < 1.11022302462516E-16);
  };

  function MathHelper_Equals$03 (a, b) {
    return ((Math.abs((a - b))) < 1.192093E-07);
  };

  function MathHelper_Factorial (n) {
    var result = $T01().Create(1, 0, 0);

    while (n > 1) {
      result = $T01().op_Multiplication(
        result, 
        $T01().FromNumber(n)
      );
      n = ((n - 1) | 0);
    }
    return result;
  };

  function MathHelper_Float4ToABGR (value) {
    var r = ((255 * value.x) | 0);
    var g = ((255 * value.y) | 0);
    var b = ((255 * value.z) | 0);
    var a = ((255 * value.w) | 0);
    return (((((((a << 24) + (b << 16)) >>> 0) + (g << 8)) >>> 0) + r) >>> 0);
  };

  function MathHelper_InverseSqrtFast$04 (x) {
    return +$T03().$Cast((1 / (Math.sqrt(x))));
  };

  function MathHelper_InverseSqrtFast$05 (x) {
    return +$S00().CallStatic($thisType, "InverseSqrtFast", null, $T03().$Cast(x));
  };

  function MathHelper_NextPowerOfTwo$06 (n) {
    if (!$T01().op_GreaterThanOrEqual(
        n, 
        $T01().Create(0, 0, 0)
      )) {
      throw $S01().Construct("n", "Must be positive.");
    }
    return $T01().FromNumber(Math.pow(2, Math.ceil((Math.log((n).ToNumber(-1, false)) / Math.log(2)))));
  };

  function MathHelper_NextPowerOfTwo$07 (n) {
    if (n < 0) {
      throw $S01().Construct("n", "Must be positive.");
    }
    return ((Math.pow(2, Math.ceil((Math.log(n) / Math.log(2))))) | 0);
  };

  function MathHelper_NextPowerOfTwo$08 (n) {
    if (n < 0) {
      throw $S01().Construct("n", "Must be positive.");
    }
    return +$T03().$Cast(Math.pow(2, Math.ceil((Math.log(n) / Math.log(2)))));
  };

  function MathHelper_NextPowerOfTwo$09 (n) {
    if (n < 0) {
      throw $S01().Construct("n", "Must be positive.");
    }
    return +Math.pow(2, Math.ceil((Math.log(n) / Math.log(2))));
  };

  function MathHelper_RadiansToDegrees (radians) {
    return +(radians * 57.2957764);
  };

  function MathHelper_Swap$0A (/* ref */ a, /* ref */ b) {
    var temp = a.get();
    a.set(b.get());
    b.set(temp);
  };

  function MathHelper_Swap$0B (/* ref */ a, /* ref */ b) {
    var temp = a.get();
    a.set(b.get());
    b.set(temp);
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.Object"), 
      Name: "Fusee.Math.MathHelper", 
      IsPublic: true, 
      IsReferenceType: true, 
      MaximumConstructorArguments: 0, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [], []), 
      MathHelper__ctor
    );

    $.Method({Static:true , Public:true }, "BinomialCoefficient", 
      new JSIL.MethodSignature($.Int64, [$.Int32, $.Int32], []), 
      MathHelper_BinomialCoefficient
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature($.Double, [
          $.Double, $.Double, 
          $.Double
        ], []), 
      MathHelper_Clamp$00
    );

    $.Method({Static:true , Public:true }, "Clamp", 
      new JSIL.MethodSignature($.Single, [
          $.Single, $.Single, 
          $.Single
        ], []), 
      MathHelper_Clamp$01
    );

    $.Method({Static:true , Public:true }, "DegreesToRadians", 
      new JSIL.MethodSignature($.Single, [$.Single], []), 
      MathHelper_DegreesToRadians
    );

    $.Method({Static:true , Public:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Double, $.Double], []), 
      MathHelper_Equals$02
    );

    $.Method({Static:true , Public:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Single, $.Single], []), 
      MathHelper_Equals$03
    );

    $.Method({Static:true , Public:true }, "Factorial", 
      new JSIL.MethodSignature($.Int64, [$.Int32], []), 
      MathHelper_Factorial
    );

    $.Method({Static:true , Public:true }, "Float4ToABGR", 
      new JSIL.MethodSignature($.UInt32, [$asm04.TypeRef("Fusee.Math.float4")], []), 
      MathHelper_Float4ToABGR
    );

    $.Method({Static:true , Public:true }, "InverseSqrtFast", 
      new JSIL.MethodSignature($.Single, [$.Single], []), 
      MathHelper_InverseSqrtFast$04
    );

    $.Method({Static:true , Public:true }, "InverseSqrtFast", 
      new JSIL.MethodSignature($.Double, [$.Double], []), 
      MathHelper_InverseSqrtFast$05
    );

    $.Method({Static:true , Public:true }, "NextPowerOfTwo", 
      new JSIL.MethodSignature($.Int64, [$.Int64], []), 
      MathHelper_NextPowerOfTwo$06
    );

    $.Method({Static:true , Public:true }, "NextPowerOfTwo", 
      new JSIL.MethodSignature($.Int32, [$.Int32], []), 
      MathHelper_NextPowerOfTwo$07
    );

    $.Method({Static:true , Public:true }, "NextPowerOfTwo", 
      new JSIL.MethodSignature($.Single, [$.Single], []), 
      MathHelper_NextPowerOfTwo$08
    );

    $.Method({Static:true , Public:true }, "NextPowerOfTwo", 
      new JSIL.MethodSignature($.Double, [$.Double], []), 
      MathHelper_NextPowerOfTwo$09
    );

    $.Method({Static:true , Public:true }, "RadiansToDegrees", 
      new JSIL.MethodSignature($.Single, [$.Single], []), 
      MathHelper_RadiansToDegrees
    );

    $.Method({Static:true , Public:true }, "Swap", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Double]), $jsilcore.TypeRef("JSIL.Reference", [$.Double])], []), 
      MathHelper_Swap$0A
    );

    $.Method({Static:true , Public:true }, "Swap", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Single]), $jsilcore.TypeRef("JSIL.Reference", [$.Single])], []), 
      MathHelper_Swap$0B
    );

    $.Constant({Static:true , Public:true }, "EpsilonFloat", 1.192093E-07); 
    $.Constant({Static:true , Public:true }, "EpsilonDouble", 1.11022302462516E-16); 
    $.Constant({Static:true , Public:true }, "Pi", 3.14159274); 
    $.Constant({Static:true , Public:true }, "PiOver2", 1.57079637); 
    $.Constant({Static:true , Public:true }, "PiOver3", 1.04719758); 
    $.Constant({Static:true , Public:true }, "PiOver4", 0.7853982); 
    $.Constant({Static:true , Public:true }, "PiOver6", 0.5235988); 
    $.Constant({Static:true , Public:true }, "TwoPi", 6.28318548); 
    $.Constant({Static:true , Public:true }, "ThreePiOver2", 4.712389); 
    $.Constant({Static:true , Public:true }, "E", 2.71828175); 
    $.Constant({Static:true , Public:true }, "Log10E", 0.4342945); 
    $.Constant({Static:true , Public:true }, "Log2E", 1.442695); 
    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

/* struct Fusee.Math.Quaternion */ 

(function Quaternion$Members () {
  var $, $thisType;
  var $T00 = function () {
    return ($T00 = JSIL.Memoize($asm04.Fusee.Math.float3)) ();
  };
  var $T01 = function () {
    return ($T01 = JSIL.Memoize($asm07.System.Single)) ();
  };
  var $T02 = function () {
    return ($T02 = JSIL.Memoize($asm07.System.Void)) ();
  };
  var $T03 = function () {
    return ($T03 = JSIL.Memoize($asm07.System.Math)) ();
  };
  var $T04 = function () {
    return ($T04 = JSIL.Memoize($asm07.System.Object)) ();
  };
  var $T05 = function () {
    return ($T05 = JSIL.Memoize($asm07.System.Boolean)) ();
  };
  var $T06 = function () {
    return ($T06 = JSIL.Memoize($asm04.Fusee.Math.MathHelper)) ();
  };
  var $T07 = function () {
    return ($T07 = JSIL.Memoize($asm07.System.Double)) ();
  };
  var $T08 = function () {
    return ($T08 = JSIL.Memoize(System.Array.Of($asm04.Fusee.Math.float3))) ();
  };
  var $T09 = function () {
    return ($T09 = JSIL.Memoize($asm04.Fusee.Math.float4x4)) ();
  };
  var $T0A = function () {
    return ($T0A = JSIL.Memoize($asm04.Fusee.Math.float4)) ();
  };
  var $T0B = function () {
    return ($T0B = JSIL.Memoize($asm07.System.String)) ();
  };
  var $S00 = function () {
    return ($S00 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.Quaternion"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S01 = function () {
    return ($S01 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.float3"), [
        $asm07.TypeRef("System.Single"), $asm07.TypeRef("System.Single"), 
        $asm07.TypeRef("System.Single")
      ]))) ();
  };
  var $S02 = function () {
    return ($S02 = JSIL.Memoize(new JSIL.ConstructorSignature($asm04.TypeRef("Fusee.Math.Quaternion"), [$asm04.TypeRef("Fusee.Math.float3"), $asm07.TypeRef("System.Single")]))) ();
  };
  var $S03 = function () {
    return ($S03 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("System.Int32"), [$asm07.TypeRef("System.Single")], []))) ();
  };
  var $S04 = function () {
    return ($S04 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$asm04.TypeRef("Fusee.Math.float3"), $asm07.TypeRef("System.Single")], []))) ();
  };
  var $S05 = function () {
    return ($S05 = JSIL.Memoize(new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$asm07.TypeRef("System.Single"), $asm04.TypeRef("Fusee.Math.float3")], []))) ();
  };
  var $S06 = function () {
    return ($S06 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")]), $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")]), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")])
      ], []))) ();
  };
  var $S07 = function () {
    return ($S07 = JSIL.Memoize(new JSIL.MethodSignature(null, [
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")]), $asm07.TypeRef("System.Single"), 
        $jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.Quaternion")])
      ], []))) ();
  };
  var $S08 = function () {
    return ($S08 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("System.Boolean"), [$asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double")], []))) ();
  };
  var $S09 = function () {
    return ($S09 = JSIL.Memoize(new JSIL.MethodSignature($asm07.TypeRef("System.Double"), [
        $asm07.TypeRef("System.Double"), $asm07.TypeRef("System.Double"), 
        $asm07.TypeRef("System.Double")
      ], []))) ();
  };

  function Quaternion__ctor$00 (v, w) {
    this._xyz = v;
    this._w = +w;
  };

  function Quaternion__ctor$01 (xx, yy, zz, w) {
    $thisType.prototype._ctor.call(this, $S01().Construct(xx, yy, zz), w);
  };

  function Quaternion_Add$02 (left, right) {
    return $S02().Construct($T00().op_Addition(
        left.get_xyz().MemberwiseClone(), 
        right.get_xyz().MemberwiseClone()
      ).MemberwiseClone(), (left.get_w() + right.get_w()));
  };

  function Quaternion_Add$03 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct($T00().op_Addition(
          left.get().get_xyz().MemberwiseClone(), 
          right.get().get_xyz().MemberwiseClone()
        ).MemberwiseClone(), (left.get().get_w() + right.get().get_w())));
  };

  function Quaternion_Conjugate$04 () {
    (this.xyz = $T00().op_UnaryNegation(this.xyz.MemberwiseClone()).MemberwiseClone());
  };

  function Quaternion_Conjugate$05 (q) {
    return $S02().Construct($T00().op_UnaryNegation(q.get_xyz().MemberwiseClone()).MemberwiseClone(), q.get_w());
  };

  function Quaternion_Conjugate$06 (/* ref */ q, /* ref */ result) {
    result.set($S02().Construct($T00().op_UnaryNegation(q.get().get_xyz().MemberwiseClone()).MemberwiseClone(), q.get().get_w()));
  };

  function Quaternion_CopySign (a, b) {
    return +((Math.abs(a)) * $T01().$Cast($S03().CallStatic($T03(), "Sign", null, b)));
  };

  function Quaternion_Object_Equals (other) {
    return ($thisType.$Is(other) && $thisType.op_Equality(this.MemberwiseClone(), $thisType.$Cast(other).MemberwiseClone()));
  };

  function Quaternion_Equals$07 (other) {
    return ($T00().op_Equality(
        this.get_xyz().MemberwiseClone(), 
        other.get_xyz().MemberwiseClone()
      ) && ((Math.abs((this.get_w() - other.get_w()))) < 1.192093E-07));
  };

  function Quaternion_EulerToQuaternion (e, inDegrees) {
    if (inDegrees) {
      $T00().prototype._ctor.call(e, 
        $T06().DegreesToRadians(e.x), 
        $T06().DegreesToRadians(e.y), 
        $T06().DegreesToRadians(e.z)
      );
    }
    var sX = +$T01().$Cast(Math.sin((e.x * 0.5)));
    var cX = +$T01().$Cast(Math.cos((e.x * 0.5)));
    var sY = +$T01().$Cast(Math.sin((e.y * 0.5)));
    var cY = +$T01().$Cast(Math.cos((e.y * 0.5)));
    var sZ = +$T01().$Cast(Math.sin((e.z * 0.5)));
    var cZ = +$T01().$Cast(Math.cos((e.z * 0.5)));
    var x = +(((sX * cY) * cZ) - ((cX * sY) * sZ));
    var y = +(((cX * sY) * cZ) + ((sX * cY) * sZ));
    var z = +(((cX * cY) * sZ) - ((sX * sY) * cZ));
    var w = +(((cX * cY) * cZ) + ((sX * sY) * sZ));
    return $S00().Construct(x, y, z, w);
  };

  function Quaternion_FromAxisAngle (axis, angle) {
    if (axis.get_LengthSquared() > 1.192093E-07) {
      var result2 = $thisType.Identity.MemberwiseClone();
    } else {
      var result = $thisType.Identity.MemberwiseClone();
      angle *= +0.5;
      axis.Normalize();
      (result.xyz = $S04().CallStatic($T00(), "op_Multiply", null, axis.MemberwiseClone(), $T01().$Cast(Math.sin(angle))).MemberwiseClone());
      result.set_w($T01().$Cast(Math.cos(angle)));
      result2 = $thisType.Normalize(result.MemberwiseClone()).MemberwiseClone();
    }
    return result2;
  };

  function Quaternion_get_Length () {
    return +$T01().$Cast(Math.sqrt(((this.get_w() * this.get_w()) + this.get_xyz().get_LengthSquared())));
  };

  function Quaternion_get_LengthSquared () {
    return +((this.get_w() * this.get_w()) + this.get_xyz().get_LengthSquared());
  };

  function Quaternion_get_w () {
    return +this._w;
  };

  function Quaternion_get_x () {
    return +this._xyz.x;
  };

  function Quaternion_get_xyz () {
    return this._xyz;
  };

  function Quaternion_get_y () {
    return +this._xyz.y;
  };

  function Quaternion_get_z () {
    return +this._xyz.z;
  };

  function Quaternion_GetHashCode () {
    return (this.get_xyz().GetHashCode() ^ this.get_w().GetHashCode());
  };

  function Quaternion_Invert$08 ($q) {
    var q = new JSIL.BoxedVariable($q);
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.Invert(/* ref */ q, /* ref */ result);
    return result.get();
  };

  function Quaternion_Invert$09 (/* ref */ q, /* ref */ result) {
    var lengthSq = +q.get().get_LengthSquared();
    if (lengthSq > 1.192093E-07) {
      var i = +(1 / lengthSq);
      result.set($S02().Construct($S04().CallStatic($T00(), "op_Multiply", null, q.get().get_xyz().MemberwiseClone(), -i).MemberwiseClone(), (q.get().get_w() * i)));
    } else {
      result.set(q.get().MemberwiseClone());
    }
  };

  function Quaternion_LookRotation (lookAt, upDirection) {
    var result = $T00().OrthoNormalize(lookAt.MemberwiseClone(), upDirection.MemberwiseClone());
    upDirection = result[1].MemberwiseClone();
    lookAt = result[0].MemberwiseClone();
    var right = $T00().Cross(upDirection.MemberwiseClone(), lookAt.MemberwiseClone()).MemberwiseClone();
    var w = +($T01().$Cast(Math.sqrt((((1 + right.x) + upDirection.y) + lookAt.z))) * 0.5);
    var x = +((upDirection.z - lookAt.y) * (1 / (4 * w)));
    var y = +((lookAt.x - right.z) * (1 / (4 * w)));
    var z = +((right.y - upDirection.x) * (1 / (4 * w)));
    var ret = $S00().Construct(x, y, z, w);
    return ret;
  };

  function Quaternion_Mult$0A (left, right) {
    return $S02().Construct($T00().op_Addition(
        $T00().op_Addition(
          $S05().CallStatic($T00(), "op_Multiply", null, 
            right.get_w(), 
            left.get_xyz().MemberwiseClone()
          ).MemberwiseClone(), 
          $S05().CallStatic($T00(), "op_Multiply", null, 
            left.get_w(), 
            right.get_xyz().MemberwiseClone()
          ).MemberwiseClone()
        ).MemberwiseClone(), 
        $T00().Cross(
          left.get_xyz().MemberwiseClone(), 
          right.get_xyz().MemberwiseClone()
        ).MemberwiseClone()
      ).MemberwiseClone(), ((left.get_w() * right.get_w()) - $T00().Dot(
          left.get_xyz(), 
          right.get_xyz()
        )));
  };

  function Quaternion_Mult$0B (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct($T00().op_Addition(
          $T00().op_Addition(
            $S05().CallStatic($T00(), "op_Multiply", null, 
              right.get().get_w(), 
              left.get().get_xyz().MemberwiseClone()
            ).MemberwiseClone(), 
            $S05().CallStatic($T00(), "op_Multiply", null, 
              left.get().get_w(), 
              right.get().get_xyz().MemberwiseClone()
            ).MemberwiseClone()
          ).MemberwiseClone(), 
          $T00().Cross(
            left.get().get_xyz().MemberwiseClone(), 
            right.get().get_xyz().MemberwiseClone()
          ).MemberwiseClone()
        ).MemberwiseClone(), ((left.get().get_w() * right.get().get_w()) - $T00().Dot(
            left.get().get_xyz(), 
            right.get().get_xyz()
          ))));
  };

  function Quaternion_Multiply$0C ($left, $right) {
    var right = new JSIL.BoxedVariable($right);
    var left = new JSIL.BoxedVariable($left);
    var result = new JSIL.BoxedVariable(new $thisType());
    $S06().CallStatic($thisType, "Multiply", null, /* ref */ left, /* ref */ right, /* ref */ result);
    return result.get();
  };

  function Quaternion_Multiply$0D (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S00().Construct(((((left.get().get_w() * right.get().get_x()) + (left.get().get_x() * right.get().get_w())) + (left.get().get_y() * right.get().get_z())) - (left.get().get_z() * right.get().get_y())), ((((left.get().get_w() * right.get().get_y()) + (left.get().get_y() * right.get().get_w())) + (left.get().get_z() * right.get().get_x())) - (left.get().get_x() * right.get().get_z())), ((((left.get().get_w() * right.get().get_z()) + (left.get().get_z() * right.get().get_w())) + (left.get().get_x() * right.get().get_y())) - (left.get().get_y() * right.get().get_x())), ((((left.get().get_w() * right.get().get_w()) - (left.get().get_x() * right.get().get_x())) - (left.get().get_y() * right.get().get_y())) - (left.get().get_z() * right.get().get_z()))));
  };

  function Quaternion_Multiply$0E (/* ref */ quaternion, scale, /* ref */ result) {
    result.set($S00().Construct((quaternion.get().get_x() * scale), (quaternion.get().get_y() * scale), (quaternion.get().get_z() * scale), (quaternion.get().get_w() * scale)));
  };

  function Quaternion_Multiply$0F (quaternion, scale) {
    return $S00().Construct((quaternion.get_x() * scale), (quaternion.get_y() * scale), (quaternion.get_z() * scale), (quaternion.get_w() * scale));
  };

  function Quaternion_Normalize$10 () {
    var $temp00;
    if (this.get_Length() > 1.192093E-07) {
      var scale = +(1 / this.get_Length());
      (this.xyz = $S04().CallStatic($T00(), "op_Multiply", null, this.xyz.MemberwiseClone(), scale).MemberwiseClone());
      ($temp00 = +(this.get_w() * scale), 
        this.set_w($temp00), 
        $temp00);
    }
  };

  function Quaternion_Normalize$11 ($q) {
    var q = new JSIL.BoxedVariable($q);
    var result = new JSIL.BoxedVariable(new $thisType());
    $thisType.Normalize(/* ref */ q, /* ref */ result);
    return result.get();
  };

  function Quaternion_Normalize$12 (/* ref */ q, /* ref */ result) {
    if (q.get().get_Length() <= 1.192093E-07) {
      var scale = +0;
    } else {
      scale = +(1 / q.get().get_Length());
    }
    result.set($S02().Construct($S04().CallStatic($T00(), "op_Multiply", null, q.get().get_xyz().MemberwiseClone(), scale).MemberwiseClone(), (q.get().get_w() * scale)));
  };

  function Quaternion_op_Addition (left, right) {
    var $temp00;
    (left.xyz = $T00().op_Addition(left.xyz.MemberwiseClone(), right.get_xyz().MemberwiseClone()).MemberwiseClone());
    ($temp00 = +(left.get_w() + right.get_w()), 
      left.set_w($temp00), 
      $temp00);
    return left;
  };

  function Quaternion_op_Equality (left, right) {
    return left.Equals(right);
  };

  function Quaternion_op_Inequality (left, right) {
    return !left.Equals(right);
  };

  function Quaternion_op_Multiply$13 ($left, $right) {
    var right = new JSIL.BoxedVariable($right);
    var left = new JSIL.BoxedVariable($left);
    $S06().CallStatic($thisType, "Multiply", null, /* ref */ left, /* ref */ right, /* ref */ left);
    return left.get();
  };

  function Quaternion_op_Multiply$14 ($quaternion, scale) {
    var quaternion = new JSIL.BoxedVariable($quaternion);
    $S07().CallStatic($thisType, "Multiply", null, /* ref */ quaternion, scale, /* ref */ quaternion);
    return quaternion.get();
  };

  function Quaternion_op_Multiply$15 (scale, quaternion) {
    return $S00().Construct((quaternion.get_x() * scale), (quaternion.get_y() * scale), (quaternion.get_z() * scale), (quaternion.get_w() * scale));
  };

  function Quaternion_op_Subtraction (left, right) {
    var $temp00;
    (left.xyz = $T00().op_Subtraction(left.xyz.MemberwiseClone(), right.get_xyz().MemberwiseClone()).MemberwiseClone());
    ($temp00 = +(left.get_w() - right.get_w()), 
      left.set_w($temp00), 
      $temp00);
    return left;
  };

  function Quaternion_QuaternionToEuler (q, inDegrees) {
    q.Normalize();
    var test = +(2 * ((q.get_y() * q.get_w()) - (q.get_x() * q.get_z())));
    if ($S08().CallStatic($T06(), "Equals", null, test, 1)) {
      var z = +(-2 * $T01().$Cast(Math.atan2(q.get_x(), q.get_w())));
      var x = +0;
      var y = +1.57079637;
    } else if ($S08().CallStatic($T06(), "Equals", null, test, -1)) {
      z = +(2 * $T01().$Cast(Math.atan2(q.get_x(), q.get_w())));
      x = +0;
      y = +-1.57079637;
    } else {
      var sqX = +(q.get_x() * q.get_x());
      var sqY = +(q.get_y() * q.get_y());
      var sqZ = +(q.get_z() * q.get_z());
      var sqW = +(q.get_w() * q.get_w());
      x = +$T01().$Cast(Math.atan2((2 * ((q.get_y() * q.get_z()) + (q.get_w() * q.get_x()))), (((sqW - sqX) - sqY) + sqZ)));
      y = +$T01().$Cast(Math.asin($S09().CallStatic($T06(), "Clamp", null, test, -1, 1)));
      z = +$T01().$Cast(Math.atan2((2 * ((q.get_x() * q.get_y()) + (q.get_w() * q.get_z()))), (((sqW + sqX) - sqY) - sqZ)));
    }
    if (inDegrees) {
      x = +$T06().RadiansToDegrees(x);
      y = +$T06().RadiansToDegrees(y);
      z = +$T06().RadiansToDegrees(z);
    }
    return $S01().Construct(x, y, z);
  };

  function Quaternion_QuaternionToMatrix (q) {
    q.Normalize();
    return (new ($T09())()).__Initialize__({
        M11: (1 - (2 * ((q.get_y() * q.get_y()) + (q.get_z() * q.get_z())))), 
        M12: (2 * ((q.get_x() * q.get_y()) + (q.get_z() * q.get_w()))), 
        M13: (2 * ((q.get_x() * q.get_z()) - (q.get_y() * q.get_w()))), 
        M14: 0, 
        M21: (2 * ((q.get_x() * q.get_y()) - (q.get_z() * q.get_w()))), 
        M22: (1 - (2 * ((q.get_x() * q.get_x()) + (q.get_z() * q.get_z())))), 
        M23: (2 * ((q.get_z() * q.get_y()) + (q.get_x() * q.get_w()))), 
        M24: 0, 
        M31: (2 * ((q.get_x() * q.get_z()) + (q.get_y() * q.get_w()))), 
        M32: (2 * ((q.get_y() * q.get_z()) - (q.get_x() * q.get_w()))), 
        M33: (1 - (2 * ((q.get_x() * q.get_x()) + (q.get_y() * q.get_y())))), 
        M34: 0, 
        M41: 0, 
        M42: 0, 
        M43: 0, 
        M44: 1}
    );
  };

  function Quaternion_set_w (value) {
    this._w = +value;
  };

  function Quaternion_set_x (value) {
    this._xyz.x = +value;
  };

  function Quaternion_set_xyz (value) {
    this._xyz = value;
  };

  function Quaternion_set_y (value) {
    this._xyz.y = +value;
  };

  function Quaternion_set_z (value) {
    this._xyz.z = +value;
  };

  function Quaternion_Slerp (q1, q2, blend) {
    var result = new $thisType();
    if (q1.get_LengthSquared() < 1.192093E-07) {
      var result2 = ((q2.get_LengthSquared() <= 1.192093E-07) ? $thisType.Identity : q2).MemberwiseClone();
    } else if (q2.get_LengthSquared() < 1.192093E-07) {
      result2 = q1.MemberwiseClone();
    } else {
      var cosHalfAngle = +((q1.get_w() * q2.get_w()) + $T00().Dot(
          q1.get_xyz(), 
          q2.get_xyz()
        ));
      if (!((cosHalfAngle < 1) && (cosHalfAngle > -1))) {
        result2 = q1.MemberwiseClone();
      } else {
        if (cosHalfAngle < 0) {
          (q2.xyz = $T00().op_UnaryNegation(q2.xyz.MemberwiseClone()).MemberwiseClone());
          q2.set_w(-q2.get_w());
          cosHalfAngle = +-cosHalfAngle;
        }
        if (cosHalfAngle < 0.99) {
          var halfAngle = +$T01().$Cast(Math.acos(cosHalfAngle));
          var sinHalfAngle = +$T01().$Cast(Math.sin(halfAngle));
          var oneOverSinHalfAngle = +(1 / sinHalfAngle);
          var blendA = +($T01().$Cast(Math.sin((halfAngle * (1 - blend)))) * oneOverSinHalfAngle);
          var blendB = +($T01().$Cast(Math.sin((halfAngle * blend))) * oneOverSinHalfAngle);
        } else {
          blendA = +(1 - blend);
          blendB = +blend;
        }
        $thisType.prototype._ctor.call(result, 
          $T00().op_Addition(
            $S05().CallStatic($T00(), "op_Multiply", null, blendA, q1.get_xyz().MemberwiseClone()).MemberwiseClone(), 
            $S05().CallStatic($T00(), "op_Multiply", null, blendB, q2.get_xyz().MemberwiseClone()).MemberwiseClone()
          ).MemberwiseClone(), 
          ((blendA * q1.get_w()) + (blendB * q2.get_w()))
        );
        result2 = ((result.get_LengthSquared() > 1.192093E-07) ? $thisType.Normalize(result.MemberwiseClone()) : $thisType.Identity).MemberwiseClone();
      }
    }
    return result2;
  };

  function Quaternion_Sub$16 (left, right) {
    return $S02().Construct($T00().op_Subtraction(
        left.get_xyz().MemberwiseClone(), 
        right.get_xyz().MemberwiseClone()
      ).MemberwiseClone(), (left.get_w() - right.get_w()));
  };

  function Quaternion_Sub$17 (/* ref */ left, /* ref */ right, /* ref */ result) {
    result.set($S02().Construct($T00().op_Subtraction(
          left.get().get_xyz().MemberwiseClone(), 
          right.get().get_xyz().MemberwiseClone()
        ).MemberwiseClone(), (left.get().get_w() - right.get().get_w())));
  };

  function Quaternion_ToAxisAngle$18 (/* ref */ axis, /* ref */ angle) {
    var result = this.ToAxisAngle();
    axis.set(result.get_xyz().MemberwiseClone());
    angle.set(result.w);
  };

  function Quaternion_ToAxisAngle$19 () {
    var q = this.MemberwiseClone();
    if (q.get_w() > 1) {
      q.Normalize();
    }
    var result = (new ($T0A())()).__Initialize__({
        w: (2 * $T01().$Cast(Math.acos(q.get_w())))}
    );
    var den = +$T01().$Cast(Math.sqrt((1 - (q.get_w() * q.get_w()))));
    if (den > 1.192093E-07) {
      (result.xyz = $T00().op_Division(q.get_xyz().MemberwiseClone(), den).MemberwiseClone());
    } else {
      (result.xyz = $T00().UnitX.MemberwiseClone());
    }
    return result;
  };

  function Quaternion_toString () {
    return $T0B().Format(
      "V: {0}, w: {1}", 
      this.get_xyz(), 
      this.get_w()
    );
  };

  JSIL.MakeType({
      BaseType: $asm07.TypeRef("System.ValueType"), 
      Name: "Fusee.Math.Quaternion", 
      IsPublic: true, 
      IsReferenceType: false, 
      MaximumConstructorArguments: 4, 
    }, function ($interfaceBuilder) {
    $ = $interfaceBuilder;

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.float3"), $.Single], []), 
      Quaternion__ctor$00
    );

    $.Method({Static:false, Public:true }, ".ctor", 
      new JSIL.MethodSignature(null, [
          $.Single, $.Single, 
          $.Single, $.Single
        ], []), 
      Quaternion__ctor$01
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      Quaternion_Add$02
    );

    $.Method({Static:true , Public:true }, "Add", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      Quaternion_Add$03
    );

    $.Method({Static:false, Public:true }, "Conjugate", 
      new JSIL.MethodSignature(null, [], []), 
      Quaternion_Conjugate$04
    );

    $.Method({Static:true , Public:true }, "Conjugate", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      Quaternion_Conjugate$05
    );

    $.Method({Static:true , Public:true }, "Conjugate", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      Quaternion_Conjugate$06
    );

    $.Method({Static:true , Public:true }, "CopySign", 
      new JSIL.MethodSignature($.Single, [$.Single, $.Single], []), 
      Quaternion_CopySign
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Object.Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Object], []), 
      Quaternion_Object_Equals
    );

    $.Method({Static:false, Public:true , Virtual:true }, "Equals", 
      new JSIL.MethodSignature($.Boolean, [$.Type], []), 
      Quaternion_Equals$07
    );

    $.Method({Static:true , Public:true }, "EulerToQuaternion", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.float3"), $.Boolean], []), 
      Quaternion_EulerToQuaternion
    );

    $.Method({Static:true , Public:true }, "FromAxisAngle", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.float3"), $.Single], []), 
      Quaternion_FromAxisAngle
    );

    $.Method({Static:false, Public:true }, "get_Length", 
      new JSIL.MethodSignature($.Single, [], []), 
      Quaternion_get_Length
    );

    $.Method({Static:false, Public:true }, "get_LengthSquared", 
      new JSIL.MethodSignature($.Single, [], []), 
      Quaternion_get_LengthSquared
    );

    $.Method({Static:false, Public:true }, "get_w", 
      new JSIL.MethodSignature($.Single, [], []), 
      Quaternion_get_w
    );

    $.Method({Static:false, Public:true }, "get_x", 
      new JSIL.MethodSignature($.Single, [], []), 
      Quaternion_get_x
    );

    $.Method({Static:false, Public:true }, "get_xyz", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [], []), 
      Quaternion_get_xyz
    );

    $.Method({Static:false, Public:true }, "get_y", 
      new JSIL.MethodSignature($.Single, [], []), 
      Quaternion_get_y
    );

    $.Method({Static:false, Public:true }, "get_z", 
      new JSIL.MethodSignature($.Single, [], []), 
      Quaternion_get_z
    );

    $.Method({Static:false, Public:true , Virtual:true }, "GetHashCode", 
      new JSIL.MethodSignature($.Int32, [], []), 
      Quaternion_GetHashCode
    );

    $.Method({Static:true , Public:true }, "Invert", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      Quaternion_Invert$08
    );

    $.Method({Static:true , Public:true }, "Invert", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      Quaternion_Invert$09
    );

    $.Method({Static:true , Public:true }, "LookRotation", 
      new JSIL.MethodSignature($.Type, [$asm04.TypeRef("Fusee.Math.float3"), $asm04.TypeRef("Fusee.Math.float3")], []), 
      Quaternion_LookRotation
    );

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      Quaternion_Mult$0A
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use Multiply instead."]; });

    $.Method({Static:true , Public:true }, "Mult", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      Quaternion_Mult$0B
    )
      .Attribute($asm07.TypeRef("System.ObsoleteAttribute"), function () { return ["Use Multiply instead."]; });

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      Quaternion_Multiply$0C
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      Quaternion_Multiply$0D
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $.Single, 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      Quaternion_Multiply$0E
    );

    $.Method({Static:true , Public:true }, "Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single], []), 
      Quaternion_Multiply$0F
    );

    $.Method({Static:false, Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [], []), 
      Quaternion_Normalize$10
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature($.Type, [$.Type], []), 
      Quaternion_Normalize$11
    );

    $.Method({Static:true , Public:true }, "Normalize", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type])], []), 
      Quaternion_Normalize$12
    );

    $.Method({Static:true , Public:true }, "op_Addition", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      Quaternion_op_Addition
    );

    $.Method({Static:true , Public:true }, "op_Equality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type], []), 
      Quaternion_op_Equality
    );

    $.Method({Static:true , Public:true }, "op_Inequality", 
      new JSIL.MethodSignature($.Boolean, [$.Type, $.Type], []), 
      Quaternion_op_Inequality
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      Quaternion_op_Multiply$13
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Single], []), 
      Quaternion_op_Multiply$14
    );

    $.Method({Static:true , Public:true }, "op_Multiply", 
      new JSIL.MethodSignature($.Type, [$.Single, $.Type], []), 
      Quaternion_op_Multiply$15
    );

    $.Method({Static:true , Public:true }, "op_Subtraction", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      Quaternion_op_Subtraction
    );

    $.Method({Static:true , Public:true }, "QuaternionToEuler", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float3"), [$.Type, $.Boolean], []), 
      Quaternion_QuaternionToEuler
    );

    $.Method({Static:true , Public:true }, "QuaternionToMatrix", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float4x4"), [$.Type], []), 
      Quaternion_QuaternionToMatrix
    );

    $.Method({Static:false, Public:true }, "set_w", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      Quaternion_set_w
    );

    $.Method({Static:false, Public:true }, "set_x", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      Quaternion_set_x
    );

    $.Method({Static:false, Public:true }, "set_xyz", 
      new JSIL.MethodSignature(null, [$asm04.TypeRef("Fusee.Math.float3")], []), 
      Quaternion_set_xyz
    );

    $.Method({Static:false, Public:true }, "set_y", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      Quaternion_set_y
    );

    $.Method({Static:false, Public:true }, "set_z", 
      new JSIL.MethodSignature(null, [$.Single], []), 
      Quaternion_set_z
    );

    $.Method({Static:true , Public:true }, "Slerp", 
      new JSIL.MethodSignature($.Type, [
          $.Type, $.Type, 
          $.Single
        ], []), 
      Quaternion_Slerp
    );

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature($.Type, [$.Type, $.Type], []), 
      Quaternion_Sub$16
    );

    $.Method({Static:true , Public:true }, "Sub", 
      new JSIL.MethodSignature(null, [
          $jsilcore.TypeRef("JSIL.Reference", [$.Type]), $jsilcore.TypeRef("JSIL.Reference", [$.Type]), 
          $jsilcore.TypeRef("JSIL.Reference", [$.Type])
        ], []), 
      Quaternion_Sub$17
    );

    $.Method({Static:false, Public:true }, "ToAxisAngle", 
      new JSIL.MethodSignature(null, [$jsilcore.TypeRef("JSIL.Reference", [$asm04.TypeRef("Fusee.Math.float3")]), $jsilcore.TypeRef("JSIL.Reference", [$.Single])], []), 
      Quaternion_ToAxisAngle$18
    );

    $.Method({Static:false, Public:true }, "ToAxisAngle", 
      new JSIL.MethodSignature($asm04.TypeRef("Fusee.Math.float4"), [], []), 
      Quaternion_ToAxisAngle$19
    );

    $.Method({Static:false, Public:true , Virtual:true }, "toString", 
      new JSIL.MethodSignature($.String, [], []), 
      Quaternion_toString
    );

    $.Field({Static:false, Public:false}, "_xyz", $asm04.TypeRef("Fusee.Math.float3")); 
    $.Field({Static:false, Public:false}, "_w", $.Single); 
    $.Field({Static:true , Public:true }, "Identity", $.Type); 
    function Quaternion__cctor () {
      $thisType.Identity = new $thisType();
      $thisType.Identity = $S00().Construct(0, 0, 0, 1);
    };


    $.Method({Static:true , Public:false}, ".cctor", 
      new JSIL.MethodSignature(null, [], []), 
      Quaternion__cctor
    );

    $.Property({Static:false, Public:true }, "xyz", $asm04.TypeRef("Fusee.Math.float3"));

    $.Property({Static:false, Public:true }, "x", $.Single);

    $.Property({Static:false, Public:true }, "y", $.Single);

    $.Property({Static:false, Public:true }, "z", $.Single);

    $.Property({Static:false, Public:true }, "w", $.Single);

    $.Property({Static:false, Public:true }, "Length", $.Single);

    $.Property({Static:false, Public:true }, "LengthSquared", $.Single);

    $.ImplementInterfaces(
      /* 0 */ $asm07.TypeRef("System.IEquatable`1", [$.Type])
    );

    return function (newThisType) { $thisType = newThisType; }; 
  });

})();

